<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ 近红外人脸定位与深度图人脸活体检测（.raw深度图像）]]></title>
    <url>%2F2018%2F10%2F22%2F12%2F</url>
    <content type="text"><![CDATA[通过深度相机的红外图进行人脸位置定位，传给深度图进行活体检测注：利用rgb传来的位置对应到深度图上偏差过大，直接利用深度相机产生的红外图像进行人脸位置的确定更加精准。 运行dlib_test.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;dlib/image_processing/frontal_face_detector.h&gt;#include &lt;dlib/gui_widgets.h&gt;#include &lt;dlib/image_io.h&gt;#include &lt;iostream&gt;#include &lt;time.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdlib.h&gt;using namespace dlib;using namespace std;/* 函数声明 */int *face_location(char *imgFile);bool liveness_detection(char *DeepFile, int rec_face[4]); const int IMG_HEIGHT = 720;const int IMG_WIDTH = 1280;int main()&#123; char *imgFile = "/home/zhoujie/cProject/dlib_test/0001_IR_frontface.jpg"; int *rec_face; /* 调用函数得到人脸位置 */ // Eg:rec_face = &#123;157 ,66 ,172 ,198 &#125;, 行取66：66+198,列取157：157+172 rec_face = face_location(imgFile); //深度图与红外图是水平翻转的 rec_face[0] = IMG_WIDTH - rec_face[0] -rec_face[2]; cout &lt;&lt; rec_face[0] &lt;&lt; endl; cout &lt;&lt; rec_face[1] &lt;&lt; endl; cout &lt;&lt; rec_face[2] &lt;&lt; endl; cout &lt;&lt; rec_face[3] &lt;&lt; endl; char *DeepFile = "/home/zhoujie/cProject/dlib_test/raw_0001_frontface.raw"; bool IS_FACE; /* 调用函数判断是否为活体 */ IS_FACE = liveness_detection( DeepFile, rec_face); printf("RESULT : %d\n", IS_FACE); delete rec_face;&#125;/* 函数 输出人脸位置 */int *face_location(char* imgFile)&#123; int *rec_face = new int[4]; frontal_face_detector detector = get_frontal_face_detector(); cout &lt;&lt; "processing image " &lt;&lt; imgFile &lt;&lt; endl; clock_t start,finish; double totaltime; start=clock(); array2d&lt;unsigned char&gt; img; load_image(img, imgFile); std::vector&lt;rectangle&gt; dets = detector(img); cout &lt;&lt; "Number of faces detected: " &lt;&lt; dets.size() &lt;&lt; endl; rec_face[0] = dets[0].left(); rec_face[1] = dets[0].top(); rec_face[2] = dets[0].right() - dets[0].left() + 1; rec_face[3] = dets[0].bottom() - dets[0].top() + 1; finish=clock(); totaltime=(double)(finish-start)/CLOCKS_PER_SEC; cout&lt;&lt;"\n此程序的运行时间为"&lt;&lt;totaltime&lt;&lt;"秒！"&lt;&lt;endl; // delete rec_face; return rec_face;&#125;/* 函数判断是否为活体 */bool liveness_detection(char *DeepFile, int rec_face[4])&#123; const int ITER = 10000; // 随机取点次数 const float PLANE_OR_NOT = 0.1; // 判断是否为平面的分界线 const int SIGMA = 1; typedef unsigned short UNIT16; // 从.raw读取二进制16位数据到MatDATA UNIT16 MatDATA[IMG_HEIGHT*IMG_WIDTH]; FILE *fp = NULL; fp = fopen( DeepFile, "rb" ); fread(MatDATA,sizeof(UNIT16),IMG_HEIGHT*IMG_WIDTH,fp); fclose(fp); int n = 0; int i,j; int COL = rec_face[0],ROW = rec_face[1],FACE_WIDTH = rec_face[2],FACE_HEIGHT = rec_face[3]; //位置信息 // txt :157 66 172 198 , 取行66：66+198,列取157：157+172 int faceno0_num = FACE_HEIGHT*FACE_WIDTH -1; int FaceDATA[3][160000]; n = 0; for(i = 1;i&lt; FACE_HEIGHT+1;i++) &#123; for(j= 1;j&lt; FACE_WIDTH+1;j++) &#123; if (MatDATA[IMG_WIDTH*(ROW+i-2)+COL+j-2] == 0) &#123; faceno0_num -= 1; // 非零深度点个数为 faceno0_num+1 continue; &#125; FaceDATA[1][n] = i; FaceDATA[0][n] = j; FaceDATA[2][n] = MatDATA[IMG_WIDTH*(ROW+i-2)+COL+j-2]; n += 1; &#125; &#125; int pretotal = 0; // 符合拟合模型的数据的个数 int x[3],y[3],z[3]; // 随机取三个点 srand((unsigned)time(NULL)); float a,b,c; // 拟合平面方程 z=ax+by+c // float besta,bestb,bestc; // 最佳参数 int rand_num[3]; float check,distance; int total = 0; for(i = 0; i &lt; ITER; i++) &#123; do&#123; rand_num[0] = std::rand()%faceno0_num; rand_num[1] = std::rand()%faceno0_num; rand_num[2] = std::rand()%faceno0_num; &#125;while(rand_num[0] == rand_num[1] || rand_num[0] == rand_num[2] || rand_num[1] == rand_num[2]); for(n = 0; n &lt; 3; n++ ) &#123; x[n] = FaceDATA[0][rand_num[n]]; y[n] = FaceDATA[1][rand_num[n]]; z[n] = FaceDATA[2][rand_num[n]]; // printf("%d,%d,%d,%d\n", x[n],y[n],z[n],n); &#125; check = (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]); if ( check == 0) // 防止提示浮点数例外 (核心已转储) &#123; i -= 1; continue; &#125; a = ( (z[0]-z[1])*(y[0]-y[2]) - (z[0]-z[2])*(y[0]-y[1]) )/( (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]) ); if (y[0] == y[2]) // 防止提示浮点数例外 (核心已转储) &#123; i -= 1; continue; &#125; b = ((z[0] - z[2]) - a * (x[0] - x[2]))/(y[0]-y[2]); c = z[0]- a * x[0] - b * y[0]; // printf("%f,%f,%f\n",a,b,c); total = 0; for(n = 0; n &lt; faceno0_num +1 ; n++ ) &#123; distance = fabs(a*FaceDATA[0][n] + b*FaceDATA[1][n] - 1*FaceDATA[2][n] + c*1); if (distance &lt; SIGMA) &#123; total +=1; &#125; &#125; // printf("%d,%f,%d\n",i,distance,total); if (total &gt; pretotal) // 找到符合拟合平面数据最多的拟合平面 &#123; pretotal=total; &#125; &#125; float pretotal_ary = pretotal *1.0/ faceno0_num ; printf("%d,%f\n", pretotal,pretotal_ary); bool IS_FACE; if (pretotal_ary &lt; PLANE_OR_NOT) &#123; IS_FACE = true; &#125; else &#123; IS_FACE = false; &#125; return IS_FACE;&#125; Ubuntu下编译Dlib库参考这里 https://blog.csdn.net/ffcjjhv/article/details/84660869修改CMakeLists.txt相应路径cmake .make./dlib_test 运行结果项目地址：https://github.com/zj19941113/Face-Liveness_detection 活检部分原理Func_liveness_detection.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dirent.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;#include &lt;stdbool.h&gt;const int IMG_HEIGHT = 345;const int IMG_WIDTH = 400;const int ITER = 10000; // 随机取点次数const float PLANE_OR_NOT = 0.1; // 判断是否为平面的分界线typedef unsigned short UNIT16;int readFileList(char *basePath)&#123; DIR *dir; struct dirent *ptr; char base[8]; char title[4]; char *p=".raw"; //需要的子串; char *p2=".txt"; char *padd="/"; int len; char Deepfile_raw[100]; char Deepfile_txt[100]; UNIT16 MatDATA[IMG_HEIGHT*IMG_WIDTH]; FILE *fp = NULL; int DeepDATA[3][IMG_HEIGHT*IMG_WIDTH]; int length; int n; int i,j; FILE *fp2 = NULL; char buf[20]; char *ptr2; int rec_face[4]; int COL ,ROW ,FACE_WIDTH ,FACE_HEIGHT ; int FaceDATA[3][40000]; int faceno0_num ; int sigma = 1; int pretotal; // 符合拟合模型的数据的个数 int x[3],y[3],z[3]; // 随机取三个点 float a,b,c; // 拟合平面方程 z=ax+by+c // float besta,bestb,bestc; // 最佳参数 int rand_num[3]; float check,distance; int total; if ((dir=opendir(basePath)) == NULL) &#123; perror("Open dir error..."); exit(1); &#125; while ((ptr=readdir(dir)) != NULL) &#123; strcpy(base, ptr-&gt;d_name); if(strstr(base,p)) &#123; len = strlen(base); memset(title, '\0', sizeof(title)); strncpy(title, base, len -4); strcpy(Deepfile_raw, basePath); strcat(Deepfile_raw, padd); strcat(Deepfile_raw, title); strcpy(Deepfile_txt, Deepfile_raw); strcat(Deepfile_raw, p); strcat(Deepfile_txt, p2); // printf("%s\n",Deepfile_raw); // printf("%s\n",Deepfile_txt); // 从.raw读取二进制16位数据到MatDATA fp = fopen( Deepfile_raw, "rb" ); fread(MatDATA,sizeof(UNIT16),IMG_HEIGHT*IMG_WIDTH,fp); fclose(fp); // length = sizeof(MatDATA) / sizeof(UNIT16); // printf("数组的长度为: %d\n",length); //length 应为IMG_HEIGHT*IMG_WIDTH n = 0; // DeepDATA三行分别为深度图行数，列数，深度信息 for(i=1;i&lt; IMG_HEIGHT+1 ;i++) &#123; for(j=1;j&lt; IMG_WIDTH+1 ;j++) &#123; DeepDATA[0][n] = i; DeepDATA[1][n] = j; DeepDATA[2][n] = MatDATA[n]; n += 1; &#125; &#125; // int test1 = 110194 ; // printf("%d,%d,%d\n",DeepDATA[0][test1],DeepDATA[1][test1],DeepDATA[2][test1]); // FaceDATA为深度图DeepDATA裁剪后且去除零深度信息后的人脸部分 n = 0; fp2 = fopen(Deepfile_txt, "r"); fgets(buf, 20, fp2); // printf("%s\n", buf ); ptr2 = strtok(buf, " "); for(n = 0; n &lt; 4; n++) &#123; rec_face[n] = atoi(ptr2); ptr2 = strtok(NULL, " "); &#125; fclose(fp2); COL = rec_face[0],ROW = rec_face[1],FACE_WIDTH = rec_face[2],FACE_HEIGHT = rec_face[3]; //位置信息 // txt :157 66 172 198 , 取行66：66+198,列取157：157+172 faceno0_num = FACE_HEIGHT*FACE_WIDTH -1; n = 0; for(i = 1;i&lt; FACE_HEIGHT+1;i++) &#123; for(j= 1;j&lt; FACE_WIDTH+1;j++) &#123; if (MatDATA[IMG_WIDTH*(ROW+i-2)+COL+j-2] == 0) &#123; faceno0_num -= 1; // 非零深度点个数为 faceno0_num+1 continue; &#125; FaceDATA[1][n] = i; FaceDATA[0][n] = j; FaceDATA[2][n] = MatDATA[IMG_WIDTH*(ROW+i-2)+COL+j-2]; n += 1; &#125; &#125; // int test = 6804; // printf("%d,%d,%d,%d\n",test,FaceDATA[0][test],FaceDATA[1][test],FaceDATA[2][test]); srand((unsigned)time(NULL)); pretotal = 0; total = 0; for(i = 0; i &lt; ITER; i++) &#123; do&#123; rand_num[0] = rand()%faceno0_num; rand_num[1] = rand()%faceno0_num; rand_num[2] = rand()%faceno0_num; &#125;while(rand_num[0] == rand_num[1] || rand_num[0] == rand_num[2] || rand_num[1] == rand_num[2]); for(n = 0; n &lt; 3; n++ ) &#123; x[n] = FaceDATA[0][rand_num[n]]; y[n] = FaceDATA[1][rand_num[n]]; z[n] = FaceDATA[2][rand_num[n]]; // printf("%d,%d,%d,%d\n", x[n],y[n],z[n],n); &#125; check = (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]); if ( check == 0) // 防止提示浮点数例外 (核心已转储) &#123; i -= 1; continue; &#125; a = ( (z[0]-z[1])*(y[0]-y[2]) - (z[0]-z[2])*(y[0]-y[1]) )*1.0/( (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]) ); if (y[0] == y[2]) // 防止提示浮点数例外 (核心已转储) &#123; i -= 1; continue; &#125; b = ((z[0] - z[2]) - a * (x[0] - x[2]))*1.0/(y[0]-y[2]); c = z[0]- a * x[0] - b * y[0]; // printf("%f,%f,%f\n",a,b,c); total = 0; for(n = 0; n &lt; faceno0_num +1 ; n++ ) &#123; distance = fabs(a*FaceDATA[0][n] + b*FaceDATA[1][n] - 1*FaceDATA[2][n] + c*1); if (distance &lt; sigma) &#123; total +=1; &#125; &#125; // printf("%d,%f,%d\n",i,distance,total); if (total &gt; pretotal) // 找到符合拟合平面数据最多的拟合平面 &#123; pretotal=total; // besta = a; // bestb = b; // bestc = c; &#125; &#125; float pretotal_ary = pretotal *1.0/ faceno0_num ; printf("pretotal = %d,_ary = %f,",pretotal,pretotal_ary); printf("%s",base); bool IS_FACE; if (pretotal_ary&gt;PLANE_OR_NOT) &#123; IS_FACE = false; printf("不是人脸\n"); &#125; else &#123; IS_FACE = true; printf("是人脸\n"); &#125; &#125; &#125; closedir(dir);&#125;int main(void)&#123; DIR *dir; char *basePath = "/home/zhoujie/liveness detection/raw文件/non-face"; readFileList(basePath); return 0;&#125; github地址：https://github.com/zj19941113/Face-Liveness_detection上面这个项目使用的数据集标定的不太准，PLANE_OR_NOT参数选为 0.1 这个数据集是自己标定的，数量较少但是比较准确： https://pan.baidu.com/s/161xSbayGW7tKg0tKfTW1mw ，PLANE_OR_NOT参数选为 0.2 快速鼠标标定深度图人脸位置： https://blog.csdn.net/ffcjjhv/article/details/83270002]]></content>
      <categories>
        <category>课题项目</category>
      </categories>
      <tags>
        <tag>深度图</tag>
        <tag>活体检测</tag>
        <tag>C++</tag>
        <tag>近红外人脸定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab 深度图人脸活体检测（.raw深度图像）]]></title>
    <url>%2F2018%2F10%2F22%2F11%2F</url>
    <content type="text"><![CDATA[github地址：https://github.com/zj19941113/Deep-Img-Liveness-Detection上面这个项目使用的数据集标定的不太准，PLANE_OR_NOT参数选为 0.1 这个数据集是自己标定的，数量较少但是比较准确： https://pan.baidu.com/s/161xSbayGW7tKg0tKfTW1mw ，PLANE_OR_NOT参数选为 0.2 快速鼠标标定深度图人脸位置： https://blog.csdn.net/ffcjjhv/article/details/83270002 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556RAW_PATH = '/home/zhoujie/liveness detection/zjraw/non-face/';PLANE_OR_NOT = 0.2; %根据标定位置的准确程度修改阈值ITER = 10000; %10000次结果基本已经稳定，不用修改file =dir([RAW_PATH ,'*.raw']);for num=1:length(file)f1 = fopen([RAW_PATH,file(num).name], 'r');txtname = strrep(file(num).name,'.raw','.txt');[par1,par2,par3,par4] = textread([RAW_PATH,txtname],'%d%d%d%d',1);data0 = fread(f1, 'uint16');fclose(f1);img1 = reshape(data0, 400, 345);dep_img = img1';% dep_img(find(dep_img &gt; 600))= 0;% figure(1),imshow(dep_img,[400,580]); face = dep_img(par2 :par2 +par4,par1 :par1 + par3); % figure(2),imshow(face,[400,580]); %%%三维平面拟合[X Y]=meshgrid(1:size(face,2),1:size(face,1));zz=face(:);xx=X(:);yy=Y(:);data=[xx';yy';zz'];id = data(3,:) == 0;data(:,id) = [];number = size(data,2); % 总点数sigma = 1;pretotal=0; %符合拟合模型的数据的个数for i=1:ITER %%% 随机选择三个点 idx = randperm(number,3); sample = data(:,idx); %%%拟合直线方程 z=ax+by+c plane = zeros(1,3); x = sample(1,:); y = sample(2,:); z = sample(3,:); a = ((z(1)-z(2))*(y(1)-y(3)) - (z(1)-z(3))*(y(1)-y(2)))/((x(1)-x(2))*(y(1)-y(3)) - (x(1)-x(3))*(y(1)-y(2))); b = ((z(1) - z(3)) - a * (x(1) - x(3)))/(y(1)-y(3)); c = z(1) - a * x(1) - b * y(1); plane = [a b -1 c]; mask=abs(plane*[data; ones(1,size(data,2))]); %求每个数据到拟合平面的距离 total=sum(mask&lt;sigma); %计算数据距离平面小于一定阈值的数据的个数 if total&gt;pretotal %找到符合拟合平面数据最多的拟合平面 pretotal=total;% bestplane=plane; %找到最好的拟合平面 end endpretotal_ary = pretotal/number;% potable(num) = pretotal_ary;if(pretotal_ary&gt;PLANE_OR_NOT) descrip = '不是人脸';elsedescrip = '是人脸'; enddisp(['pretotal=',num2str(pretotal),',','_ary=',num2str(pretotal_ary),',',file(num).name,descrip]);end]]></content>
      <categories>
        <category>课题项目</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>深度图</tag>
        <tag>活体检测</tag>
        <tag>人脸</tag>
        <tag>raw</tag>
      </tags>
  </entry>
</search>
