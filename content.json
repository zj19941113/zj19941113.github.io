{"meta":{"title":"ZhouJie's Blog","subtitle":"向阳而生","description":"C++ / 后台开发 / Three","author":"ZhouJie","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About Me | Ms.Zhou","date":"2019-06-18T09:42:22.000Z","updated":"2019-12-18T03:48:14.625Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"大家好，我是就读于西安交通大学的一名研三学生，热爱学习新知识，探索新技术； 下面是我的博客地址，希望能和大家多交流，分享经验技术： github地址：https://github.com/zj19941113 CSDN地址：https://blog.csdn.net/ffcjjhv"},{"title":"分类","date":"2019-06-18T09:38:00.000Z","updated":"2019-06-18T09:41:57.214Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-18T09:42:15.000Z","updated":"2019-06-18T09:43:14.708Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"刷题汇总（六）leetcode 多线程 / Shell","slug":"33","date":"2019-12-17T13:55:52.000Z","updated":"2019-12-18T04:25:50.464Z","comments":true,"path":"2019/12/17/33/","link":"","permalink":"http://yoursite.com/2019/12/17/33/","excerpt":"题目来源 leetcode 多线程 / Shell 相关：刷题汇总（一）leetcode 精选50题 JavaScript答案总结刷题汇总（二）剑指Offer 66题 C++答案总结刷题汇总（三）leetcode 精选50题 C++答案总结刷题汇总（四）技术类编程题汇总 C++刷题汇总（五）leetcode 热题 HOT 100 C++ 答案总结 这篇文章使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。","text":"题目来源 leetcode 多线程 / Shell 相关：刷题汇总（一）leetcode 精选50题 JavaScript答案总结刷题汇总（二）剑指Offer 66题 C++答案总结刷题汇总（三）leetcode 精选50题 C++答案总结刷题汇总（四）技术类编程题汇总 C++刷题汇总（五）leetcode 热题 HOT 100 C++ 答案总结 这篇文章使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。 知识点1：创建线程/终止线程 #include &lt;pthread.h&gt;pthread_create (thread, attr, start_routine, arg)pthread_exit (status) 使用 -lpthread 库编译：$ g++ test.cpp -lpthread -o test.o 多线程1、按序打印我们提供了一个类： 12345public class Foo &#123; public void one() &#123; print(&quot;one&quot;); &#125; public void two() &#123; print(&quot;two&quot;); &#125; public void three() &#123; print(&quot;three&quot;); &#125;&#125; 三个不同的线程将会共用一个 Foo 实例。 线程 A 将会调用 one() 方法线程 B 将会调用 two() 方法线程 C 将会调用 three() 方法请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。 示例 1: 输入: [1,2,3]输出: “onetwothree”解释:有三个线程会被异步启动。输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。正确的输出是 “onetwothree”。示例 2: 输入: [1,3,2]输出: “onetwothree”解释:输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。正确的输出是 “onetwothree”。 注意: 尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。你看到的输入格式主要是为了确保测试的全面性。 12345678910111213141516171819202122232425262728293031#include &lt;semaphore.h&gt;class Foo &#123;public: sem_t t1, t2, t3; Foo() &#123; sem_init(&amp;t1,0,1); sem_init(&amp;t2,0,0); sem_init(&amp;t3,0,0); &#125; void first(function&lt;void()&gt; printFirst) &#123; sem_wait(&amp;t1); // printFirst() outputs \"first\". Do not change or remove this line. printFirst(); sem_post(&amp;t2); &#125; void second(function&lt;void()&gt; printSecond) &#123; sem_wait(&amp;t2); // printSecond() outputs \"second\". Do not change or remove this line. printSecond(); sem_post(&amp;t3); &#125; void third(function&lt;void()&gt; printThird) &#123; sem_wait(&amp;t3); // printThird() outputs \"third\". Do not change or remove this line. printThird(); &#125;&#125;; 知识点2：信号量 #include &lt;semaphore.h&gt;int sem_init(sem_t *sem, int pshared, unsigned int val); // 初始化信号量int sem_wait(sem_t *sem); // 信号量减1int sem_post(sem_t *sem); // 信号量加1int sem_destory(sem_t *sem); // 销毁信号量 2、交替打印FooBar我们提供一个类： 12345678910111213class FooBar &#123; public void foo() &#123; for (int i = 0; i &lt; n; i++) &#123; print(&quot;foo&quot;); &#125; &#125; public void bar() &#123; for (int i = 0; i &lt; n; i++) &#123; print(&quot;bar&quot;); &#125; &#125;&#125; 两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。 请设计修改程序，以确保 “foobar” 被输出 n 次。 示例 1: 输入: n = 1输出: “foobar”解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，”foobar” 将被输出一次。示例 2: 输入: n = 2输出: “foobarfoobar” 123456789101112131415161718192021222324252627282930# include&lt;semaphore.h&gt;class FooBar &#123;private: int n; sem_t t1, t2;public: FooBar(int n) &#123; this-&gt;n = n; sem_init(&amp;t1,0,1); sem_init(&amp;t2,0,0); &#125; void foo(function&lt;void()&gt; printFoo) &#123; for (int i = 0; i &lt; n; i++) &#123; sem_wait(&amp;t1); // printFoo() outputs \"foo\". Do not change or remove this line. printFoo(); sem_post(&amp;t2); &#125; &#125; void bar(function&lt;void()&gt; printBar) &#123; for (int i = 0; i &lt; n; i++) &#123; sem_wait(&amp;t2); // printBar() outputs \"bar\". Do not change or remove this line. printBar(); sem_post(&amp;t1); &#125; &#125;&#125;; 123456789101112131415161718192021222324252627282930class FooBar &#123;private: int n; pthread_mutex_t t1, t2;public: FooBar(int n) &#123; this-&gt;n = n; pthread_mutex_init(&amp;t1,NULL); pthread_mutex_init(&amp;t2,NULL); pthread_mutex_lock(&amp;t2); &#125; void foo(function&lt;void()&gt; printFoo) &#123; for (int i = 0; i &lt; n; i++) &#123; pthread_mutex_lock(&amp;t1); // printFoo() outputs \"foo\". Do not change or remove this line. printFoo(); pthread_mutex_unlock(&amp;t2); &#125; &#125; void bar(function&lt;void()&gt; printBar) &#123; for (int i = 0; i &lt; n; i++) &#123; pthread_mutex_lock(&amp;t2); // printBar() outputs \"bar\". Do not change or remove this line. printBar(); pthread_mutex_unlock(&amp;t1); &#125; &#125;&#125;; 知识点3：互斥量pthread_mutex_t sum_mutex; //互斥锁pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER //静态初始化pthread_mutex_init( &amp;sum_mutex, NULL ); //动态初始化 初始化成功返回0pthread_mutex_lock( &amp;sum_mutex ); //加锁pthread_mutex_unlock( &amp;sum_mutex ); //释放锁，供其他线程使用pthread_mutex_destroy( &amp;sum_mutex ); //注销锁 3、打印零与奇偶数假设有这么一个类： 123456class ZeroEvenOdd &#123; public ZeroEvenOdd(int n) &#123; ... &#125; // 构造函数 public void zero(printNumber) &#123; ... &#125; // 仅打印出 0 public void even(printNumber) &#123; ... &#125; // 仅打印出 偶数 public void odd(printNumber) &#123; ... &#125; // 仅打印出 奇数&#125; 相同的一个 ZeroEvenOdd 类实例将会传递给三个不同的线程： 线程 A 将调用 zero()，它只输出 0 。线程 B 将调用 even()，它只输出偶数。线程 C 将调用 odd()，它只输出奇数。每个线程都有一个 printNumber 方法来输出一个整数。请修改给出的代码以输出整数序列 010203040506… ，其中序列的长度必须为 2n。 示例 1： 输入：n = 2输出：”0102”说明：三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 “0102”。示例 2： 输入：n = 5输出：”0102030405” 123456789101112131415161718192021222324252627282930313233343536373839# include&lt;semaphore.h&gt;class ZeroEvenOdd &#123;private: int n; sem_t t0, t1, t2;public: ZeroEvenOdd(int n) &#123; this-&gt;n = n; sem_init(&amp;t0,0,1); sem_init(&amp;t1,0,0); sem_init(&amp;t2,0,0); &#125; // printNumber(x) outputs \"x\", where x is an integer. void zero(function&lt;void(int)&gt; printNumber) &#123; for(int i=1;i&lt;=n;i++)&#123; sem_wait(&amp;t0); printNumber(0); if(i%2==1) sem_post(&amp;t1); else sem_post(&amp;t2); &#125; &#125; void even(function&lt;void(int)&gt; printNumber) &#123; for(int i=2;i&lt;=n;i+=2)&#123; sem_wait(&amp;t2); printNumber(i); sem_post(&amp;t0); &#125; &#125; void odd(function&lt;void(int)&gt; printNumber) &#123; for(int i=1;i&lt;=n;i+=2)&#123; sem_wait(&amp;t1); printNumber(i); sem_post(&amp;t0); &#125; &#125;&#125;; 4、H2O 生成现在有两种线程，氢 oxygen 和氧 hydrogen，你的目标是组织这两种线程来产生水分子。 存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。 氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。 这些线程应该三三成组突破屏障并能立即组合产生一个水分子。 你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。 换句话说: 如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。书写满足这些限制条件的氢、氧线程同步代码。 示例 1: 输入: “HOH”输出: “HHO”解释: “HOH” 和 “OHH” 依然都是有效解。示例 2: 输入: “OOHHHH”输出: “HHOHHO”解释: “HOHHHO”, “OHHHHO”, “HHOHOH”, “HOHHOH”, “OHHHOH”, “HHOOHH”, “HOHOHH” 和 “OHHOHH” 依然都是有效解。 限制条件: 输入字符串的总长将会是 3n, 1 ≤ n ≤ 50；输入字符串中的 “H” 总数将会是 2n；输入字符串中的 “O” 总数将会是 n。 1234567891011121314151617181920212223242526272829303132# include&lt;semaphore.h&gt;class H2O &#123;public: sem_t h_limit, o_limit, h, o; H2O() &#123; sem_init(&amp;h_limit,0,2); sem_init(&amp;o_limit,0,1); sem_init(&amp;h,0,0); sem_init(&amp;o,0,0); &#125; void hydrogen(function&lt;void()&gt; releaseHydrogen) &#123; sem_wait(&amp;h_limit); sem_post(&amp;h); sem_wait(&amp;o); // releaseHydrogen() outputs \"H\". Do not change or remove this line. releaseHydrogen(); sem_post(&amp;h_limit); &#125; void oxygen(function&lt;void()&gt; releaseOxygen) &#123; sem_wait(&amp;o_limit); sem_post(&amp;o); sem_post(&amp;o); sem_wait(&amp;h); sem_wait(&amp;h); // releaseOxygen() outputs \"O\". Do not change or remove this line. releaseOxygen(); sem_post(&amp;o_limit); &#125;&#125;; 5、交替打印字符串编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是： 如果这个数字可以被 3 整除，输出 “fizz”。如果这个数字可以被 5 整除，输出 “buzz”。如果这个数字可以同时被 3 和 5 整除，输出 “fizzbuzz”。例如，当 n = 15，输出： 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。 假设有这么一个类： 1234567class FizzBuzz &#123; public FizzBuzz(int n) &#123; ... &#125; // constructor public void fizz(printFizz) &#123; ... &#125; // only output &quot;fizz&quot; public void buzz(printBuzz) &#123; ... &#125; // only output &quot;buzz&quot; public void fizzbuzz(printFizzBuzz) &#123; ... &#125; // only output &quot;fizzbuzz&quot; public void number(printNumber) &#123; ... &#125; // only output the numbers&#125; 请你实现一个有四个线程的多线程版 FizzBuzz， 同一个 FizzBuzz 实例会被如下四个线程使用： 线程A将调用 fizz() 来判断是否能被 3 整除，如果可以，则输出 fizz。线程B将调用 buzz() 来判断是否能被 5 整除，如果可以，则输出 buzz。线程C将调用 fizzbuzz() 来判断是否同时能被 3 和 5 整除，如果可以，则输出 fizzbuzz。线程D将调用 number() 来实现输出既不能被 3 整除也不能被 5 整除的数字。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# include&lt;semaphore.h&gt;class FizzBuzz &#123;private: int n; sem_t t0, t3, t5, t35;public: FizzBuzz(int n) &#123; this-&gt;n = n; sem_init(&amp;t0,0,1); sem_init(&amp;t3,0,0); sem_init(&amp;t5,0,0); sem_init(&amp;t35,0,0); &#125; // printFizz() outputs \"fizz\". void fizz(function&lt;void()&gt; printFizz) &#123; for(int i=1;i&lt;=n;i++)&#123; if(i%3==0 &amp;&amp; i%5!=0)&#123; sem_wait(&amp;t3); printFizz(); sem_post(&amp;t0); &#125; &#125; &#125; // printBuzz() outputs \"buzz\". void buzz(function&lt;void()&gt; printBuzz) &#123; for(int i=1;i&lt;=n;i++)&#123; if(i%3!=0 &amp;&amp; i%5==0)&#123; sem_wait(&amp;t5); printBuzz(); sem_post(&amp;t0); &#125; &#125; &#125; // printFizzBuzz() outputs \"fizzbuzz\". void fizzbuzz(function&lt;void()&gt; printFizzBuzz) &#123; for(int i=1;i&lt;=n;i++)&#123; if(i%3==0 &amp;&amp; i%5==0)&#123; sem_wait(&amp;t35); printFizzBuzz(); sem_post(&amp;t0); &#125; &#125; &#125; // printNumber(x) outputs \"x\", where x is an integer. void number(function&lt;void(int)&gt; printNumber) &#123; for(int i=1;i&lt;=n;i++)&#123; sem_wait(&amp;t0); if(i%3!=0 &amp;&amp; i%5!=0)&#123; printNumber(i); sem_post(&amp;t0); &#125; else if(i%3==0 &amp;&amp; i%5!=0)&#123; sem_post(&amp;t3); &#125; else if(i%3!=0 &amp;&amp; i%5==0)&#123; sem_post(&amp;t5); &#125; else&#123; sem_post(&amp;t35); &#125; &#125; &#125;&#125;; 6、哲学家进餐5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子） 所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。 假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。 设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。 问题描述和图片来自维基百科 wikipedia.org 哲学家从 0 到 4 按 顺时针 编号。请实现函数 void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)： philosopher 哲学家的编号。pickLeftFork 和 pickRightFork 表示拿起左边或右边的叉子。eat 表示吃面。putLeftFork 和 pickRightFork 表示放下左边或右边的叉子。由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。 示例： 输入：n = 1输出：[[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]解释:n 表示每个哲学家需要进餐的次数。输出数组描述了叉子的控制和进餐的调用，它的格式如下：output[i] = [a, b, c] (3个整数) a 哲学家编号。 b 指定叉子：{1 : 左边, 2 : 右边}. c 指定行为：{1 : 拿起, 2 : 放下, 3 : 吃面}。如 [4,2,1] 表示 4 号哲学家拿起了右边的叉子。 提示：1 &lt;= n &lt;= 60 123456789101112131415161718192021222324252627282930313233343536373839404142# include&lt;semaphore.h&gt;class DiningPhilosophers &#123;private: sem_t sem; pthread_mutex_t mutex[5];public: DiningPhilosophers() &#123; sem_init(&amp;sem,0,4); for(int i=0;i&lt;5;i++)&#123; pthread_mutex_init(&amp;mutex[i],NULL); &#125; &#125; // 限定哲学家就餐数量 void wantsToEat(int philosopher, function&lt;void()&gt; pickLeftFork, function&lt;void()&gt; pickRightFork, function&lt;void()&gt; eat, function&lt;void()&gt; putLeftFork, function&lt;void()&gt; putRightFork) &#123; int left = philosopher; int right = (philosopher+1)%5; sem_wait(&amp;sem); pthread_mutex_lock(&amp;mutex[left]); pthread_mutex_lock(&amp;mutex[right]); pickLeftFork(); pickRightFork(); eat(); putLeftFork(); putRightFork(); pthread_mutex_unlock(&amp;mutex[left]); pthread_mutex_unlock(&amp;mutex[right]); sem_post(&amp;sem); &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243# include&lt;semaphore.h&gt;class DiningPhilosophers &#123;private: pthread_mutex_t mutex; pthread_mutex_t forks_mutex[5];public: DiningPhilosophers() &#123; pthread_mutex_init(&amp;mutex,NULL); for(int i=0;i&lt;5;i++)&#123; pthread_mutex_init(&amp;forks_mutex[i],NULL); &#125; &#125; // 同时拿起左右2把叉子 void wantsToEat(int philosopher, function&lt;void()&gt; pickLeftFork, function&lt;void()&gt; pickRightFork, function&lt;void()&gt; eat, function&lt;void()&gt; putLeftFork, function&lt;void()&gt; putRightFork) &#123; int left = philosopher; int right = (philosopher+1)%5; pthread_mutex_lock(&amp;mutex); pthread_mutex_lock(&amp;forks_mutex[left]); pthread_mutex_lock(&amp;forks_mutex[right]); pickLeftFork(); pickRightFork(); pthread_mutex_unlock(&amp;mutex); eat(); putLeftFork(); putRightFork(); pthread_mutex_unlock(&amp;forks_mutex[left]); pthread_mutex_unlock(&amp;forks_mutex[right]); &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445# include&lt;semaphore.h&gt;class DiningPhilosophers &#123;private: pthread_mutex_t forks_mutex[5];public: DiningPhilosophers() &#123; for(int i=0;i&lt;5;i++)&#123; pthread_mutex_init(&amp;forks_mutex[i],NULL); &#125; &#125; // 一部分哲学家优先去获取其左边的叉子，再去获取其右边的叉子； // 再让剩余哲学家优先去获取其右边的叉子，再去获取其左边的叉子 void wantsToEat(int philosopher, function&lt;void()&gt; pickLeftFork, function&lt;void()&gt; pickRightFork, function&lt;void()&gt; eat, function&lt;void()&gt; putLeftFork, function&lt;void()&gt; putRightFork) &#123; int left = philosopher; int right = (philosopher+1)%5; if(philosopher%2 == 1)&#123; pthread_mutex_lock(&amp;forks_mutex[left]); pthread_mutex_lock(&amp;forks_mutex[right]); &#125; else&#123; pthread_mutex_lock(&amp;forks_mutex[right]); pthread_mutex_lock(&amp;forks_mutex[left]); &#125; pickLeftFork(); pickRightFork(); eat(); putLeftFork(); putRightFork(); pthread_mutex_unlock(&amp;forks_mutex[left]); pthread_mutex_unlock(&amp;forks_mutex[right]); &#125;&#125;; Shell1、统计词频写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。 为了简单起见，你可以假设： words.txt只包括小写字母和 ‘ ‘ 。每个单词只由小写字母组成。单词间由一个或多个空格字符分隔。示例: 假设 words.txt 内容如下： the day is sunny the thethe sunny is is你的脚本应当输出（以词频降序排列）： the 4is 3sunny 2day 1说明: 不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。你可以使用一行 Unix pipes 实现吗？ 12# Read from the file words.txt and output the word frequency list to stdout.cat words.txt | xargs -n1 | awk '&#123;data[$1] += 1&#125; END &#123;for(str in data) print data[str],str&#125;' | sort -nr | awk '&#123;print $2, $1&#125;' xargs 用作替换工具，读取输入数据重新格式化后输出# cat test.txta b c d ef g h$ cat test.txt | xargs -n3a b cd e fg h按照数值大小 反向排序$ sort -nr 1cat words.txt | xargs -n1 | awk '&#123;data[$1] += 1&#125; END &#123;for(str in data) print str,data[str]&#125;' | sort -nr -k2 将第二列按照数值大小 反向排序 $ sort -nr -k2 1cat words.txt | awk '&#123;for(i=1;i&lt;=NF;i++) data[$i] += 1&#125; END &#123;for(str in data) print str,data[str]&#125;' | sort -nr -k2 1awk '&#123;for(i=1;i&lt;=NF;i++) data[$i] += 1&#125; END &#123;for(str in data) print str,data[str]&#125;' words.txt | sort -nr -k2 NF 一条记录的字段的数目NR 已经读出的记录数，就是行号，从1开始 1cat words.txt | xargs -n1 | sort | uniq -c | sort -nr | awk '&#123;print $2,$1&#125;' 统计各行在文件中出现的次数：$ sort testfile | uniq -c当重复的行并不相邻时，uniq 命令是不起作用的，因此常与sort一起使用 1cat words.txt | tr -s ' ' '\\n' | sort | uniq -c | sort -nr | awk '&#123;print $2,$1&#125;' 空格改为换行符 $ tr -s ‘ ‘ ‘\\n’缩减连续重复的字符成指定的单个字符 2、有效电话号码给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个 bash 脚本输出所有有效的电话号码。 你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字） 你也可以假设每行前后没有多余的空格字符。 示例: 假设 file.txt 内容如下： 987-123-4567123 456 7890(123) 456-7890你的脚本应当输出下列有效的电话号码： 987-123-4567(123) 456-7890 12# Read from the file file.txt and output all valid phone numbers to stdout.grep -E \"^\\([0-9]&#123;3&#125;\\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$|^[0-9]&#123;3&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$\" file.txt ^ 为匹配输入字符串的开始位置,$ 为匹配输入字符串的结束位置 1awk \"/^\\([0-9]&#123;3&#125;\\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$|^[0-9]&#123;3&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/\" file.txt 1awk \"/^\\([0-9]&#123;3&#125;\\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/ || /^[0-9]&#123;3&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/\" file.txt 1awk \"/^(\\([0-9]&#123;3&#125;\\) |[0-9]&#123;3&#125;-)[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/\" file.txt 1grep -P \"^(\\(\\d&#123;3&#125;\\) |\\d&#123;3&#125;-)\\d&#123;3&#125;-\\d&#123;4&#125;$\" file.txt grep -E主要是用来支持扩展正则表达式 加上-P（使用Perl的正则引擎）在MAC OS下面man grep是没有-P参数的，新的主流正则引擎已经默认加上了-P参数 3、转置文件给定一个文件 file.txt，转置它的内容。 你可以假设每行列数相同，并且每个字段由 ‘ ‘ 分隔. 示例: 假设 file.txt 文件内容如下： name agealice 21ryan 30应当输出： name alice ryanage 21 30 12# Read from the file file.txt and print its transposed content to stdout.awk '&#123;for(i=1;i&lt;=NF;i++)if(arr[i])&#123;arr[i]=arr[i]\" \"$i&#125;else&#123;arr[i]=$i&#125;&#125;END&#123;for(key in arr)print arr[key]&#125;' file.txt 4、第十行给定一个文本文件 file.txt，请只打印这个文件中的第十行。 示例: 假设 file.txt 有如下内容： Line 1Line 2Line 3Line 4Line 5Line 6Line 7Line 8Line 9Line 10你的脚本应当显示第十行： Line 10说明: 如果文件少于十行，你应当输出什么？ 至少有三种不同的解法，请尝试尽可能多的方法来解题。 1awk 'NR==10' file.txt NR在awk中指行号 1tail -n +10 file.txt | head -1 tail -n +10 从第 10 行至文件末尾 1sed -n '10p' file.txt -n表示只输出匹配行，p表示Print","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"},{"name":"CodeCode","slug":"CodeCode","permalink":"http://yoursite.com/categories/CodeCode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"刷题汇总（五）leetcode 热题 HOT 100 C++ 答案总结","slug":"32","date":"2019-12-05T04:14:26.000Z","updated":"2019-12-18T04:24:59.014Z","comments":true,"path":"2019/12/05/32/","link":"","permalink":"http://yoursite.com/2019/12/05/32/","excerpt":"题目来源 leetcode 热题 HOT 100题 相关：刷题汇总（一）leetcode 精选50题 JavaScript答案总结刷题汇总（二）剑指Offer 66题 C++答案总结刷题汇总（三）leetcode 精选50题 C++答案总结刷题汇总（四）技术类编程题汇总 C++刷题汇总（六）leetcode 多线程 / Shell PDF版 code （提取码：0wxr ） 1、两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。","text":"题目来源 leetcode 热题 HOT 100题 相关：刷题汇总（一）leetcode 精选50题 JavaScript答案总结刷题汇总（二）剑指Offer 66题 C++答案总结刷题汇总（三）leetcode 精选50题 C++答案总结刷题汇总（四）技术类编程题汇总 C++刷题汇总（六）leetcode 多线程 / Shell PDF版 code （提取码：0wxr ） 1、两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 123456789101112131415161718class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(n) vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2); unordered_map&lt;int,int&gt; map; for(int i=0;i&lt;nums.size();i++)&#123; int tmp = target - nums[i]; if(map.find(tmp)!=map.end())&#123; res[0] = i; res[1] = map[tmp]; break; &#125; map[nums[i]] = i; &#125; return res; &#125;&#125;; 2、两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ // 时间复杂度：O(max(m,n))，空间复杂度：O(max(m,n))， 新列表的长度最多为max(m,n)+1class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* res = new ListNode(0); ListNode* head = res; int flag = 0; while(l1 || l2)&#123; int x = l1?l1-&gt;val:0; int y = l2?l2-&gt;val:0; head-&gt;next = new ListNode((x+y+flag)%10); flag = x+y+flag&gt;9?1:0; if(l1) l1 = l1-&gt;next; if(l2) l2 = l2-&gt;next; head = head-&gt;next; &#125; if(flag==1)&#123; head-&gt;next = new ListNode(1); &#125; return res-&gt;next; &#125;&#125;; 3、无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 1234567891011121314151617// 时间复杂度：O(n)，空间复杂度：O(m)，m 是字符集的大小class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int res = 0; unordered_map&lt;char,int&gt; map; int i = 0; for(int j=0;j&lt;s.size();j++)&#123; if(map.find(s[j])!=map.end())&#123; i = max(map[s[j]],i); &#125; map[s[j]] = j+1; res = max(j-i+1, res); &#125; return res; &#125;&#125;; 4、寻找两个有序数组的中位数给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3]nums2 = [2] 则中位数是 2.0示例 2: nums1 = [1, 2]nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 12345678910111213141516171819202122class Solution &#123;public: // 时间复杂度：O(log(min(m,n)))，空间复杂度：O(1)O(1) double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; if(nums1.size()&gt;nums2.size()) return findMedianSortedArrays(nums2,nums1); int m = nums1.size(), n = nums2.size(); int lmax1,rmin1,lmax2,rmin2,c1,c2,low=0,heigh=2*m; while(low &lt;= heigh)&#123; int c1 = (low+heigh)/2; int c2 = m+n-c1; lmax1 = c1 == 0? INT_MIN:nums1[(c1-1)/2]; rmin1 = c1 == 2*m? INT_MAX:nums1[c1/2]; lmax2 = c2 == 0? INT_MIN:nums2[(c2-1)/2]; rmin2 = c2 == 2*n? INT_MAX:nums2[c2/2]; if(lmax1&gt;rmin2) heigh = c1-1; else if(lmax2&gt;rmin1) low = c1+1; else break; &#125; return (max(lmax1,lmax2)+min(rmin1,rmin2))/2.0; &#125;&#125;; 5、最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” 1234567891011121314151617181920212223class Solution &#123;public: // 时间复杂度：O(n^2)，空间复杂度：O(1) string longestPalindrome(string s) &#123; int start=0, len=0; for(int i=0;i&lt;s.size();i++)&#123; int tmp = max(getsub(i,i,s),getsub(i,i+1,s)); if(tmp&gt;len)&#123; len = tmp; start = i-(len-1)/2; &#125; &#125; return s.substr(start,len); &#125; int getsub(int i,int j,string s)&#123; while(i&gt;=0 &amp;&amp; j&lt;s.size() &amp;&amp; s[i]==s[j])&#123; i--; j++; &#125; return j-i-1; &#125;&#125;; 6、正则表达式匹配给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 ‘.’ 匹配任意单个字符‘*’ 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。示例 1: 输入:s = “aa”p = “a”输出: false解释: “a” 无法匹配 “aa” 整个字符串。示例 2: 输入:s = “aa”p = “a*”输出: true解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。示例 3: 输入:s = “ab”p = “.*”输出: true解释: “.*” 表示可匹配零个或多个（’*’）任意字符（’.’）。示例 4: 输入:s = “aab”p = “cab”输出: true解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。示例 5: 输入:s = “mississippi”p = “misisp*.”输出: false 1234567891011121314151617181920212223242526class Solution &#123;public: bool isMatch(string s, string p) &#123; const char* str = s.c_str(); const char* pattern = p.c_str(); return match(str,pattern); &#125; bool match(const char* str, const char* pattern) &#123; if(*str == '\\0' &amp;&amp; *pattern == '\\0') return true; if(*str != '\\0' &amp;&amp; *pattern == '\\0') return false; if(*(pattern+1) != '*')&#123; if(*str==*pattern || *pattern=='.'&amp;&amp;*str!='\\0')&#123; return match(str+1,pattern+1); &#125; else return false; &#125; else&#123; if(*str==*pattern || *pattern=='.'&amp;&amp;*str!='\\0')&#123; return match(str,pattern+2)|| match(str+1,pattern+2)|| match(str+1,pattern); &#125; else return match(str,pattern+2); &#125; &#125;&#125;; 123456789101112131415161718192021class Solution &#123;public: // 时间复杂度：O(TP)，空间复杂度：O(TP) bool isMatch(string s, string p) &#123; int l1 = s.size(),l2 = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(l1+1,vector&lt;bool&gt;(l2+1)); dp[l1][l2]=true; for(int i=l1;i&gt;=0;i--)&#123; for(int j=l2-1;j&gt;=0;j--)&#123; bool tmp = i&lt;l1 &amp;&amp; ( s[i] == p[j] || p[j] == '.'); if(j+1&lt;l2 &amp;&amp; p[j+1] == '*')&#123; dp[i][j] = dp[i][j+2] || tmp &amp;&amp; dp[i+1][j]; &#125; else&#123; dp[i][j] = tmp &amp;&amp; dp[i+1][j+1]; &#125; &#125; &#125; return dp[0][0]; &#125;&#125;; 7、盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。示例: 输入: [1,8,6,2,5,4,8,3,7]输出: 49 1234567891011121314class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(1) int maxArea(vector&lt;int&gt;&amp; height) &#123; int res=0; int i=0,j=height.size()-1; while(i&lt;j)&#123; res = max(res,(j-i)*min(height[i],height[j])); if(height[i]&lt;height[j]) i++; else j--; &#125; return res; &#125;&#125;; 8、三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 1234567891011121314151617181920212223242526class Solution &#123;public: // 时间复杂度：O(n^2)，空间复杂度：O(1) vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(nums.empty()) return res; sort(nums.begin(),nums.end()); for(int i=0;i&lt;nums.size();i++)&#123; if(i&gt;=1 &amp;&amp; nums[i] == nums[i-1]) continue; if(nums[i]&gt;0) break; int l=i+1,r=nums.size()-1; while(l&lt;r)&#123; if(nums[l]+nums[r]+nums[i] &lt; 0) l++; else if(nums[l]+nums[r]+nums[i] &gt; 0) r--; else&#123; res.push_back(&#123;nums[i],nums[l],nums[r]&#125;); l++; r--; while(l&lt;r &amp;&amp; nums[l]==nums[l-1]) l++; while(l&lt;r &amp;&amp; nums[r]==nums[r+1]) r--; &#125; &#125; &#125; return res; &#125;&#125;; 9、电话号码的字母组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 1234567891011121314151617181920212223242526class Solution &#123;public: // 时间复杂度：O(3^N*4^M)，空间复杂度：O(3^N*4^M) unordered_map&lt;char,string&gt; map&#123;&#123;'2',\"abc\"&#125;,&#123;'3',\"def\"&#125;,&#123;'4',\"ghi\"&#125;,&#123;'5',\"jkl\"&#125;,&#123;'6',\"mno\"&#125;,&#123;'7',\"pqrs\"&#125;,&#123;'8',\"tuv\"&#125;,&#123;'9',\"wxyz\"&#125;&#125;; vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.empty()) return res; help(\"\",digits,res); return res; &#125; void help(string str, string digits, vector&lt;string&gt; &amp;res) &#123; if(str.size() == digits.size())&#123; res.push_back(str); return; &#125; string tmp = map[digits[str.size()]]; for(int i=0;i&lt;tmp.size();i++)&#123; str += tmp[i]; help(str,digits,res); str.pop_back(); &#125; return; &#125;&#125;; 注：可以联系剑指offer27题一起看 12345678910111213141516171819202122232425class Solution &#123;public: // 时间复杂度：O(3^N*4^M)，空间复杂度：O(3^N*4^M) vector&lt;string&gt; letterCombinations(string digits) &#123; unordered_map&lt;char,string&gt; map&#123;&#123;'2',\"abc\"&#125;,&#123;'3',\"def\"&#125;,&#123;'4',\"ghi\"&#125;,&#123;'5',\"jkl\"&#125;,&#123;'6',\"mno\"&#125;,&#123;'7',\"pqrs\"&#125;,&#123;'8',\"tuv\"&#125;,&#123;'9',\"wxyz\"&#125;&#125;; vector&lt;string&gt; res; if(digits.empty()) return res; if(digits.size() == 1)&#123; string tmp = map[digits[0]]; for(char w : tmp) &#123; string s(1,w); res.push_back(s); &#125; return res; &#125; vector&lt;string&gt; last = letterCombinations(digits.substr(0,digits.size()-1)); string tmp = map[digits[digits.size()-1]]; //abc def for(int i=0;i&lt;last.size()||i==0;i++)&#123; for(int j=0;j&lt;tmp.size();j++)&#123; res.push_back(last[i]+tmp[j]); &#125; &#125; return res; &#125;&#125;; 10、删除链表的倒数第N个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(1) ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(!head || n==0) return head; ListNode* l1 = head; ListNode* l2 = head; int k=0; while(l1)&#123; if(k&gt;n) l2 = l2-&gt;next; l1 = l1-&gt;next; k++; &#125; // 倒数第k-1个结点l2 if(k == n) return head-&gt;next; l2-&gt;next = l2-&gt;next-&gt;next; return head; &#125;&#125;; 11、有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: “()”输出: true示例 2: 输入: “()[]{}”输出: true示例 3: 输入: “(]”输出: false示例 4: 输入: “([)]”输出: false示例 5: 输入: “{[]}”输出: true 123456789101112131415161718class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(n) bool isValid(string s) &#123; stack&lt;char&gt; stack; for(int i=0;i&lt;s.size();i++)&#123; if(stack.empty() || !isok(stack.top(),s[i]))&#123; stack.push(s[i]); &#125; else stack.pop(); &#125; return stack.empty(); &#125; bool isok(char a, char b) &#123; return a=='('&amp;&amp;b==')' || a=='['&amp;&amp;b==']' || a=='&#123;'&amp;&amp;b=='&#125;'; &#125;&#125;; 12、合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 时间复杂度：O(n+m)，空间复杂度：O(1) ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* res = new ListNode(0); ListNode* head = res; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val&lt;l2-&gt;val)&#123; head-&gt;next = l1; l1 = l1-&gt;next; &#125; else&#123; head-&gt;next = l2; l2 = l2-&gt;next; &#125; head = head-&gt;next; &#125; head-&gt;next = l1?l1:l2; return res-&gt;next; &#125;&#125;; 13、括号生成给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] 123456789101112131415161718class Solution &#123;public: // 时间复杂度：O(4^n/sqrt(n))，空间复杂度：O(4^n/sqrt(n)) vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; if(n==0) return &#123;\"\"&#125;; for(int i=0;i&lt;n;i++)&#123; vector&lt;string&gt; left = generateParenthesis(i); vector&lt;string&gt; right = generateParenthesis(n-1-i); for(string l :left)&#123; for(string r :right)&#123; res.push_back(\"(\"+l+\")\"+r); &#125; &#125; &#125; return res; &#125;&#125;; 14、合并K个排序链表合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6] 输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 时间复杂度：O(Nlogk)，空间复杂度：O(1) ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode* res = NULL; for(int i=0;i&lt;lists.size();i++)&#123; res = mergeTwoLists(res,lists[i]); &#125; return res; &#125; ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* res = new ListNode(0); ListNode* head = res; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val&lt;l2-&gt;val)&#123; head-&gt;next = l1; l1 = l1-&gt;next; &#125; else&#123; head-&gt;next = l2; l2 = l2-&gt;next; &#125; head = head-&gt;next; &#125; head-&gt;next = l1?l1:l2; return res-&gt;next; &#125;&#125;; 15、下一个排列实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 123456789101112131415161718192021222324252627class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(1) void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i= nums.size()-2; while(i&gt;=0 &amp;&amp; nums[i]&gt;=nums[i+1])&#123; i--; &#125; if(i&gt;=0) &#123; int j = nums.size()-1; while(j&gt;=0 &amp;&amp; nums[j]&lt;=nums[i])&#123; j--; &#125; swap(nums[i],nums[j]); &#125; reverse(nums,i+1); &#125; void reverse(vector&lt;int&gt;&amp; nums,int n)&#123; int l=n,r=nums.size()-1; while(l&lt;r)&#123; swap(nums[l],nums[r]); l++; r--; &#125; &#125;&#125;; 16、最长有效括号给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 输入: “(()”输出: 2解释: 最长有效括号子串为 “()”示例 2: 输入: “)()())”输出: 4解释: 最长有效括号子串为 “()()” 123456789101112131415161718192021class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(1) int longestValidParentheses(string s) &#123; int l = 0, r = 0 , res = 0; for(int i=0;i&lt;s.size();i++)&#123; if(s[i] == '(') l++; if(s[i] == ')') r++; if(l==r) res = max(res,2*l); if(r&gt;l) l=r=0; &#125; l=0,r=0; for(int i=s.size()-1;i&gt;=0;i--)&#123; if(s[i] == '(') l++; if(s[i] == ')') r++; if(l==r) res = max(res,2*l); if(l&gt;r) l=r=0; &#125; return res; &#125;&#125;; 17、搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 1234567891011121314151617181920class Solution &#123;public: // 时间复杂度：O(logN)，空间复杂度：O(1) int search(vector&lt;int&gt;&amp; nums, int target) &#123; return help(nums,target,0,nums.size()-1); &#125; int help(vector&lt;int&gt;&amp; nums, int target, int l, int r) &#123; if(l&gt;r) return -1; int mid = (l+r)/2; if(nums[mid] == target) return mid; if(nums[mid]&gt;nums[r])&#123; // 3 4 7 8 1 2 旋转点在右，左顺序 if(nums[l]&lt;=target &amp;&amp; target &lt;nums[mid]) return help(nums,target,l,mid-1); else return help(nums,target,mid+1,r); &#125; else&#123; // 7 8 1 2 3 4 if(nums[mid]&lt;target &amp;&amp; target &lt;=nums[r]) return help(nums,target,mid+1,r); else return help(nums,target,l,mid-1); &#125; &#125;&#125;; 18、在排序数组中查找元素的第一个和最后一个位置给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4]示例 2: 输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 1234567891011121314151617181920212223242526272829class Solution &#123;public: // 时间复杂度：O(logN)，空间复杂度：O(1) vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res&#123;-1,-1&#125;; int l=0,r=nums.size()-1; while(l&lt;=r)&#123; int mid=(l+r)/2; if(nums[mid] == target) &#123; help(nums,mid,res); break; &#125; else if(nums[mid] &gt; target) r = mid-1; else l = mid+1; &#125; return res; &#125; void help(vector&lt;int&gt; nums, int n,vector&lt;int&gt; &amp;res) &#123; int l=n,r=n; while(l&gt;=0&amp;&amp;nums[l]==nums[n])&#123; l--; &#125; while(r&lt;nums.size()&amp;&amp;nums[r]==nums[n])&#123; r++; &#125; res[0]=l+1; res[1]=r-1; &#125;&#125;; 19、组合总和给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。 说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。示例 1: 输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(),candidates.end()); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; dfs(candidates,target,0,path,res); return res; &#125; void dfs(vector&lt;int&gt;&amp; candidates, int target, int start, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;res) &#123; if(target == 0) &#123; res.push_back(path); return; &#125; for(int i=start;i&lt;candidates.size()&amp;&amp;target&gt;=candidates[i];i++)&#123; path.push_back(candidates[i]); dfs(candidates,target-candidates[i],i,path,res); path.pop_back(); &#125; &#125;&#125;; 20、接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 12345678910111213141516171819202122class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(1) int trap(vector&lt;int&gt;&amp; height) &#123; int res = 0; int l = 0, r = height.size()-1; int max_left = 0, max_right = 0; while(l&lt;r)&#123; if(height[l]&lt;height[r])&#123; if(height[l]&gt;=max_left) max_left = height[l]; else res += max_left-height[l]; l++; &#125; else&#123; if(height[r]&gt;=max_right) max_right = height[r]; else res += max_right-height[r]; r--; &#125; &#125; return res; &#125;&#125;; 21、全排列给定一个没有重复数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 1234567891011121314151617class Solution &#123;public: // 时间复杂度：O(n!)，空间复杂度：O(1) vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; help(nums,res,0); return res; &#125; void help(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt; &amp;res, int k)&#123; if(k==nums.size()-1) res.push_back(nums); for(int i=k;i&lt;nums.size();i++)&#123; swap(nums[i],nums[k]); help(nums,res,k+1); swap(nums[i],nums[k]); &#125; &#125;&#125;; 22、旋转图像给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。 说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 给定 matrix =[ [1,2,3], [4,5,6], [7,8,9]], 原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2: 给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 1234567891011121314151617class Solution &#123;public: // 时间复杂度：O(n^2)，空间复杂度：O(1) void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n= matrix.size(); for(int i=0;i&lt;n;i++)&#123; for(int j=i;j&lt;n;j++)&#123; swap(matrix[i][j],matrix[j][i]); &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n/2;j++)&#123; swap(matrix[i][j],matrix[i][n-1-j]); &#125; &#125; &#125;&#125;; 23、字母异位词分组给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],输出:[ [“ate”,”eat”,”tea”], [“nat”,”tan”], [“bat”]] 说明： 所有输入均为小写字母。不考虑答案输出的顺序。 1234567891011121314151617181920212223242526class Solution &#123;public: // 时间复杂度：O(NK)，空间复杂度：O(NK) vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string,int&gt; map; vector&lt;vector&lt;string&gt;&gt; res; int k = 0; for(int i=0;i&lt;strs.size();i++)&#123; string str = strs[i]; string node(26,'0'); for(int j=0;j&lt;str.size();j++)&#123; int t = node[str[j]-'a']-'0'+1; node[str[j]-'a']= '0' + t; &#125; if(map.find(node)!=map.end())&#123; res[map[node]].push_back(str); &#125; else&#123; map[node] = k; res.push_back(vector&lt;string&gt;&#123;str&#125;); k++; &#125; &#125; return res; &#125;&#125;; 24、最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 1234567891011121314class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(1) int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int res = INT_MIN; int add = 0; for(int i=0;i&lt;nums.size();i++)&#123; add+=nums[i]; res=max(res,add); if(add&lt;0) add=0; &#125; return res; &#125;&#125;; 25、跳跃游戏给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。示例 2: 输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 1234567891011class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(1) bool canJump(vector&lt;int&gt;&amp; nums) &#123; int last = nums.size()-1; for(int i=nums.size()-2;i&gt;=0;i--)&#123; if(i+nums[i]&gt;=last) last = i; &#125; return last == 0; &#125;&#125;; 26、合并区间给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].示例 2: 输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 123456789101112131415161718class Solution &#123;public: // 时间复杂度：O(nlogn)，空间复杂度：O(1) vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(intervals.begin(),intervals.end(),Sort); for(int i=0;i&lt;intervals.size();i++)&#123; if(res.empty() || intervals[i][0]&gt;res[res.size()-1][1]) res.push_back(intervals[i]); else res[res.size()-1][1] = max(res[res.size()-1][1],intervals[i][1]); &#125; return res; &#125; static bool Sort(vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b) &#123; return a[0]&lt;b[0]; &#125;&#125;; 27、不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右示例 2: 输入: m = 7, n = 3输出: 28 123456789101112131415class Solution &#123;public: // 时间复杂度：O(nm)，空间复杂度：O(nm) int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1)); dp[0][0] = 0; for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(i==1||j==1) dp[i][j] = 1; else dp[i][j] = dp[i-1][j]+dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; 28、最小路径和给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入:[ [1,3,1], [1,5,1], [4,2,1]] 输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 1234567891011121314151617181920class Solution &#123;public: // 时间复杂度：O(nm)，空间复杂度：O(nm) int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int res = INT_MAX; int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0)); for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(i==0&amp;&amp;j==0) dp[i][j] = grid[i][j]; else&#123; if(i==0) dp[i][j] = dp[i][j-1] + grid[i][j]; else if(j==0) dp[i][j] = dp[i-1][j] + grid[i][j]; else dp[i][j] = min(dp[i][j-1],dp[i-1][j]) + grid[i][j]; &#125; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 29、爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶示例 2： 输入： 3输出： 3解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 123456789101112131415class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(1) int climbStairs(int n) &#123; // 1 2 3 5 int i=0,j=1,k=0; while(k&lt;n)&#123; int t = j; j = i+j; i = t; k++; &#125; return j; &#125;&#125;; 30、编辑距离给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符删除一个字符替换一个字符示例 1: 输入: word1 = “horse”, word2 = “ros”输出: 3解释:horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)rorse -&gt; rose (删除 ‘r’)rose -&gt; ros (删除 ‘e’)示例 2: 输入: word1 = “intention”, word2 = “execution”输出: 5解释:intention -&gt; inention (删除 ‘t’)inention -&gt; enention (将 ‘i’ 替换为 ‘e’)enention -&gt; exention (将 ‘n’ 替换为 ‘x’)exention -&gt; exection (将 ‘n’ 替换为 ‘c’)exection -&gt; execution (插入 ‘u’) 12345678910111213141516class Solution &#123;public: // 时间复杂度：O(mn)，空间复杂度：O(mn) int minDistance(string word1, string word2) &#123; int m= word1.size(), n=word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1)); for(int i=0;i&lt;=m;i++)&#123; for(int j=0;j&lt;=n;j++)&#123; if(i==0||j==0) dp[i][j]= max(i,j); else if(word1[i-1]==word2[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j]= min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1])) + 1; &#125; &#125; return dp[m][n]; &#125;&#125;; 31、颜色分类给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2]进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？ 12345678910111213141516171819class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(1) void sortColors(vector&lt;int&gt;&amp; nums) &#123; int p0 = 0, p2 = nums.size()-1, cur = 0; while(cur&lt;=p2)&#123; if(nums[cur] == 0)&#123; swap(nums[p0],nums[cur]); p0++; cur++; &#125; else if(nums[cur] == 2)&#123; swap(nums[p2],nums[cur]); p2--; &#125; else cur++; &#125; &#125;&#125;; 32、最小覆盖子串给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。 示例： 输入: S = “ADOBECODEBANC”, T = “ABC”输出: “BANC”说明： 如果 S 中不存这样的子串，则返回空字符串 “”。如果 S 中存在这样的子串，我们保证它是唯一的答案。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: // 时间复杂度：O(S+T)，空间复杂度：O(S+T) string minWindow(string s, string t) &#123; int start = 0, len = INT_MAX; int l = 0, r = 0; unordered_map&lt;char,int&gt; map; unordered_map&lt;char,int&gt; match; for(char c : t) map[c]++; int count = 0; while(r&lt;s.size())&#123; char t = s[r]; if(map.count(t))&#123; match[t]++; if(map[t] == match[t])&#123; count++; &#125; &#125; r++; while(map.size()==count)&#123; if(r-l&lt;len)&#123; start = l; len = r-l; &#125; char t2 = s[l]; if(map.count(t2))&#123; match[t2]--; if(match[t2]&lt;map[t2])&#123; count--; &#125; &#125; l++; &#125; &#125; return len == INT_MAX? \"\":s.substr(start,len); &#125;&#125;; 33、子集给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 12345678910111213141516class Solution &#123;public: // 利用二进制，时间复杂度：O(2^n)，空间复杂度：O(2^n) vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int len = 1&lt;&lt;nums.size(); for(int i=0;i&lt;len;i++)&#123; vector&lt;int&gt; tmp; for(int j=0;j&lt;nums.size();j++)&#123; if(i&amp;(1&lt;&lt;j)) tmp.push_back(nums[j]); &#125; res.push_back(tmp); &#125; return res; &#125;&#125;; 12345678910111213141516class Solution &#123;public: // 时间复杂度：O(2^n)，空间复杂度：O(2^n) vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res&#123;&#123;&#125;&#125;; for(int i=0;i&lt;nums.size();i++)&#123; int len = res.size(); for(int j=0;j&lt;len;j++)&#123; vector&lt;int&gt; tmp(res[j]); tmp.push_back(nums[i]); res.push_back(tmp); &#125; &#125; return res; &#125;&#125;; 34、单词搜索给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: board =[ [‘A’,’B’,’C’,’E’], [‘S’,’F’,’C’,’S’], [‘A’,’D’,’E’,’E’]] 给定 word = “ABCCED”, 返回 true.给定 word = “SEE”, 返回 true.给定 word = “ABCB”, 返回 false. 12345678910111213141516171819202122232425class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; for(int i=0;i&lt;board.size();i++)&#123; for(int j=0;j&lt;board[0].size();j++)&#123; if(help(board,i,j,word,0)) return true; &#125; &#125; return false; &#125; bool help(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j, string word, int k) &#123; if(i&lt;0||i&gt;=board.size()||j&lt;0||j&gt;=board[0].size()||board[i][j]=='*'||board[i][j]!=word[k]) return false; if(k==word.size()-1) return true; char tmp = board[i][j]; board[i][j] = '*'; if(help(board,i-1,j,word,k+1) || help(board,i+1,j,word,k+1) || help(board,i,j-1,word,k+1) || help(board,i,j+1,word,k+1))&#123; return true; &#125; board[i][j] = tmp; return false; &#125;&#125;; 35、柱状图中最大的矩形给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例: 输入: [2,1,5,6,2,3]输出: 10 123456789101112131415class Solution &#123;public: // 时间复杂度：O(nlogn)，空间复杂度：O(n) 有时候通过有时候超时 int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; return help(heights,0,heights.size()-1); &#125; int help(vector&lt;int&gt; &amp;heights, int l, int r)&#123; if(l&gt;r) return 0; int low = l; for(int i=l;i&lt;=r;i++)&#123; if(heights[i]&lt;heights[low]) low = i; &#125; return max(heights[low]*(r-l+1),max(help(heights,l,low-1),help(heights,low+1,r))); &#125;&#125;; 12345678910111213141516171819class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(n) int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; stack&lt;int&gt; st; heights.push_back(0); int size = heights.size(); int res = 0; for (int i = 0; i &lt; size; i++) &#123; while (!st.empty() &amp;&amp; heights[st.top()] &gt;= heights[i]) &#123; int val = st.top(); st.pop(); res = max(res, heights[val] * (st.empty() ? i : (i - st.top() - 1))); &#125; st.push(i); &#125; return res; &#125; &#125;; 36、最大矩形给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例: 输入:[ [“1”,”0”,”1”,”0”,”0”], [“1”,”0”,”1”,”1”,”1”], [“1”,”1”,”1”,”1”,”1”], [“1”,”0”,”0”,”1”,”0”]] 输出: 6 12345678910111213141516171819202122232425262728293031class Solution &#123;public: // 时间复杂度：O(n*m)，空间复杂度：O(m) int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty()) return 0; int res = 0; vector&lt;int&gt; vec(matrix[0].size(),0); for(int i=0;i&lt;matrix.size();i++)&#123; for(int j=0;j&lt;matrix[0].size();j++)&#123; vec[j] = matrix[i][j]=='1'?vec[j]+1:0; &#125; res = max(res,help(vec)); &#125; return res; &#125; int help(vector&lt;int&gt; &amp;vec)&#123; stack&lt;int&gt; stack; int res = 0; vec.push_back(0); for(int i=0;i&lt;vec.size();i++)&#123; while(!stack.empty()&amp;&amp;vec[stack.top()]&gt;=vec[i])&#123; int tmp = stack.top(); stack.pop(); res = max(res,vec[tmp]*(stack.empty()?i:(i-stack.top()-1))); &#125; stack.push(i); &#125; vec.pop_back(); return res; &#125;&#125;; 37、二叉树的中序遍历给定一个二叉树，返回它的中序 遍历。 示例: 输入: [1,null,2,3] 123451 \\ 2 /3 输出: [1,3,2]进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(logn) 递归 vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; help(res,root); return res; &#125; void help(vector&lt;int&gt; &amp;res, TreeNode* root)&#123; if(!root) return; help(res,root-&gt;left); res.push_back(root-&gt;val); help(res,root-&gt;right); &#125;&#125;; 1234567891011121314151617181920class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(n) 栈 vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; while(cur || !stack.empty())&#123; while(cur)&#123; stack.push(cur); cur = cur-&gt;left; &#125; cur = stack.top(); stack.pop(); res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; return res; &#125;&#125;; 1234567891011121314151617181920212223242526class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(n) 线索二叉树 vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; TreeNode* cur = root; TreeNode* next; while(cur)&#123; if(!cur-&gt;left)&#123; res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; else&#123; next = cur-&gt;left; while(next-&gt;right)&#123; next = next-&gt;right; &#125; next-&gt;right = cur; TreeNode* tmp = cur; cur = cur-&gt;left; tmp-&gt;left = NULL; &#125; &#125; return res; &#125;&#125;; 38、不同的二叉搜索树给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 123451 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\2 1 2 3 123456789101112131415class Solution &#123;public: // 时间复杂度：O(n^2)，空间复杂度：O(n) int numTrees(int n) &#123; vector&lt;int&gt; res(n+1); res[0] = 1; res[1] = 1; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; res[i] += res[j-1]*res[i-j]; &#125; &#125; return res[n]; &#125;&#125;; 39、验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。示例 1: 输入: 123 2 / \\1 3 输出: true示例 2: 输入: 12345 5 / \\1 4 / \\ 3 6 输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(n) 中序遍历递增 bool isValidBST(TreeNode* root) &#123; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; //int tmp = INT_MIN; // 测试用例用[-2147483648]卡边界值过分了。。。 long tmp = LONG_MIN; while(cur || !stack.empty())&#123; while(cur)&#123; stack.push(cur); cur=cur-&gt;left; &#125; cur = stack.top(); stack.pop(); if(cur-&gt;val&lt;=tmp)&#123; return false; &#125; tmp = cur-&gt;val; cur = cur-&gt;right; &#125; return true; &#125;&#125;; 40、对称二叉树给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \\2 2 \\ \\ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(n) 递归 bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return help(root-&gt;left,root-&gt;right); &#125; bool help(TreeNode* l,TreeNode* r) &#123; if(!l &amp;&amp; !r) return true; if(!l || !r) return false; return l-&gt;val==r-&gt;val &amp;&amp; help(l-&gt;right,r-&gt;left) &amp;&amp; help(l-&gt;left,r-&gt;right); &#125;&#125;; 1234567891011121314151617181920212223class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(n) 迭代 bool isSymmetric(TreeNode* root) &#123; queue&lt;TreeNode*&gt; queue; queue.push(root); queue.push(root); while(!queue.empty())&#123; TreeNode* t1 = queue.front(); queue.pop(); TreeNode* t2 = queue.front(); queue.pop(); if(!t1 &amp;&amp; !t2) continue; if(!t1 || !t2) return false; if(t1-&gt;val != t2-&gt;val) return false; queue.push(t1-&gt;left); queue.push(t2-&gt;right); queue.push(t2-&gt;left); queue.push(t1-&gt;right); &#125; return true; &#125;&#125;; 41、二叉树的层次遍历给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(n) vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; queue; if(root) queue.push(root); while(!queue.empty())&#123; int count = queue.size(); vector&lt;int&gt; tmp; while(count!=0)&#123; tmp.push_back(queue.front()-&gt;val); count--; if(queue.front()-&gt;left) queue.push(queue.front()-&gt;left); if(queue.front()-&gt;right) queue.push(queue.front()-&gt;right); queue.pop(); &#125; res.push_back(tmp); &#125; return res; &#125;&#125;; 42、二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \\9 20 / \\ 15 7 返回它的最大深度 3 。 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(logn) int maxDepth(TreeNode* root) &#123; if(!root) return 0; return max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+1; &#125;&#125;; 43、从前序与中序遍历序列构造二叉树根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 12345 3 / \\9 20 / \\ 15 7· 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(n) TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return help(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1); &#125; TreeNode* help(vector&lt;int&gt;&amp; pre,int pl,int pr,vector&lt;int&gt;&amp; vin,int vl,int vr) &#123; if(pl&gt;pr || vl&gt;vr) return NULL; TreeNode* head = new TreeNode(pre[pl]); int i; for(i=vl;i&lt;=vr;i++)&#123; if(vin[i]==pre[pl]) break; &#125; int num = i-vl; head-&gt;left=help(pre,pl+1,pl+num,vin,vl,vl+num-1); head-&gt;right=help(pre,pl+num+1,pr,vin,vl+num+1,vr); return head; &#125;&#125;; 44、二叉树展开为链表给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 12345 1 / \\ 2 5 / \\ \\3 4 6 将其展开为： 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 先序遍历 线索二叉树 // 时间复杂度：O(n)，空间复杂度：O(1) void flatten(TreeNode* root) &#123; TreeNode* cur = root; TreeNode* next; while(cur)&#123; if(!cur-&gt;left)&#123; cur = cur-&gt;right; &#125; else&#123; next = cur-&gt;left; while(next-&gt;right)&#123; next = next-&gt;right; &#125; next-&gt;right = cur-&gt;right; cur-&gt;right = cur-&gt;left; cur-&gt;left = NULL; cur = cur-&gt;right; &#125; &#125; &#125; /* // 中序遍历 线索二叉树 vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; TreeNode* cur = root; TreeNode* next; while(cur)&#123; if(!cur-&gt;left)&#123; res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; else&#123; next = cur-&gt;left; while(next-&gt;right)&#123; next = next-&gt;right; &#125; next-&gt;right = cur; TreeNode* tmp = cur; cur = cur-&gt;left; tmp-&gt;left = NULL; &#125; &#125; return res; &#125; */&#125;; 45、买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。示例 2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 12345678910111213class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(1) int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; int minp = INT_MAX; for(int i=0;i&lt;prices.size();i++)&#123; minp=min(minp,prices[i]); res = max(res,prices[i]-minp); &#125; return res; &#125;&#125;; 46、二叉树中的最大路径和给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1: 输入: [1,2,3] 1 / \\ 2 3输出: 6示例 2: 输入: [-10,9,20,null,null,15,7] -10 / 9 20 / 15 7 输出: 42 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(logn) int maxPathSum(TreeNode* root) &#123; int res=INT_MIN; help(root,res); return res; &#125; int help(TreeNode* root,int &amp;res)&#123; // 从root向下走的最长距离 if(!root) return 0; int l = max(0, help(root-&gt;left,res)); int r = max(0, help(root-&gt;right,res)); res = max(res,root-&gt;val+l+r); return root-&gt;val+max(l,r); &#125;&#125;; 47、最长连续序列给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 示例: 输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 123456789101112131415161718192021class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(n) int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; int res = 0; set&lt;int&gt; s(nums.begin(),nums.end()); set&lt;int&gt;::iterator it; for(it = s.begin();it!=s.end();it++)&#123; int beg = *it; if(s.find(beg-1)==s.end())&#123; int len = 1; while(s.find(beg+1)!=s.end())&#123; len++; beg++; &#125; res=max(res,len); &#125; &#125; return res; &#125;&#125;; 48、只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1示例 2: 输入: [4,1,2,1,2]输出: 4 123456789class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(1) int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res; for(int num:nums) res^=num; return res; &#125;&#125;; 49、单词拆分给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。示例 1： 输入: s = “leetcode”, wordDict = [“leet”, “code”]输出: true解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。示例 2： 输入: s = “applepenapple”, wordDict = [“apple”, “pen”]输出: true解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。 注意你可以重复使用字典中的单词。示例 3： 输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]输出: false 12345678910111213141516171819class Solution &#123;public: // 时间复杂度：O(n^2)，空间复杂度：O(n) // dp[i]表示字符串s的前i个字符能否拆分成wordDict bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; vector&lt;bool&gt; flag(s.size()+1,false); unordered_set&lt;string&gt; set(wordDict.begin(),wordDict.end()); flag[0] = true; for(int i=1;i&lt;=s.size();i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(flag[j] &amp;&amp; set.find(s.substr(j,i-j))!=set.end())&#123; flag[i]=true; break; &#125; &#125; &#125; return flag[s.size()]; &#125;&#125;; 50、环形链表给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 时间复杂度：O(n)，空间复杂度：O(1) bool hasCycle(ListNode *head) &#123; if(!head) return false; ListNode * fast = head; ListNode * slow = head; while(fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) return true; &#125; return false; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"},{"name":"CodeCode","slug":"CodeCode","permalink":"http://yoursite.com/categories/CodeCode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"技术类编程题汇总 C++ 刷题记录","slug":"31","date":"2019-12-02T03:57:52.000Z","updated":"2019-12-18T04:25:10.503Z","comments":true,"path":"2019/12/02/31/","link":"","permalink":"http://yoursite.com/2019/12/02/31/","excerpt":"腾讯2018春招技术类编程题汇总1、翻转数列小Q定义了一种数列称为翻转数列:给定整数n和m, 满足n能被2m整除。对于一串连续递增整数数列1, 2, 3, 4…, 每隔m个符号翻转一次, 最初符号为’-‘;。例如n = 8, m = 2, 数列就是: -1, -2, +3, +4, -5, -6, +7, +8.而n = 4, m = 1, 数列就是: -1, +2, -3, + 4.小Q现在希望你能帮他算算前n项和为多少。","text":"腾讯2018春招技术类编程题汇总1、翻转数列小Q定义了一种数列称为翻转数列:给定整数n和m, 满足n能被2m整除。对于一串连续递增整数数列1, 2, 3, 4…, 每隔m个符号翻转一次, 最初符号为’-‘;。例如n = 8, m = 2, 数列就是: -1, -2, +3, +4, -5, -6, +7, +8.而n = 4, m = 1, 数列就是: -1, +2, -3, + 4.小Q现在希望你能帮他算算前n项和为多少。 输入描述:输入包括两个整数n和m(2 &lt;= n &lt;= 109, 1 &lt;= m), 并且满足n能被2m整除。 输出描述:输出一个整数, 表示前n项和。 输入例子1:8 2 输出例子1:8 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;// 暴力法 case通过率为80.00%，超时long long fun(int n, int m) &#123; long long res = 0; int k = 0, flag = -1; for (int i = 0; i &lt; n/m; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; k = flag * (abs(k) + 1); res += k; &#125; flag *= -1; &#125; return res;&#125;// 找规律：第一个加号值加上第一个减号值,差值刚好是m,共有n/2对// -1, -2, +3, +4, -5, -6, +7, +8long long fun2(int n, int m) &#123; return n/2*m;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; fun2(n,m) &lt;&lt; endl; return 0;&#125; 2、纸牌游戏牛牛和羊羊正在玩一个纸牌游戏。这个游戏一共有n张纸牌, 第i张纸牌上写着数字ai。牛牛和羊羊轮流抽牌, 牛牛先抽, 每次抽牌他们可以从纸牌堆中任意选择一张抽出, 直到纸牌被抽完。他们的得分等于他们抽到的纸牌数字总和。现在假设牛牛和羊羊都采用最优策略, 请你计算出游戏结束后牛牛得分减去羊羊得分等于多少。 输入描述:输入包括两行。第一行包括一个正整数n(1 &lt;= n &lt;= 105),表示纸牌的数量。第二行包括n个正整数ai(1 &lt;= ai &lt;= 109),表示每张纸牌上的数字。 输出描述:输出一个整数, 表示游戏结束后牛牛得分减去羊羊得分等于多少。 输入例子1:3 2 7 4 输出例子1:5 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; priority_queue&lt;int, vector&lt;int&gt;,less&lt;int&gt;&gt; card; int t; for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; t; card.push(t); &#125; int res = 0; int flag = 1; while (!card.empty())&#123; int c = card.top(); res += flag*c; flag *= -1; card.pop(); &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 3、贪吃的小Q小Q的父母要出差N天，走之前给小Q留下了M块巧克力。小Q决定每天吃的巧克力数量不少于前一天吃的一半，但是他又不想在父母回来之前的某一天没有巧克力吃，请问他第一天最多能吃多少块巧克力 输入描述:每个输入包含一个测试用例。每个测试用例的第一行包含两个正整数，表示父母出差的天数N(N&lt;=50000)和巧克力的数量M(N&lt;=M&lt;=100000)。 输出描述:输出一个数表示小Q第一天最多能吃多少块巧克力。 输入例子1:3 7 输出例子1:4 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int fun(int n, int m)&#123; int start = ceil(m / 2.0); for (int i = start; i &gt;= 1; i--)&#123; int t = 0; int ti = i; for (int j = 0; j &lt; n; j++)&#123; t += ti; if (ti != 1) ti = ceil(ti / 2.0); &#125; if (t &lt;= m) return i; &#125; return 0;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; if (n == 1) cout &lt;&lt; m &lt;&lt; endl; else cout &lt;&lt; fun(n, m) &lt;&lt; endl; return 0;&#125; 4、小Q的歌单小Q有X首长度为A的不同的歌和Y首长度为B的不同的歌，现在小Q想用这些歌组成一个总长度正好为K的歌单，每首歌最多只能在歌单中出现一次，在不考虑歌单内歌曲的先后顺序的情况下，请问有多少种组成歌单的方法。 输入描述:每个输入包含一个测试用例。每个测试用例的第一行包含一个整数，表示歌单的总长度K(1&lt;=K&lt;=1000)。接下来的一行包含四个正整数，分别表示歌的第一种长度A(A&lt;=10)和数量X(X&lt;=100)以及歌的第二种长度B(B&lt;=10)和数量Y(Y&lt;=100)。保证A不等于B。 输出描述:输出一个整数,表示组成歌单的方法取模。因为答案可能会很大,输出对1000000007取模的结果。 输入例子1:5 2 3 3 3 输出例子1:9 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// n选k组合数C(n,k) = C(n-1,k) + C(n-1,k-1）void CreatSelect(vector&lt;vector&lt;long long&gt;&gt; &amp;arr)&#123; arr[0][0] = 1; for (int i = 1; i &lt;= 100; i++)&#123; arr[i][0] = 1; for (int j = 1; j &lt;= 100; j++)&#123; arr[i][j] = (arr[i - 1][j] + arr[i - 1][j - 1] )% 1000000007; &#125; &#125;&#125;long long fun(int k, int a, int x, int b, int y, vector&lt;vector&lt;long long&gt;&gt; arr)&#123; long long res = 0; for (int i = 0; i &lt;= k / a &amp;&amp; i &lt;= x; i++)&#123; if ((k - a*i) % b == 0 &amp;&amp; (k - a*i) / b &lt;= y)&#123; // x里选i个a，y里选(k - a*i) / b个b res = (res + arr[x][i] * arr[y][(k - a*i) / b] % 1000000007) % 1000000007; &#125; &#125; return res;&#125;int main()&#123; int k; cin &gt;&gt; k; int a, b, x, y; cin &gt;&gt; a &gt;&gt; x &gt;&gt; b &gt;&gt; y; vector&lt;vector&lt;long long&gt;&gt; arr(101, vector&lt;long long&gt;(101)); CreatSelect(arr); cout &lt;&lt; fun(k, a, x, b, y, arr) &lt;&lt; endl; return 0;&#125; 5、安排机器小Q的公司最近接到m个任务, 第i个任务需要xi的时间去完成, 难度等级为yi。小Q拥有n台机器, 每台机器最长工作时间zi, 机器等级wi。对于一个任务,它只能交由一台机器来完成, 如果安排给它的机器的最长工作时间小于任务需要的时间, 则不能完成,如果完成这个任务将获得200 * xi + 3 * yi收益。 对于一台机器,它一天只能完成一个任务, 如果它的机器等级小于安排给它的任务难度等级, 则不能完成。 小Q想在今天尽可能的去完成任务, 即完成的任务数量最大。如果有多种安排方案,小Q还想找到收益最大的那个方案。小Q需要你来帮助他计算一下。 输入描述:输入包括N + M + 1行,输入的第一行为两个正整数n和m(1 &lt;= n, m &lt;= 100000), 表示机器的数量和任务的数量。接下来n行,每行两个整数zi和wi(0 &lt; zi &lt; 1000, 0 &lt;= wi &lt;= 100), 表示每台机器的最大工作时间和机器等级。接下来的m行,每行两个整数xi和yi(0 &lt; xi &lt; 1000, 0 &lt;= yi&lt;= 100), 表示每个任务需要的完成时间和任务的难度等级。 输出描述:输出两个整数, 分别表示最大能完成的任务数量和获取的收益。 输入例子1:1 2100 3100 2100 1 输出例子1:1 20006 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct Node &#123; int time, grade;&#125;;bool Cmp(const Node &amp;a, const Node &amp;b) &#123; if (a.time == b.time) return a.grade &gt; b.grade; return a.time &gt; b.time;&#125;// case通过率为90.00%，超时int main() &#123; int n, m; //机器的数量和任务的数量 1 &lt;= n, m &lt;= 100000 cin &gt;&gt; n &gt;&gt; m; vector&lt;Node&gt; machine(n); vector&lt;Node&gt; task(m); for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; machine[i].time &gt;&gt; machine[i].grade; &#125; for (int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; task[i].time &gt;&gt; task[i].grade; &#125; sort(machine.begin(), machine.end(), Cmp); sort(task.begin(), task.end(), Cmp); int res = 0, value = 0; bool* flag = new bool[n]; memset(flag, true, n); for (int i = 0; i &lt; m; i++)&#123; int min_grade = 101; int min_j; for (int j = 0; j &lt; n; j++)&#123; if (flag[j])&#123; if (task[i].time &lt;= machine[j].time)&#123; if (task[i].grade &lt;= machine[j].grade &amp;&amp; machine[j].grade &lt; min_grade)&#123; min_grade = machine[j].grade; min_j = j; &#125; &#125; else&#123; break; &#125; &#125; &#125; if (min_grade != 101)&#123; res++; value += 200 * task[i].time + 3 * task[i].grade; flag[min_j] = false; &#125; &#125; delete[] flag; cout &lt;&lt; res &lt;&lt; \" \" &lt;&lt; value &lt;&lt; endl; return 0;&#125; 6、画家小Q画家小Q又开始他的艺术创作。小Q拿出了一块有NxM像素格的画板, 画板初始状态是空白的,用’X’表示。小Q有他独特的绘画技巧,每次小Q会选择一条斜线, 如果斜线的方向形如’/‘,即斜率为1,小Q会选择这条斜线中的一段格子,都涂画为蓝色,用’B’表示;如果对角线的方向形如’&#39;,即斜率为-1,小Q会选择这条斜线中的一段格子,都涂画为黄色,用’Y’表示。如果一个格子既被蓝色涂画过又被黄色涂画过,那么这个格子就会变成绿色,用’G’表示。小Q已经有想画出的作品的样子, 请你帮他计算一下他最少需要多少次操作完成这幅画。 输入描述:每个输入包含一个测试用例。每个测试用例的第一行包含两个正整数N和M(1 &lt;= N, M &lt;= 50), 表示画板的长宽。接下来的N行包含N个长度为M的字符串, 其中包含字符’B’,’Y’,’G’,’X’,分别表示蓝色,黄色,绿色,空白。整个表示小Q要完成的作品。 输出描述:输出一个正整数, 表示小Q最少需要多少次操作完成绘画。 输入例子1:4 4YXXBXYGXXBYYBXXY 输出例子1:3 例子说明1:XXXXXXXXXXXXXXXX-&gt;YXXXXYXXXXYXXXXY-&gt;YXXBXYBXXBYXBXXY-&gt;YXXBXYGXXBYYBXXY 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int n, m; //N和M(1 &lt;= N, M &lt;= 50), 表示画板的长宽vector&lt;vector&lt;char&gt;&gt; arr;void fun_b(int i, int j)&#123; if (i &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; m &amp;&amp; (arr[i][j] == 'B' || arr[i][j] == 'G'))&#123; if (arr[i][j] == 'B') arr[i][j] = 'X'; else arr[i][j] = 'Y'; fun_b(i - 1,j + 1); fun_b(i + 1, j - 1); &#125; return;&#125;void fun_y(int i, int j)&#123; if (i &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; m &amp;&amp; (arr[i][j] == 'Y' || arr[i][j] == 'G'))&#123; if (arr[i][j] == 'Y') arr[i][j] = 'X'; else arr[i][j] = 'B'; fun_y(i + 1, j + 1); fun_y(i - 1, j - 1); &#125; return;&#125;/*YXXBXYGXXBYYBXXY*/int fun() &#123; int res = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (arr[i][j] == 'B')&#123; fun_b(i, j); res++; &#125; if (arr[i][j] == 'Y')&#123; fun_y(i, j); res++; &#125; if (arr[i][j] == 'G')&#123; fun_b(i, j); fun_y(i, j); res += 2; &#125; &#125; &#125; return res;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; arr = vector&lt;vector&lt;char&gt;&gt; (n, vector&lt;char&gt;(m)); string str; for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; str; for (int j = 0; j &lt; m; j++)&#123; arr[i][j] = str[j]; &#125; &#125; cout &lt;&lt; fun() &lt;&lt; endl; return 0;&#125; 腾讯2017秋招笔试编程题1、编码假定一种编码的编码范围是a ~ y的25个字母，从1位到4位的编码，如果我们把该编码按字典序排序，形成一个数组如下： a, aa, aaa, aaaa, aaab, aaac, … …, b, ba, baa, baaa, baab, baac … …, yyyw, yyyx, yyyy 其中a的Index为0，aa的Index为1，aaa的Index为2，以此类推。 编写一个函数，输入是任意一个编码，输出这个编码对应的Index. 输入描述:输入一个待编码的字符串,字符串长度小于等于100. 输出描述:输出这个编码的index 输入例子1:baca 输出例子1:16331 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;vector&lt;int&gt; loop = &#123; 0, 1, 26, 651, 16276 &#125;;int fun(string str) &#123; int res = 0, len = str.size(); for (int i = 0; i &lt; len; i++)&#123; res += (str[i] - 'a')*loop[4 -i]+1; &#125; return res-1;&#125;int main() &#123; string str; while (cin &gt;&gt; str)&#123; cout &lt;&lt; fun(str) &lt;&lt; endl; &#125; return 0;&#125; 2、游戏任务标记游戏里面有很多各式各样的任务，其中有一种任务玩家只能做一次，这类任务一共有1024个，任务ID范围[1,1024]。请用32个unsigned int类型来记录着1024个任务是否已经完成。初始状态都是未完成。 输入两个参数，都是任务ID，需要设置第一个ID的任务为已经完成；并检查第二个ID的任务是否已经完成。 输出一个参数，如果第二个ID的任务已经完成输出1，如果未完成输出0。如果第一或第二个ID不在[1,1024]范围，则输出-1。 输入描述:输入包括一行,两个整数表示人物ID. 输出描述:输出是否完成 输入例子1:1024 1024 输出例子1:1 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;unsigned int flag[32];// unsigned int为32位，32个unsigned int为32*32=1024int fun(int n, int m) &#123; // Index(N) = N / 32 = N &gt;&gt; 5; // Position(N) = N % 32 = N &amp; 31; （对于2的幂的数才能） int index, position; index = (n - 1) &gt;&gt; 5; position = (n-1) &amp; 31; flag[index] |= 1 &lt;&lt; position; if (m &gt;= 1 &amp;&amp; m &lt;= 1024)&#123; index = (m - 1) &gt;&gt; 5; position = (m - 1) &amp; 31; return (flag[index]&amp;(1&lt;&lt;position))!=0; &#125; return -1;&#125;int main() &#123; int n,m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; fun(n, m) &lt;&lt; endl; return 0;&#125; 3、素数对给定一个正整数，编写程序计算有多少对质数的和等于输入的这个正整数，并输出结果。输入值小于1000。如，输入为10, 程序应该输出结果为2。（共有两对质数的和为10,分别为(5,5),(3,7)） 输入描述:输入包括一个整数n,(3 ≤ n &lt; 1000) 输出描述:输出对数 输入例子1:10 输出例子1:2 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;// 质数：只能被１和本身整除，最小质数为２bool is_zhishu(int x) &#123; for (int i = 2; i*i &lt;= x; i++)&#123; if (x%i == 0) return false; &#125; return true;&#125;int fun(int n) &#123; int res = 0; for (int i = 2; i &lt;= n / 2; i++)&#123; if (is_zhishu(i) &amp;&amp; is_zhishu(n - i)) res++; &#125; return res;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; fun(n) &lt;&lt; endl; return 0;&#125; 4、geohash编码geohash编码：geohash常用于将二维的经纬度转换为字符串，分为两步：第一步是经纬度的二进制编码，第二步是base32转码。此题考察纬度的二进制编码：算法对纬度[-90, 90]通过二分法进行无限逼近（取决于所需精度，本题精度为6）。注意，本题进行二分法逼近过程中只采用向下取整来进行二分，针对二分中间值属于右区间。算法举例如下： 针对纬度为80进行二进制编码过程：1) 区间[-90, 90]进行二分为[-90, 0),[0, 90]，成为左右区间，可以确定80为右区间，标记为1；2) 针对上一步的右区间[0, 90]进行二分为[0, 45),[45, 90]，可以确定80是右区间，标记为1；3) 针对[45, 90]进行二分为[45, 67),[67,90],可以确定80为右区间，标记为1；4) 针对[67,90]进行二分为[67, 78),[78,90]，可以确定80为右区间，标记为1；5) 针对[78, 90]进行二分为[78, 84),[84, 90]，可以确定80为左区间，标记为0；6) 针对[78, 84)进行二分为[78, 81), [81, 84)，可以确定80为左区间，标记为0； 输入描述:输入包括一个整数n,(-90 ≤ n ≤ 90) 输出描述:输出二进制编码 输入例子1:80 输出例子1:111100 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;// -66string fun(int n) &#123; string res; int k = 0; int l = -90, r = 90; while (k != 6)&#123; int mid = floor((l + r) / 2.0); if (mid &lt;= n)&#123; res.push_back('1'); l = mid; &#125; else&#123; res.push_back('0'); r = mid; &#125; k++; &#125; return res;&#125;string fun2(int n) &#123; string res; int k = 0; int l = -90, r = 90; while (k != 6)&#123; int mid = l + r &gt; 0 ? floor((l + r) / 2.0) : -floor(-(l + r) / 2.0); if (mid &lt;= n)&#123; res.push_back('1'); l = mid; &#125; else&#123; res.push_back('0'); r = mid; &#125; k++; &#125; return res;&#125;int main() &#123; int n; // (-90 ≤ n ≤ 90) cin &gt;&gt; n; cout &lt;&lt; fun2(n) &lt;&lt; endl; return 0;&#125; 注：题中向下取整存在歧义 腾讯2017暑期实习生编程题1、构造回文给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？输出需要删除的字符个数。 输入描述: 输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000. 输出描述: 对于每组数据，输出一个整数，代表最少需要删除的字符个数。 输入例子1:abcdagoogle 输出例子1:2 2 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;// 求原字符串和其反串的最大公共子序列的长度int fun(string s1, string s2) &#123; if (s1.size() == 1) return 1; int len = s1.size(); vector&lt;vector&lt;int&gt;&gt; arr(len + 1, vector&lt;int&gt;(len + 1)); for (int i = 0; i &lt;= len; i++)&#123; for (int j = 0; j &lt;= len; j++)&#123; if (i == 0 || j == 0)&#123; arr[i][j] =0; &#125; else if (s1[i-1] == s2[j-1])&#123; arr[i][j] = arr[i - 1][j - 1] + 1; &#125; else&#123; arr[i][j] = max(arr[i][j - 1], arr[i-1][j]); &#125; &#125; &#125; return arr[len][len];&#125;int main() &#123; string s; // 1 &lt;= s.length &lt;= 1000 while (cin &gt;&gt; s)&#123; string s2 = s; reverse(s2.begin(), s2.end()); cout &lt;&lt; s.size()-fun(s,s2) &lt;&lt; endl; &#125; return 0;&#125; 2、算法基础-字符移位小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？ 输入描述: 输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000. 输出描述: 对于每组数据，输出移位后的字符串。 输入例子1:AkleBiCeilD 输出例子1:kleieilABCD 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool is_upper(char c)&#123; return c &gt;= 'A' &amp;&amp; c &lt;= 'Z';&#125;string fun(string &amp;s) &#123; if (s.size() == 1) return s; for (int i = 0; i &lt; s.size(); i++)&#123; if (is_upper(s[i]))&#123; for (int j = i + 1; j &lt; s.size(); j++)&#123; if (!is_upper(s[j]))&#123; int k = j; char t = s[j]; while (k&gt;i)&#123; s[k] = s[k - 1]; k--; &#125; s[i] = t; break; &#125; &#125; &#125; &#125; return s;&#125;int main() &#123; string s; // 1 &lt;= s.length &lt;= 1000 while (cin &gt;&gt; s)&#123; cout &lt;&lt; fun(s) &lt;&lt; endl; &#125; return 0;&#125; 3、有趣的数字小Q今天在上厕所时想到了这个问题：有n个数，两两组成二元组，相差最小的有多少对呢？相差最大呢？ 输入描述: 输入包含多组测试数据。 对于每组测试数据： N - 本组测试数据有n个数 a1,a2…an - 需要计算的数据 保证: 1&lt;=N&lt;=100000,0&lt;=ai&lt;=INT_MAX. 输出描述: 对于每组数据，输出两个数，第一个数表示差最小的对数，第二个数表示差最大的对数。 输入例子1:6 45 12 45 32 5 6 输出例子1:1 2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void fun(int n,vector&lt;int&gt; &amp;vec) &#123; int min_count = 0, max_count = 0; if (n &gt; 1)&#123; sort(vec.begin(), vec.end()); if (vec[0] == vec[n - 1])&#123; // 11111 min_count = n*(n - 1) / 2; max_count = n*(n - 1) / 2; &#125; else&#123; // min int min = vec[1] - vec[0]; for (int i = 0; i &lt; n - 1; i++)&#123; if (vec[i + 1] - vec[i] &lt; min)&#123; min = vec[i + 1] - vec[i]; &#125; &#125; if (min == 0)&#123; // 11233 int time; for (int i = 0; i &lt; n; i++)&#123; time = 1; while (i + 1 &lt; n &amp;&amp; vec[i + 1] == vec[i])&#123; time++; i++; &#125; min_count += time*(time - 1)/2; &#125; &#125; else&#123; // 12457 for (int i = 0; i &lt; n - 1; i++)&#123; if (vec[i + 1] - vec[i] == min)&#123; min_count++; &#125; &#125; &#125; // max int max = vec[n - 1] - vec[0]; int l = 0, r = 0; for (int i = 0; i &lt; n; i++)&#123; if (vec[i] == vec[0]) l++; else break; &#125; for (int i = n - 1; i &gt;= 0; i--)&#123; if (vec[i] == vec[n-1]) r++; else break; &#125; max_count = l*r; &#125; &#125; cout &lt;&lt; min_count &lt;&lt; \" \" &lt;&lt; max_count &lt;&lt; endl;&#125;int main() &#123; int n; while (cin &gt;&gt; n)&#123; vector&lt;int&gt; vec(n); for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; vec[i]; &#125; fun(n, vec); &#125; return 0;&#125; 腾讯2016研发工程师编程题1、生成格雷码在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同， 则称这种编码为格雷码(Gray Code)，请编写一个函数，使用递归的方法生成N位的格雷码。 给定一个整数n，请返回n位的格雷码，顺序为从0开始。 测试样例：1 返回：[“0”,”1”] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*n: 0 1 2 3 0 0 00 000 1 10 100 110 11 010 01 011 111 101 001*/class GrayCode &#123;public: // 题目不严谨case通过率为9.09% // 用例:2 // 对应输出应该为:[\"00\",\"01\",\"11\",\"10\"] // 你的输出为:[\"00\",\"10\",\"11\",\"01\"] vector&lt;string&gt; getGray2(int n) &#123; if (n == 0) return&#123; \"0\" &#125;; vector&lt;string&gt; res&#123; \"0\", \"1\" &#125;; for (int i = 1; i &lt; n; i++)&#123; for (int j = 0; j &lt; res.size(); j++)&#123; res[j].push_back('0'); &#125; for (int j = res.size()-1; j &gt;=0; j--)&#123; string t = res[j]; t[t.size() - 1] = '1'; res.push_back(t); &#125; &#125; return res; &#125; vector&lt;string&gt; getGray(int n) &#123; if (n == 0) return&#123; \"0\" &#125;; vector&lt;string&gt; res&#123; \"0\", \"1\" &#125;; for (int i = 1; i &lt; n; i++)&#123; for (int j = 0; j &lt; res.size(); j++)&#123; res[j]='0' + res[j]; &#125; for (int j = res.size()-1; j &gt;=0; j--)&#123; string t = res[j]; t[0] = '1'; res.push_back(t); &#125; &#125; return res; &#125;&#125;; 2、微信红包春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。 给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。 若没有金额超过总数的一半，返回0。测试样例：[1,2,3,2,2],5返回：2 123456789101112131415161718192021222324class Gift &#123;public: /* 如果重复的次数超过一半的话，一定有相邻的数字相同这种情况的 对数组同时去掉两个不同的数字，到最后剩下的一个数就是该数字 */ int getValue(vector&lt;int&gt; gifts, int n) &#123; int res = gifts[0], time = 1; for(int i=1;i&lt;gifts.size();i++)&#123; if(gifts[i]==res) time++; else&#123; time--; if(time == 0)&#123; res = gifts[i]; &#125; &#125; &#125; time = 0; for(int i=0;i&lt;gifts.size();i++)&#123; if(gifts[i] == res) time++; &#125; return time&gt;gifts.size()/2?res:0; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"},{"name":"CodeCode","slug":"CodeCode","permalink":"http://yoursite.com/categories/CodeCode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/tags/后台开发/"},{"name":"技术类编程题","slug":"技术类编程题","permalink":"http://yoursite.com/tags/技术类编程题/"}]},{"title":"3D微信小游戏 轮盘控制模块 three.js","slug":"30","date":"2019-11-11T08:05:00.000Z","updated":"2019-12-18T04:23:15.671Z","comments":true,"path":"2019/11/11/30/","link":"","permalink":"http://yoursite.com/2019/11/11/30/","excerpt":"一、场景构造three.js基础如果是刚接触3D引擎，关于three.js的基础知识可以参考之前的博客Three.js+tween.js 基础(一) 中的基本概念篇部分。（场景 、相机 、渲染器 、添加对象） 微信小游戏中使用three使用微信开发者工具创建新的小游戏模板，AppID选择测试号，得到的是飞机大战的源文件，在这个基础上进行修改。","text":"一、场景构造three.js基础如果是刚接触3D引擎，关于three.js的基础知识可以参考之前的博客Three.js+tween.js 基础(一) 中的基本概念篇部分。（场景 、相机 、渲染器 、添加对象） 微信小游戏中使用three使用微信开发者工具创建新的小游戏模板，AppID选择测试号，得到的是飞机大战的源文件，在这个基础上进行修改。 game.js: 123456import './js/libs/weapp-adapter'import './js/libs/symbol'import Main from './js/main'new Main() game.json: 123&#123; \"deviceOrientation\": \"landscapeRight\"&#125; 改为横屏游戏。 最后，清空images、audio和js文件夹。添加 libs 和main.js空文件到js文件夹。 最终得到：代码部分的修改在main.js。 静止的场景main.js 代码主体部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 引入threeimport * as THREE from 'libs/three.js'// 一些全局变量var Colors = &#123; ... &#125;var WIDTH = window.innerWidth;var HEIGHT = window.innerHeight;var Sea = function () &#123; ... &#125;var Cloud = function () &#123; ... &#125;var Sky = function () &#123; ... &#125;var AirPlane = function () &#123; ... &#125;var Pilot = function () &#123; ... &#125;/** * 游戏主函数 */export default class Main &#123; constructor() &#123; // 创建场景，相机和渲染器 this.createScene(); // 添加光源 this.createLights(); this.start() &#125; createScene() &#123; ... &#125; createLights() &#123; ... &#125; createPlane() &#123; ... &#125; createSea() &#123; ... &#125; createSky() &#123; ... &#125; start() &#123; // 添加对象 this.createPlane(); this.createSea(); this.createSky(); window.requestAnimationFrame(this.loop.bind(this), canvas); &#125; update() &#123; &#125; loop() &#123; this.update() this.renderer.render(this.scene, this.camera); window.requestAnimationFrame(this.loop.bind(this), canvas); &#125;&#125; 动画渲染main.js 修改update()： 1234567891011update() &#123; // 转动大海和云 this.sea.mesh.rotation.z += .005; this.sky.rotation.z += .01; // 更新每帧的飞机 this.updatePlane(); // 更新每帧的海浪 this.sea.moveWaves();&#125; 添加 updatePlane()，更新每帧的飞机 1234updatePlane() &#123; this.airplane.propeller.rotation.x += 0.3; this.airplane.pilot.updateHairs(); &#125; 为 Pilot 添加原型函数 updateHairs() ，让头发飘起来: 123456789101112131415Pilot.prototype.updateHairs = function () &#123; // 获得头发 var hairs = this.hairsTop.children; // 根据 angleHairs 的角度更新头发 var l = hairs.length; for (var i = 0; i &lt; l; i++) &#123; var h = hairs[i]; // 每根头发将周期性的基础上原始大小的75%至100%之间作调整。 h.scale.y = .75 + Math.cos(this.angleHairs + i / 3) * .25; &#125; // 在下一帧增加角度 this.angleHairs += 0.16;&#125; 更新每帧的海浪，为 Sea 添加原型函数 moveWaves() : 12345678910111213141516171819202122232425262728Sea.prototype.moveWaves = function () &#123; // 获取顶点 var verts = this.mesh.geometry.vertices; var l = verts.length; for (var i = 0; i &lt; l; i++) &#123; var v = verts[i]; // 获取关联的值 var vprops = this.waves[i]; // 更新顶点的位置 v.x = vprops.x + Math.cos(vprops.ang) * vprops.amp; v.y = vprops.y + Math.sin(vprops.ang) * vprops.amp; // 下一帧自增一个角度 vprops.ang += vprops.speed; &#125; // 告诉渲染器代表大海的几何体发生改变 // 事实上，为了维持最好的性能 // Three.js 会缓存几何体和忽略一些修改 // 除非加上这句 this.mesh.geometry.verticesNeedUpdate = true; this.mesh.rotation.z += .005;&#125; 二、轮盘控制创建UI部分main.js 轮盘控制，分数信息，技能按钮这些部分和游戏主体分开，都创建在UI部分，使用新的场景和正交相机，需要保证在各个机型位置相对不变。这里只添加轮盘控制，分数信息，技能按钮以后再写。。。。修改 start() 、loop() ： 123456789101112131415start() &#123; // 添加对象 this.createPlane(); this.createSea(); this.createSky(); this.createUI(); window.requestAnimationFrame(this.loop.bind(this), canvas); &#125;loop() &#123; this.update() this.renderer.render(this.scene, this.camera); this.ui.render(this.renderer); window.requestAnimationFrame(this.loop.bind(this), canvas); &#125; 添加 createUI() 1234567891011createUI() &#123; // 利用新建一个场景，并创建一个正交相机 // 把UI元素放在这个场景里，渲染的时候同时渲染多个场景 this.ui = new UI(); // 创建轮盘 var controller = new Controller(); // console.log(controller)； controller.mesh.position.set(30 + controller.controllerRadius - WIDTH * 0.5, 20 + controller.controllerRadius - HEIGHT * 0.5, 0); this.controller = controller; this.ui.add(this.controller.mesh);&#125; 添加 UI 及其原型函数 add()、render() 123456789101112var UI = function () &#123; this.scene = new THREE.Scene(); this.camera = new THREE.OrthographicCamera(WIDTH / -2, WIDTH / 2, HEIGHT / 2, HEIGHT / -2, 0, 10000); this.camera.position.z = 10000;&#125;UI.prototype.add = function (obj) &#123; this.scene.add(obj);&#125;UI.prototype.render = function (renderer) &#123; renderer.clearDepth(); renderer.render(this.scene, this.camera);&#125; 添加轮盘 Controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var Controller = function () &#123; this.mesh = new THREE.Object3D(); var controllerRadius = HEIGHT * 0.17 &gt; 105 ? 105 : HEIGHT * 0.17; this.controllerRadius = controllerRadius; // 创建轮盘 var geometry = new THREE.CircleGeometry(controllerRadius, 32); var material = new THREE.LineBasicMaterial(&#123; color: 0xf7d9aa &#125;); geometry.vertices.shift(); var circle = new THREE.LineLoop(geometry, material); this.mesh.add(circle); var geometry = new THREE.CircleGeometry(controllerRadius, 32); var material = new THREE.MeshBasicMaterial(&#123; color: 0xffffff, transparent: true, opacity: 0.1 &#125;); var bgcircle = new THREE.Mesh(geometry, material); this.mesh.add(bgcircle); // 创建当前位置 var wheel = new THREE.Object3D(); wheel.name = \"wheel\"; var geometry = new THREE.CircleGeometry(controllerRadius * 0.33, 32); var material = new THREE.MeshBasicMaterial(&#123; color: 0xffffff, transparent: true, opacity: 0.1 &#125;); var circle1 = new THREE.Mesh(geometry, material); wheel.add(circle1); var geometry = new THREE.CircleGeometry(controllerRadius * 0.33 - 2, 32); var material = new THREE.MeshBasicMaterial(&#123; color: 0x201D13, transparent: true, opacity: 0.1 &#125;); var circle2 = new THREE.Mesh(geometry, material); wheel.add(circle2); this.mesh.add(wheel); // 创建指向标&#125; 轮盘控制main.js start()中添加事件监听，update()中更新每帧的鼠标位置和轮盘 123456789101112131415161718192021222324252627start() &#123; // 添加对象 this.createPlane(); this.createSea(); this.createSky(); this.createUI(); this.mousePos = &#123; x: 0, y: 0 &#125;; // 初始化事件监听 this.touchEvent(); window.requestAnimationFrame(this.loop.bind(this), canvas); &#125;update() &#123; // 转动大海和云 this.sea.mesh.rotation.z += .005; this.sky.rotation.z += .01; // 更新每帧的飞机 this.updatePlane(); // 更新每帧的海浪 this.sea.moveWaves(); // 更新每帧的鼠标位置 this.updatePosition(); &#125; 添加 touchEvent() 事件监听，实时更新 mousePos 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950touchEvent() &#123; canvas.addEventListener('touchstart', ((e) =&gt; &#123; e.preventDefault() var radius = this.controller.controllerRadius; var tx = (e.touches[0].clientX - 30 - radius) / radius; var ty = (HEIGHT -e.touches[0].clientY - 20 - radius) / radius; if (this.checkIsFingerOnController(tx, ty)) &#123; this.touched = true; this.controller.mesh.children[2].children[1].material.opacity = 0.3; this.mousePos = &#123; x: tx, y: ty &#125;; &#125; &#125;).bind(this)) canvas.addEventListener('touchmove', ((e) =&gt; &#123; e.preventDefault() if (this.touched) &#123; var radius = this.controller.controllerRadius; var tx = (e.touches[0].clientX - 30 - radius) / radius; var ty = (HEIGHT-e.touches[0].clientY - 20 - radius) / radius; if (this.checkIsFingerOnController(tx, ty))&#123; this.mousePos = &#123; x: tx, y: ty &#125;; &#125; else&#123; let k = ty/tx; if (tx &gt; 0 &amp;&amp; ty &gt; 0) &#123;tx = 1 / Math.sqrt(k * k + 1);ty = k * tx;&#125; else if (tx &lt; 0 &amp;&amp; ty &gt; 0) &#123; tx = -1 / Math.sqrt(k * k + 1); ty = k * tx; &#125; else if (tx &gt; 0 &amp;&amp; ty &lt; 0) &#123; tx = 1 / Math.sqrt(k * k + 1); ty = k * tx; &#125; else &#123; tx = -1 / Math.sqrt(k * k + 1); ty = k * tx; &#125; this.mousePos = &#123; x: tx, y: ty &#125;; &#125; &#125; &#125;).bind(this)) canvas.addEventListener('touchend', ((e) =&gt; &#123; e.preventDefault() this.touched = false; this.controller.mesh.children[2].children[1].material.opacity = 0.1; this.mousePos = &#123; x: 0, y: 0 &#125;; &#125;).bind(this)) &#125; checkIsFingerOnController(x, y) &#123; return x*x+y*y&lt;1; &#125; 添加 updatePosition() ，更新当前轮盘位置 12345678910111213141516171819updatePosition() &#123; var radius = this.controller.controllerRadius; // 在x轴上-radius至radius之间移动点标 // 根据鼠标的位置在-1与1之间的范围，使用 normalize 函数实现（如下） var targetX = this.normalize(this.mousePos.x, -1, 1, (-1 + 0.33) * radius, (1 - 0.33)*radius); var targetY = this.normalize(this.mousePos.y, -1, 1, (-1 + 0.33) * radius, (1 - 0.33)*radius); // 在每帧通过添加剩余距离的一小部分的值移动点标 this.controller.mesh.children[2].position.x += (targetX - this.controller.mesh.children[2].position.x) * 0.25; this.controller.mesh.children[2].position.y += (targetY - this.controller.mesh.children[2].position.y) * 0.25; &#125;normalize(v, vmin, vmax, tmin, tmax) &#123; var nv = Math.max(Math.min(v, vmax), vmin); var dv = vmax - vmin; var pc = (nv - vmin) / dv; var dt = tmax - tmin; var tv = tmin + (pc * dt); return tv; &#125; 修改 updatePlane() ，更新当前飞机位置 123456789101112131415161718192021updatePlane() &#123; // 在x轴上-140至140之间和y轴25至175之间移动飞机 // 根据鼠标的位置在-1与1之间的范围，使用 normalize 函数实现（如下） var targetX = this.normalize(this.mousePos.x, -1, 1, -140, 140); var targetY = this.normalize(this.mousePos.y, -1, 1, 25, 175); // 更新飞机的位置 //this.airplane.mesh.position.x = targetX; // 在每帧通过添加剩余距离的一小部分的值移动飞机 this.airplane.mesh.position.y += (targetY - this.airplane.mesh.position.y) * 0.1; this.airplane.mesh.position.x += (targetX - this.airplane.mesh.position.x) * 0.05; // 剩余的距离按比例转动飞机 this.airplane.mesh.rotation.z = (targetY - this.airplane.mesh.position.y) * 0.0128; this.airplane.mesh.rotation.x = (this.airplane.mesh.position.y - targetY) * 0.0064; this.airplane.propeller.rotation.x += 0.3; this.airplane.pilot.updateHairs(); &#125; 代码主体部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 引入threeimport * as THREE from 'libs/three.js'// 一些全局变量var Colors = &#123; ... &#125;var WIDTH = window.innerWidth;var HEIGHT = window.innerHeight;var Sea = function () &#123; ... &#125;Sea.prototype.moveWaves = function () &#123; ... &#125;var Cloud = function () &#123; ... &#125;var Sky = function () &#123; ... &#125;var AirPlane = function () &#123; ... &#125;var Pilot = function () &#123; ... &#125;Pilot.prototype.updateHairs = function () &#123; ... &#125;var UI = function () &#123; ... &#125;UI.prototype.add = function (obj) &#123; ... &#125;UI.prototype.render = function (renderer) &#123; ... &#125;var Controller = function () &#123; ... &#125;/** * 游戏主函数 */export default class Main &#123; constructor() &#123; // 创建场景，相机和渲染器 this.createScene(); // 添加光源 this.createLights(); this.start() &#125; createScene() &#123; ... &#125; createLights() &#123; ... &#125; createPlane() &#123; ... &#125; createSea() &#123; ... &#125; createSky() &#123; ... &#125; createUI() &#123; ... &#125; updatePlane() &#123; ... &#125; touchEvent() &#123; ... &#125; checkIsFingerOnController(x, y) &#123; ... &#125; updatePosition() &#123; ... &#125; normalize(v, vmin, vmax, tmin, tmax) &#123; ... &#125; start() &#123; // 添加对象 this.createPlane(); this.createSea(); this.createSky(); this.createUI(); this.mousePos = &#123; x: 0, y: 0 &#125;; // 初始化事件监听 this.touchEvent(); window.requestAnimationFrame(this.loop.bind(this), canvas); &#125; update() &#123; // 转动大海和云 this.sea.mesh.rotation.z += .005; this.sky.rotation.z += .01; // 更新每帧的飞机 this.updatePlane(); // 更新每帧的海浪 this.sea.moveWaves(); // 更新每帧的鼠标位置 this.updatePosition(); &#125; loop() &#123; this.update() this.renderer.render(this.scene, this.camera); window.requestAnimationFrame(this.loop.bind(this), canvas); &#125;&#125; 相关链接：Github项目地址three.js官方文档The Making of “The Aviator”: Animating a Basic 3D Scene with Three.js 翻译","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"THREE","slug":"THREE","permalink":"http://yoursite.com/categories/THREE/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"}],"tags":[{"name":"Three.js","slug":"Three-js","permalink":"http://yoursite.com/tags/Three-js/"},{"name":"3D微信小游戏","slug":"3D微信小游戏","permalink":"http://yoursite.com/tags/3D微信小游戏/"},{"name":"轮盘控制","slug":"轮盘控制","permalink":"http://yoursite.com/tags/轮盘控制/"}]},{"title":"C++后台开发知识总结（四）操作系统/Linux 内核","slug":"29","date":"2019-11-08T08:23:39.000Z","updated":"2019-12-18T04:22:25.834Z","comments":true,"path":"2019/11/08/29/","link":"","permalink":"http://yoursite.com/2019/11/08/29/","excerpt":"相关：C++后台开发知识总结（一）C++基础C++后台开发知识总结（二）数据库C++后台开发知识总结（三）计算机网络C++后台开发知识总结（四）操作系统/Linux 内核 中断为什么需要中断：提高CPU运行效率中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。","text":"相关：C++后台开发知识总结（一）C++基础C++后台开发知识总结（二）数据库C++后台开发知识总结（三）计算机网络C++后台开发知识总结（四）操作系统/Linux 内核 中断为什么需要中断：提高CPU运行效率中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。 中断一般三类：1.由CPU外部引起的，如I/O中断、时钟中断2.来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出3.在程序中使用了系统调用引起的。 中断处理机制为保证系统实时性，中断服务程序必须足够简短，但实际应用中某些时候发生中断时必须处理大量的事物，这时候如果都在中断服务程序中完成，则会严重降低中断的实时性，基于这个原因，linux系统提出了一个概念：把中断服务程序分为两部分-顶半部-底半部 。 顶半部中断处理程序，功能是”登记中断”，当一个中断发生时，它进行相应地硬件读写后就把中断例程的下半部挂到该设备的下半部执行队列中去。特点：响应速度快 ，不可中断 request_irq用于实现中断的注册功能:int request_irq(unsigned int irq, void (*handler)(int, void*, struct pt_regs *), unsigned long flags, const char *devname, void *dev_id)返回0表示成功,或者返回一个错误码功能：向内核注册一个中断服务函数，发生中断号为irq的中断的时候，会执行handle指针函数。 中断注册(参数) 1）unsigned int irq 中断号。 2）void (*handler)(int,void *,struct pt_regs *) 中断处理函数。3）unsigned long flags 与中断管理有关的各种选项，如快速中断，共享中断 IRQF_DISABLED(SA_INTERRUPT) 如果设置该位,表示是一个“快速”中断处理程序，保证中断处理的原子性(不被打断)，在服务该中断时,不会被其他类型的中断打断IRQF_SHARED(SA_SHIRQ) 表明中断可以在设备间共享。共享中断就是将不同的设备挂到同一个中断信号线上。Linux对共享的支持主要是为PCI设备（如声卡、网卡、MODEM等）服务。 4）const char * devname 设备名5）void *dev_id 共享中断时使用。void free_irq(unsigned int irq, void *dev_id) 释放中断 底半部中断处理的大部分工作都在底半部，它几乎做了中断处理程序的所有事情。特点：处理与中断有相关性但是可以延后执行的任务，可中断，而且可以被新的中断打断底半部机制主要有：tasklet、工作队列和软中断软中断：软中断作为下半部机制的代表，是随着SMP（share memory processor）的出现应运而生的，也是tasklet实现的基础。它的出现就是因为要满足上面所提出的上半部和下半部的区别，使得对时间不敏感的任务延后执行，产生后并不是马上可以执行，必须要等待内核的调度才能执行。而且可以在多个CPU上并行执行，使得总的系统效率可以更高。tasklet：由于软中断允许多个CPU同时操作，这就导致设计上的复杂度变高，如果某种应用并不需要在多个CPU上并行执行，那么软中断其实是没有必要的。因此诞生了弥补以上两个要求的tasklet。它具有以下特性：a）一种特定类型的tasklet只能运行在一个CPU上，不能并行，只能串行执行。b）多个不同类型的tasklet可以并行在多个CPU上。c）软中断是静态分配的，在内核编译好之后，就不能改变。但tasklet就灵活许多，可以在运行时改变（比如添加模块时）。如果不需要软中断的并行特性，tasklet就是最好的选择。工作队列：1、由内核线程去执行，换句话说总在进程上下文执行。2、可以睡眠，阻塞。 信号信号：对于 Linux来说，实际信号是软中断，用来通知进程发生了异步事件。一个进程收到一个信号类似与处理器收到一个中断请求。信号为 Linux 提供了一种处理异步事件的方法。比如，终端用户输入了 ctrl+c（会产生SIGINT信号，对该信号的默认反应就是进程终止） 来中断程序，会通过信号机制停止一个程序。 信号的名字和编号：每个信号都有一个名字和编号，这些名字都以“SIG”开头，例如“SIGIO ”、“SIGCHLD”等等。信号定义在signal.h头文件中，信号名都定义为正整数。具体的信号名称可以使用kill -l来查看信号的名字以及序号，信号是从1开始编号的，不存在0号信号。kill对于信号0又特殊的应用。 信号的处理有三种方法，分别是：忽略、捕捉和默认动作忽略信号，大多数信号可以使用这个方式来处理，但是有两种信号不能被忽略（分别是 SIGKILL和SIGSTOP）捕捉信号：当该信号产生时，由内核来调用用户自定义的函数，以此来实现某种信号的处理。系统默认动作，对于每个信号来说，系统都对应由默认的处理动作，当发生了该信号，系统会自动执行。不过，对系统来说，大部分的处理方式都比较粗暴，就是直接杀死该进程。信号的使用：常用的 kill 命令就是一个发送信号的工具，kill 9 PID来杀死进程。比如，我在后台运行了一个 top 工具，通过 ps 命令可以查看他的 PID（进程标志号），通过 kill 9 来发送了一个终止进程的信号来结束了 top 进程。 如果查看信号编号和名称，可以发现9对应的是 9) SIGKILL，正是杀死该进程的信号。而以下的执行过程实际也就是执行了9号信号的默认动作——杀死进程。 信号的种类可靠信号与不可靠信号不可靠信号：Linux的信号继承自早期的Unix信号，信号值小于SIGRTMIN（34）的信号都是不可靠信号。这就是”不可靠信号”的来源。它的主要问题是信号可能丢失。1-31 都是不可靠的。可靠信号：34-64重新设计的一套信号集合，不会出现信号丢失，支持排队实时信号与非实时信号实时信号 ： 就是可靠信号 ；非实时信号：不可靠信号 SIGCHLD信号：在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，按系统默认将忽略此信号，如果父进程希望被告知其子系统的这种状态，则应捕捉此信号。子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。SIGCLD信号：对于SIGCLD的早期处理方式如下:如果进程特地设置该信号的配置为SIG_IGN,则子进程状态信息会被丢弃，将不产生僵死进程。 进程与线程进程是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；线程是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。 进程和线程的区别：1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）3、进程是资源分配的最小单位，线程是CPU调度的最小单位。4、进程创建/撤消或切换的开销大于线程。由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。7、一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。8、进程适应于多核、多机分布；线程适用于多核。游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程 多线程和多进程的不同进程是资源分配的最小单位，而线程时CPU调度的最小单位。多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布。多进程和多线程的使用场景：多进程，适用于CPU密集型，多线程，适用于I/O密集型的工作场景。多进程适用于多机分布式场景中，易于多机扩展，多线程适用于单机多核分布式场景。 如何设计server，使得能够接收多个客户端的请求:多线程，线程池，io复用线程产生的原因：进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：进程在同一时间只能干一件事，进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：1、从资源上来讲，线程是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。2、从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。（3、从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。 进程间通信进程用户空间是相互独立的，一般而言是不能相互访问的。但很多情况下进程间需要互相通信，来完成系统的某项功能。进程通过与内核及其它进程之间的互相通信来协调它们的行为。进程通信的应用场景：数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 进程间通信主要包括：管道、消息队列、信号量、信号、共享内存、以及套接字socket。 管道( pipe )主要包括无名管道和命名管道管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信消息队列是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；特点：1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。信号量( semophore )是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不用于存储进程间通信数据。特点：1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。4)支持信号量组。信号( sinal )是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。共享内存( shared memory )它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等特点：1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取2)因为多个进程可以同时操作，所以需要进行同步3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问Linux内存共享有多种，如mmap()、Posix共享内存、System V 共享内存。套接字( socket )可用于不同主机之间的进程通信。 线程间通信Posix实现的线程，需使用 -lpthread 库编译 : 1$ g++ test.cpp -lpthread -o test 1、 临界区通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；确保在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。假如有多个线程试图同时访问临界区，那么在有一个线程进入后其他任何试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程能够继续抢占，并以此达到用原子方式操作共享资源的目的。2、 互斥量为协调一起对一个共享资源的单独访问而设计的对资源加锁能阻塞其他线程的访问 123456#include &lt;pthread.h&gt;pthread_mutex_t sum_mutex; //互斥锁pthread_mutex_init( &amp;sum_mutex, NULL ); //对锁进行初始化pthread_mutex_lock( &amp;sum_mutex ); //加锁pthread_mutex_unlock( &amp;sum_mutex ); //释放锁，供其他线程使用pthread_mutex_destroy( &amp;sum_mutex ); //注销锁 3、信号量它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 123456pthread_mutex_t tasks_mutex; //互斥锁pthread_cond_t tasks_cond; //条件信号量pthread_cond_init( &amp;tasks_cond, NULL ); //初始化条件信号量pthread_cond_signal( &amp;tasks_cond ); //signal:向hello1发送信号pthread_cond_wait( &amp;tasks_cond, &amp;tasks_mutex ); //wait:等待信号量生效，接收到信号，向hello2发出信号，跳出wait,执行后续pthread_cond_destroy( &amp;tasks_cond ); //销毁条件变量 4、事件用来通知线程有一些事件已发生，从而启动后继任务的开始 内核线程：内核线程需要系统内核支持，同时系统内核支持内核线程，内核线程只运行在内核态，不受用户态上下文的拖累，内核线程只能由系统内核管理，像普通进程一样被调度。内核线程的使用是廉价的，唯一使用的资源就是内核栈和上下文切换时保存寄存器的空间。轻量级进程： LWP， Light-Weight Process也是一种用户线程，运行在用户态，是建立在系统内核上的，由系统内核支持的用户线程。它是内核线程的高度抽象，所以轻量级进程需要系统内核支持，同时系统内核支持内核线程。每个轻量级进程都与一个内核线程关联，轻量级进程与内核线程一对一关联。用户级线程：完全建立在用户态空间的线程，用户线程的创建、调度、同步和销毁全部在用户态空间中完成，不需要系统内核支持，也不需要系统内核支持内核线程。Linux使用的线程库采用的是一对一关联，一个用户线程对应一个轻量级进程，一个轻量级进程对应一个内核线程。 协程协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。协程和线程区别那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 微内核与宏内核宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。优点：效率高。缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。 微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。 用户态和内核态区别用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。 用户态到内核态的转化原理:1、系统调用这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。2、异常当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就到了内核态，比如缺页异常。3、外围设备的中断当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。2、使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。 线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：SP:堆栈指针，指向当前栈的栈顶地址PC:程序计数器，存储下一条将要执行的指令EAX:累加寄存器，用于加法乘法的缺省寄存器 实现多线程Win: 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;void thread01() &#123; for (int i = 0; i &lt; 5; i++) cout &lt;&lt; \"Thread 01 is working ！\" &lt;&lt; endl;&#125;void thread02() &#123; for (int i = 0; i &lt; 5; i++) cout &lt;&lt; \"Thread 02 is working ！\" &lt;&lt; endl;&#125;int main()&#123; thread task01(thread01); thread task02(thread02); task01.join(); task02.join(); for (int i = 0; i &lt; 5; i++) cout &lt;&lt; \"Main thread is working ！\" &lt;&lt; endl; return 0;&#125; 阻塞主流程:两个子线程并行执行，join函数会阻塞主流程，所以子线程执行完成后才继续执行主线程。 从主流程中分离:可以使用detach将子线程从主流程中分离，独立运行，不会阻塞主线程： 1234thread task01(thread01);thread task02(thread02);task01.detach();task02.detach(); 带参数线程： 123void thread01(int n) &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; \"Thread 01 is working ！\" &lt;&lt; endl;&#125; 1thread task01(thread01,5); 多线程数据竞争:使用线程互斥对象mutex保持数据同步。mutex类的使用需要包含头文件mutex。 12345678910111213141516171819#include &lt;mutex&gt;mutex mu; //线程互斥对象void thread01() &#123; while (totalNum &gt; 0)&#123; mu.lock(); //同步数据锁 cout &lt;&lt; totalNum &lt;&lt; endl; totalNum--; mu.unlock(); //解除锁定 &#125;&#125;void thread02() &#123; while (totalNum &gt; 0)&#123; mu.lock(); cout &lt;&lt; totalNum &lt;&lt; endl; totalNum--; mu.unlock(); &#125;&#125; Linux: 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;pthread.h&gt;using namespace std;#define NUM_THREADS 5// 线程的运行函数,函数返回的是函数指针，便于后面作为参数 void* say_hello(void* args)&#123; cout &lt;&lt; \"Hello Runoob！\" &lt;&lt; endl;&#125;int main()&#123; // 定义线程的 id 变量，多个变量使用数组 pthread_t tids[NUM_THREADS]; for(int i = 0; i &lt; NUM_THREADS; ++i) &#123; //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数 int ret = pthread_create(&amp;tids[i], NULL, say_hello, NULL); if (ret != 0) &#123; cout &lt;&lt; \"pthread_create error: error_code=\" &lt;&lt; ret &lt;&lt; endl; &#125; &#125; pthread_exit(NULL);&#125; 使用 -lpthread 库编译 : 1$ g++ test.cpp -lpthread -o test.o 传递参数： 1234567void *PrintHello(void *threadid)&#123; // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取 int tid = *((int*)threadid); cout &lt;&lt; \"Hello Runoob! 线程 ID, \" &lt;&lt; tid &lt;&lt; endl; pthread_exit(NULL);&#125; 1rc = pthread_create(&amp;threads[i], NULL,PrintHello, (void *)&amp;(indexes[i])); 通过结构传递多个参数 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt;using namespace std;#define NUM_THREADS 5struct thread_data&#123; int thread_id; char *message;&#125;;void *PrintHello(void *threadarg)&#123; struct thread_data *my_data; my_data = (struct thread_data *) threadarg; cout &lt;&lt; \"Thread ID : \" &lt;&lt; my_data-&gt;thread_id ; cout &lt;&lt; \" Message : \" &lt;&lt; my_data-&gt;message &lt;&lt; endl; pthread_exit(NULL);&#125;int main ()&#123; pthread_t threads[NUM_THREADS]; struct thread_data td[NUM_THREADS]; int rc; int i; for( i=0; i &lt; NUM_THREADS; i++ )&#123; cout &lt;&lt;\"main() : creating thread, \" &lt;&lt; i &lt;&lt; endl; td[i].thread_id = i; td[i].message = \"This is message\"; rc = pthread_create(&amp;threads[i], NULL, PrintHello, (void *)&amp;td[i]); //传入到参数必须强转为void*类型，即无类型指针 if (rc)&#123; cout &lt;&lt; \"Error:unable to create thread,\" &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; &#125; pthread_exit(NULL);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;using namespace std;#define NUM_THREADS 5void *wait(void *t)&#123; int i; long tid; tid = (long)t; sleep(1); cout &lt;&lt; \"Sleeping in thread \" &lt;&lt; endl; cout &lt;&lt; \"Thread with id : \" &lt;&lt; tid &lt;&lt; \" ...exiting \" &lt;&lt; endl; pthread_exit(NULL);&#125;int main ()&#123; int rc; int i; pthread_t threads[NUM_THREADS]; pthread_attr_t attr; void *status; // 初始化并设置线程为可连接的（joinable） pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for( i=0; i &lt; NUM_THREADS; i++ )&#123; cout &lt;&lt; \"main() : creating thread, \" &lt;&lt; i &lt;&lt; endl; rc = pthread_create(&amp;threads[i], NULL, wait, (void *)i ); if (rc)&#123; cout &lt;&lt; \"Error:unable to create thread,\" &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; &#125; // 删除属性，并等待其他线程 pthread_attr_destroy(&amp;attr); for( i=0; i &lt; NUM_THREADS; i++ )&#123; rc = pthread_join(threads[i], &amp;status); if (rc)&#123; cout &lt;&lt; \"Error:unable to join,\" &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; \"Main: completed thread id :\" &lt;&lt; i ; cout &lt;&lt; \" exiting with status :\" &lt;&lt; status &lt;&lt; endl; &#125; cout &lt;&lt; \"Main: program exiting.\" &lt;&lt; endl; pthread_exit(NULL);&#125; 并发(concurrency)和并行(parallelism)并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。 系统调用系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。系统调用举例：对文件进行写操作，open和write都是系统调用。创建进程fork，vfork等都是系统调用。 Linux虚拟内存为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。1 每个进程有独立的虚拟地址空间，进程访问的虚拟地址并不是真正的物理地址2 虚拟地址可通过每个进程上页表与物理地址进行映射，获得真正物理地址3 如果虚拟地址对应物理地址不在物理内存中，则产生缺页中断，真正分配物理地址，同时更新进程的页表；如果此时物理内存已耗尽，则根据内存替换算法淘汰部分页面至物理磁盘中。 虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。 优点：1.既然每个进程的内存空间都是一致而且固定的，所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际的内存地址，这是有独立内存空间的好处2.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存3.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片 内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚拟内存的代价： 虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存 虚拟地址到物理地址的转换，增加了指令的执行时间。 页面的换入换出需要磁盘I/O，这是很耗时的 如果一页中只有一部分数据，会浪费内存。操作系统中的页表寻址页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。缺页中断malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：1、保护CPU现场2、分析中断原因3、转入缺页中断处理程序进行处理4、恢复CPU现场，继续执行但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：1、在指令执行期间产生和处理缺页中断信号2、一条指令在执行期间，可能产生多次缺页中断3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。 malloc 的内存都有相应的 free ，就不会出现内存泄露了吗free 的内存:1 malloc 使用 mmap 分配的内存 ( 大于 128k) ， free 会调用 unmmap 系统调用马上还给 OS ，实现真正释放。2 堆内的内存，只有释放堆顶的空间，同时堆顶总连续空闲空间大于 128k 才使用 sbrk(-SIZE) 回收内存，真正归还 OS 。3 堆内的空闲空间，是不会归还给 OS 的。 狭义上的内存泄露是指 malloc 的内存，没有 free ，导致内存浪费，直到程序结束。而广义上的内存泄露就是进程使用内存量不断增加，或大大超出系统原设计的上限。free 了的堆空闲空间并不会马上归还 OS ，并且堆内的空洞（碎片）更是很难真正释放，除非空洞成为了新的堆顶。因此，随着系统频繁地 malloc 和 free ，尤其对于小块内存，堆内将产生越来越多不可用的碎片，导致“内存泄露”。而这种“泄露”现象使用 valgrind 是无法检测出来的。因此，当我们写程序时，不能完全依赖 glibc 的 malloc 和 free 的实现。更好方式是建立属于进程的内存池，即一次分配 (malloc) 大块内存，小内存从内存池中获得，当进程结束或该块内存不可用时，一次释放 (free) ，可大大减少碎片的产生。 操作系统中的结构体对齐，字节对齐1、原因：1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。2、规则1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。 12345678910111213141516171819202122232425262728293031323334353637// 字节对齐struct SByte1 &#123; double d; // 长度8，偏移量为0；存放位置区间[0,7] char j; // 长度1，偏移量为8；存放位置区间[8] int a; // 长度4，偏移量12；存放位置区间[12，15] &#125;; sizeof(SByte1); // = 16 struct SByte2 &#123; char j; // 长度1，偏移量为0；存放位置区间[0,1] double d; // 长度8，偏移量8；存放位置区间[8,15] int a; // 长度4，偏移量16；存放位置区间[16,19]&#125;; sizeof(SByte2); // = 24，为了凑成8的倍数，填充20~23 //可以通过#pragma pack(n)来设定变量以n字节对齐方式，n=1,2,4,8,16#pragma pack(push) //保存对齐状态 #pragma pack(4) //设定为4字节对齐 class CByte &#123; char c; //长度1 &lt; 4 按1对齐；偏移量为0；存放位置区间[0,1]double d; //长度8 &gt; 4 按4对齐；偏移量为4；存放位置区间[4,11] int i; //长度4 = 4 按4对齐；偏移量为12；存放位置区间[12,15]&#125;; #pragma pack(pop) //恢复对齐状态 sizeof(CByte); // = 16 #pragma pack(2)struct AA &#123;int a; //长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]char b; //长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]short c; //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]char d; //长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节&#125;;#pragma pack() 软链接和硬链接区别为了解决文件共享问题，Linux引入了软链接和硬链接。除了为Linux解决文件共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。硬链接：若1个inode号对应多个文件名软连接：若文件用户数据块中存放的内容是另一个文件的路径名指向1，软链接可以理解成快捷方式。它和windows下的快捷方式的作用是一样的。2，硬链接等于cp -p 加 同步更新。对文件jys建立软链接和硬链接： 软链接：ln -s 源文件 目标文件硬链接：ln 源文件 目标文件区别:软链接文件的大小和创建时间和源文件不同。硬链接文件和源文件的大小和创建时间一样。删除源文件多软链接和硬链接的影响：查看软链接文件，查看的文件不存在。但是删除源文件，硬链接文件还可以查看。i节点是文件和目录的唯一标识，删除了jys,只是删除了从920586到jys的映射关系，不影响它和jys.hard的映射关系。此图也解释了硬链接的同步更新，对源文件修改，操作系统只认i节点，于是操作系统就将修改内容写进所有i节点相同名字不同的文件。 什么是大端小端以及如何判断大端小端小端就是低位字节放在内存的低地址端, 大端就是低位字节放在内存的高地址端 12345678int JudgeSystem(void)&#123; int a = 1; char * p = (char *)&amp;a; //如果是小端则返回1，如果是大端则返回0 return *p;&#125; 或者根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。 Linux 常用命令ls命令ls –l # 以详情模式(long listing fashion)列出文件夹的内容。ls –a # 列出文件夹里的所有内容，包括以”.”开头的隐藏文件。mkdir命令“mkdir”(Make directory)命令在命名路径下创建新的目录。然而如果目录已经存在了，那么它就会返回一个错误信息”不能创建文件夹，文件夹已经存在了”(“cannot create folder, folder already exists”)grep命令通常用于对一些命令的输出进行筛选加工grep [-acinv] [–color=auto] ‘查找字符串’ filenamels -l | grep -i file # 把ls -l的输出中包含字母file（不区分大小写）的内容输出cp命令cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中mv命令mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中mv file1 file2 # 把文件file1重命名为file2rm命令rm -i file # 删除文件file，在删除之前会询问是否进行该操作rm -fr dir # 强制删除目录dir中的所有文件ps命令ps aux # 查看系统所有的进程数据vim命令用于文本编辑输入 i ，退出命令模式，进入INSERT模式开始修改内容……按 esc 键，退出INSERT模式，进入命令模式再输入 :wq，保存文件，退出vi编辑器time命令$ time dateSun Mar 26 22:45:34 GMT-8 2006 # 命令”date”的执行结果real 0m0.136s # 实际时间user 0m0.010s # 用户CPU时间sys 0m0.070s # 系统CPU时间touch 命令“touch”命令代表了将文件的访问和修改时间更新为当前时间。touch命令只会在文件不存在的时候才会创建它。如果文件已经存在了，它会更新时间戳，但是并不会改变文件的内容。chmod 命令chmod 777 abc.sh # 为拥有者，用户所在组和其它用户提供读，写，执行权限。tar命令tar -zxvf abc.tar.gz # (记住’z’代表了.tar.gz)tar -jxvf abc.tar.bz2 # (记住’j’代表了.tar.bz2) 压缩的更好但是也更慢 awk的使用awk [-F field-separator] ‘commands’ input-file(s)1、找到当前文件夹下所有的文件和子文件夹,并显示文件大小$ ls –l | awk ‘{print $5 “\\t” $9}’ 2、找到当前文件夹下所有的文件和子文件夹，并显示文件大小，并显示排序&gt; ls -l | awk ‘BEGIN {COUNT = -1; print “BEGIN COUNT”}{COUNT = COUNT + 1; print COUNT”\\t”$5”\\t”$9}END {print “END, COUNT = “COUNT}’ 3、找到当前文件夹下所有的子文件夹,并显示排序&gt; ls -l | awk ‘BEGIN {print “BEGIN COUNT”} /4096/{print NR”\\t”$5”\\t”$9}END {print “END”}’ Linux下怎么得到一个文件的100到200行sed -n ‘100,200p’ inputfileawk ‘NR&gt;=100&amp;&amp;NR&lt;=200{print}’ inputfilehead -200 inputfile|tail -100 OS缺页置换算法当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。当前最常采用的就是LRU算法。 虚拟内存置换的方式比较常见的内存替换算法有：FIFO，LRU，LFU，LRU-K，2Q。1、FIFO（先进先出淘汰算法）思想：最近刚访问的，将来访问的可能性比较大。实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。弊端：无法体现页面冷热信息2、LFU（最不经常访问淘汰算法）思想：如果数据过去被访问多次，那么将来被访问的频率也更高。实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。开销：排序开销。弊端：缓存颠簸。3、LRU（最近最少使用替换算法）思想：如果数据最近被访问过，那么将来被访问的几率也更高。实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。优点：LRU算法对热点数据命中率是很高的。缺陷：1）缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。2）缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。4、LRU-K（LRU-2、LRU-3）思想：最久未使用K次淘汰算法。LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。实现：1）数据第一次被访问，加入到访问历史列表；2）如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；3）当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；4）缓存数据队列中被再次访问后，重新排序；5）需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。针对问题：LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。5、2Q类似LRU-2。使用一个FIFO队列和一个LRU队列。实现1）新访问的数据插入到FIFO队列；2）如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；3）如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；4）如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；5）LRU队列淘汰末尾的数据。针对问题：LRU的缓存污染弊端：当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。 linux常见的调度算法调度算法：根据系统的资源分配策略所规定的资源分配算法。调度，当有多个进程(或多个进程发出的请求)要使用这些资源时，因为资源的有限性，必须按照一定的原则选择进程(请求)来占用资源。1、先来先去服务（队列）如果早就绪的进程排在就绪队列的前面，迟就绪的进程排在就绪队列的后面，那么先来先服务(FCFS: first come first service)总是把当前处于就绪队列之首的那个进程调度到运行状态。也就说，它只考虑进程进入就绪队列的先后，而不考虑它的下一个CPU周期的长短及其他因素。有利于长作业以及CPU繁忙的作业，不利于短作业以及I/O繁忙的作业2、最短优先（优先队列）对预计执行时间短的作业（进程）优先分派处理机.通常后来的短作业不抢先正在执行的作业.比FCFS缩短作业的等待时间；长作业的运行得不到保证。3、轮转法(RoundRobin)将系统中所有的就绪进程按照FCFS原则，排成一个队列。每次调度时将CPU分派给队首进程，让其执行一个时间片。时间片的长度从几个ms到几百ms。当进程用完分给它的时间片后，调度程序便停止该进程的运行，并把它放入就绪队列的末尾。让每个进程在就绪队列中的等待时间与享受服务的时间成正比例。4、多级反馈队列算法设置多个就绪队列，分别赋予不同的优先级。新进程进入内存后，先投入队列1的末尾，按FCFS算法调度;若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按FCFS算法调度;如此下去，降低到最后的队列，则按”时间片轮转”算法调度直到完成。仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾。优点：为提高系统吞吐量和缩短平均周转时间而照顾短进程。为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程。不必估计进程的执行时间，动态调节。 linux文件系统Linux ext2, ext3, ext4 文件系统：Ext，全称extended file system, extfs，即扩展文件系统，Ext2就代表第二代文件扩展系统，Linux ext2/ext3文件系统使用索引节点来记录文件信息，作用像windows的文件分配表。索引节点是一个结构，它包含了一个文件的长度、创建及修改时间、权限、所属关系、磁盘中的位置等信息。一个文件系统维护了一个索引节点的数组，每个文件或目录都与索引节点数组中的唯一一个元素对应。Ext3/Ext4，是Ext2的升级版，只不过为了快速恢复文件系统，减少一致性检查的时间，增加了日志功能，所以Ext2被称为索引式文件系统，而Ext3/Ext4被称为日志式文件系统。 Ext家族是Linux支持度最广、最完整的文件系统，当我们格式化磁盘后，就已经为我们规划好了所有的inode/block/metadate等数据，这样系统可以直接使用，不需要再进行动态的配置，这也是它最优秀的特点，不过这也是它最显著的缺点，磁盘容量越大，格式化越慢，centos7.x已经选用xfs作为默认文件系统，xfs是一种适合大容量磁盘和处理巨型文件的文件系统。虚拟文件系统（Virtual File System, 简称 VFS）， 是 Linux 内核中的一个软件层，用于给用户空间的程序提供文件系统接口。正是由于在内核中引入了VFS，跨文件系统的文件操作才能实现，“一切皆是文件” 的口号才能承诺。 目录 描述 / (root 文件系统) root 文件系统是文件系统的顶级目录。 /bin /bin 目录包含用户的可执行文件。 /boot 包含启动 Linux 系统所需要的静态引导程序和内核可执行文件以及配置文件。 /dev 该目录包含每一个连接到系统的硬件设备的设备文件。这些文件不是设备驱动，而是代表计算机上的每一个计算机能够访问的设备。 /etc 包含主机计算机的本地系统配置文件。 /home 主目录存储用户文件，每一个用户都有一个位于 /home 目录中的子目录（作为其主目录）。 /lib 包含启动系统所需要的共享库文件。 /media 一个挂载外部可移动设备的地方，比如主机可能连接了一个 USB 驱动器。 /mnt 一个普通文件系统的临时挂载点（如不可移动的介质），当管理员对一个文件系统进行修复或在其上工作时可以使用。 /opt 可选文件，比如供应商提供的应用程序应该安装在这儿。 /root 这不是 root（/）文件系统。它是 root 用户的主目录。 /sbin 系统二进制文件。这些是用于系统管理的可执行文件。 /tmp 临时目录。被操作系统和许多程序用来存储临时文件。用户也可能临时在这儿存储文件。注意，存储在这儿的文件可能在任何时候在没有通知的情况下被删除。 /usr 该目录里面包含可共享的、只读的文件，包括可执行二进制文件和库、man 文件以及其他类型的文档。 /var 可变数据文件存储在这儿。这些文件包括日志文件、MySQL 和其他数据库的文件、Web 服务器的数据文件、邮件以及更多。 《深入理解linux内核》第12章：虚拟文件系统 以及 第18章：Ext2和Ext3文件系统 以及 第16章：访问文件，可以让你深入了解linux文件系统 如何修改文件最大句柄数linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”too many open files”的错误。故在linux服务器高并发调优时，往往需要预先调优Linux参数，修改Linux最大文件句柄数。有两种方法： ulimit -n &lt;可以同时打开的文件数&gt;，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值）首先用ulimit -a查询Linux相关的参数，如下所示：123max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 1024 其中，open files就是最大文件句柄数，默认是1024个。修改Linux最大文件句柄数： ulimit -n 2048， 将最大句柄数修改为 2048个。 对所有进程都有效的方法，修改Linux系统参数vi /etc/security/limits.conf 添加 * soft nofile 65536* hard nofile 65536将最大句柄数改为65536修改以后保存，注销当前用户，重新登录，修改后的参数就生效了 System V、Posix IPCPosix是“可移植操作系统接口（Portable Operating System Interface ）的首字母简写，但它并不是一个单一的标准，而是IEEE开发的一系列标准，System v是Unix操作系统众多版本的一个分支。将这两个名词放在一起讨论的一般是在Linux的进程间通信中，如在信号量编程中，有Posix信号量和System V信号量。Posix信号量是基于内存的，即信号量值是放在共享内存中的。而System v信号量测试基于内核的，它放在内核里面，相同点都是它们都可以用于进程或者线程间的同步。“Posix 信号量”，指的是单个计数信号量；“System v信号量”时，所指的是计数信号量集。 死锁产生的四个必要条件及如何预防死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件：互斥：一个资源每次只能被一个进程使用。请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。不可剥夺: 进程已获得的资源，在末使用完之前，不能强行剥夺，只能在使用后自己释放循环等待: 若干进程之间形成一种头尾相接的循环等待资源关系。 通过破坏死锁产生的4个必要条件来预防死锁，由于资源互斥是资源使用的固有特性是无法改变的。破坏”请求与保持条件“：第一种方法静态分配：每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配：每个进程在申请所需要的资源时他本身不占用系统资源。破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用。破坏“循环等待”条件：采用资源有序分配，将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，每个进程按编号递增的请求资源，释放则相反 Linux的4种锁机制互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。互斥锁和读写锁的区别：1）读写锁区分读者和写者，而互斥锁不区分2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。 怎么实现线程池1.设置一个生产者消费者队列，作为临界资源2.初始化n个线程，并让其运行起来，加锁去队列取任务运行3.当任务队列为空的时候，所有线程阻塞4.当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程 如何实现linux的高并发，线程池的思想线程池：线程的开启和回收是要消耗系统性能的，对于大量使用线程的场景，使用线程池来进行管理，实现单个线程的复用，提高并发效率。线程池里面的线程都是现成的而且能够重复使用，我们不需要临时创建大量线程，然后在任务结束时又销毁大量线程。一个理想的线程池能够合理地动态调节池内线程数量，既不会因为线程过少而导致大量任务堆积，也不会因为线程过多了而增加额外的系统开销。 线程池的处理流程如下：1、判断线程池里的工作线程（线程池中实际执行任务的线程）是否都在执行任务，如果不是（工作线程空闲或者还有工作线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。2、线程池判断工作队列（用来存放没有处理的任务，提供一种缓冲机制）是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。3、判断线程池里的线程是否都处于工作状态（线程的闲与忙的状态是通过互斥量实现的），如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。因为这里涉及到多个线程同时访问一个队列的问题，所以我们需要互斥锁来保护队列 生产者消费者并发程序死循环+来连接时新建线程的方法效率有点低，怎么改进？提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术。生产者消费者并发程序要求能够写得出来生产者（producer）和消费者（consumer）问题是并发处理中最常见的一类问题，是一个多线程同步问题的经典案例。有一个或者多个生产者产生某种类型的数据，并放置在固定大小的缓冲区中，一个消费者从缓冲区中取数据，每次取一项。任何时候，只有一个生产者或者消费者可以访问缓冲区；同时，消费者只能在缓冲区不为空的时候从缓冲区中读数据，生产者只能在缓冲区不为满的时候向缓冲区写入数据。第一是缓冲区的互斥访问问题，任意时刻最多只能有一个线程访问缓冲区，Linux下可以使用互斥量pthread_mutex_t mutex对访问缓冲区的临界区代码进行保护。第二是生产者和消费者对缓冲区访问的同步问题，生产者在缓冲区满时不能向缓冲区中写入数据，同时消费者在缓冲区空时不能读取数据，这里采用两个信号量sem_t room_sem（表示缓冲区有可用空间）和sem_t product_sem（表示缓冲区有可用产品）来对缓冲区进行同步。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #include&lt;unistd.h&gt; // POSIX 操作系统 API 的访问功能#include&lt;pthread.h&gt; //线程#include&lt;semaphore.h&gt; //信号量 #define PRODUCER_NUM 5 //生产者数目#define CONSUMER_NUM 5 //消费者数目#define POOL_SIZE 11 //缓冲池大小int pool[POOL_SIZE]; //缓冲区int head=0; //缓冲池读取指针int rear=0; //缓冲池写入指针sem_t room_sem; //同步信号量，表示缓冲区有可用空间sem_t product_sem; //同步信号量，表示缓冲区有可用产品pthread_mutex_t mutex; //互斥量void producer_fun(void *arg)&#123; while (1) &#123; sleep(1); sem_wait(&amp;room_sem); pthread_mutex_lock(&amp;mutex); //生产者往缓冲池中写入数据 pool[rear] = 1; rear = (rear + 1) % POOL_SIZE; printf(\"producer %d write to pool\\n\", (int)arg); printf(\"pool size is %d\\n\",(rear-head+POOL_SIZE)%POOL_SIZE); pthread_mutex_unlock(&amp;mutex); sem_post(&amp;product_sem); &#125;&#125; void consumer_fun(void *arg)&#123; while (1) &#123; int data; sleep(10); sem_wait(&amp;product_sem);pthread_mutex_lock(&amp;mutex); //消费者从缓冲池读取数据 data = pool[head]; head = (head + 1) % POOL_SIZE; printf(\"consumer %d read from pool\\n\", (int)arg); printf(\"pool size is %d\\n\",(rear-head+POOL_SIZE)%POOL_SIZE); pthread_mutex_unlock(&amp;mutex); sem_post(&amp;room_sem); &#125;&#125; int main()&#123; pthread_t producer_id[PRODUCER_NUM]; pthread_t consumer_id[CONSUMER_NUM]; pthread_mutex_init(&amp;mutex, NULL); //初始化互斥量 int ret = sem_init(&amp;room_sem, 0, POOL_SIZE-1); //初始化信号量room_sem为缓冲池大小 if (ret != 0) &#123; printf(\"sem_init error\"); exit(0); &#125; ret = sem_init(&amp;product_sem, 0, 0); //初始化信号量product_sem为0，开始时缓冲池中没有数据 if (ret != 0) &#123; printf(\"sem_init error\"); exit(0); &#125; for (int i = 0; i &lt; PRODUCER_NUM; i++) &#123; //创建生产者线程 ret =pthread_create(&amp;producer_id[i], NULL, producer_fun, (void*)i); if (ret != 0) &#123; printf(\"producer_id error\"); exit(0); &#125; //创建消费者线程 ret = pthread_create(&amp;consumer_id[i], NULL, consumer_fun, (void*)i); if (ret != 0) &#123; printf(\"consumer_id error\"); exit(0); &#125; &#125; for(int i=0;i&lt;PRODUCER_NUM;i++) &#123; pthread_join(producer_id[i],NULL); pthread_join(consumer_id[i],NULL); &#125; exit(0);&#125; 惊群效应惊群是指多个进程/线程在等待同一资源时，每当资源可用，所有的进程/线程都来竞争资源的现象。春天来了, 公园出现了很多麻雀. 而你恰巧有一个玉米粒. 扔出去，立马无数麻雀过来争抢.而最终只有一只麻雀得到了.而那些没有抢到的麻雀很累…….对于操作系统来说，多个进程/线程在等待同一资源是，也会产生类似的效果，其结果就是每当资源可用，所有的进程/线程都来竞争资源，造成的后果：1）系统对用户进程/线程频繁的做无效的调度、上下文切换，系统系能大打折扣。2）为了确保只有一个线程得到资源，用户必须对资源操作进行加锁保护，进一步加大了系统开销。accept惊群多线程或多进程调用accept就会出现如下情况，当前多个进程阻塞在accept中，此时有客户端连接时，内核就会通知阻塞在accept的所有进程，这时就会造成惊群现象，也就是所有accept都会返回 但是只有一个能拿到有效的文件描述符，其他进程最后都会返回无效描述符。但在linux kernel 版本2.6 以上时，accept惊群的问题已经解决，大致方案就是选一个阻塞在accept的进程返回。epoll惊群但是在IO复用中， select/poll/epoll 还是存在这种现象，其原因就是这些阻塞函数造成了以上同样的问题。如果多个进程/线程阻塞在监听同一个监听socket fd的epoll_wait上，当有一个新的连接到来时，所有的进程都会被唤醒。避免惊群：Nginx采用互斥锁 fork、vfork、clone的区别fork,vfork,clone都是linux的系统调用，主要用来linux创建新的子进程或线程（vfork创造出来的是线程）。forkfork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用： 123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void); 由于fork()后会产生一个和父进程完全相同的子进程，fork函数调用一次返回两次，子进程返回值为0，父进程返回子进程的进程ID，返回类型为pid_t。但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制技术-Copy-On-Write”。写时复制 fork子进程完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”，如果父子进程一直对这个页面是同一个页面，直到其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用。fork之后内核一般会通过将子进程放在队列的前面，以让子进程先执行，因为很多情况下子进程要马上执行exec，会清空栈、堆，这些和父进程共享的空间，加载新的代码段。exec将新程序代码加载（拷贝）到子进程的内存空间，替换掉原有的与父进程一模一样的代码和数据，让子进程空间运行全新的程序。 123456789101112131415#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; pid_t pid; pid = fork(); if(pid&lt;0) printf(\"error in fork!\\n\"); else if(pid == 0) printf(\"I am the child process,ID is %d\\n\",getpid()); else printf(\"I am the parent process,ID is %d\\n\",getpid()); return 0;&#125; Wait():我们用fork启动一个进程时，子进程就有了自己的生命，并将独立地运行。有时，我们需要知道某个子进程是否已经结束了，我们可以通过wait函数安排父进程在子进程之后结束。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。返回的是子进程的PIDVfork在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。 123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t vfork(void); vfork创建出的子进程（线程）共享了父进程的变量，内存资源不独立，这一次是指针复制，2者的指针指向了同一个内存，所以子进程修改了变量，父进程的变量同样受到了影响。另外由vfork创造出来的子进程还会导致父进程挂起，除非子进程exit或者exec才会唤起父进程。fork和vfork的区别：1.fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段 fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。 vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。 fork( )当需要改变共享数据段中变量的值，则拷贝父进程。 cloneclone函数功能强大，带了众多参数，因此由他创建的进程要比前面2种方法要复杂。clone可以让你有选择性的继承父进程的资源，你可以选择想vfork一样和父进程共享一个虚存空间，从而使创造的是线程，你也可以不和父进程共享，你甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系。int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);fn是函数指针，指向程序的指针，child_stack是为子进程分配系统堆栈空间，flags是标志用来描述你需要从父进程继承那些资源，arg就是传给子进程的参数CLONE_VFORK 父进程被挂起，直至子进程释放虚拟内存资源CLONE_VM 子进程与父进程运行于相同的内存空间 1234int FIBER_STACK = 8192;void * stack = malloc(FIBER_STACK);//为子进程申请系统堆栈clone(&amp;do_something, (char *)stack + FIBER_STACK, CLONE_VM|CLONE_VFORK, 0);int do_something()&#123;&#125; 僵尸进程1）正常进程正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。waitt和waitpid区别和联系 在一个子进程终止前， wait 使其调用者阻塞，而waitpid 有一选择项，可使调用者不阻塞。waitpid并不等待第一个终止的子进程—它有若干个选择项，可以控制它所等待的特定进程。实际上wait函数是waitpid函数的一个特例。unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：1进程号the process ID2退出状态the termination status of the process3运行时间the amount of CPU time taken by the process等2）孤儿进程一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。3）僵尸进程一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。危害：如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。外部消灭：通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源内部解决：1、子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。2、fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。 杀死僵死进程： 1$ kill -HUP `ps -A -ostat,ppid,pid |grep -e '^[Zz]' | awk'&#123;print $2&#125;'` (1) 检查当前僵尸进程信息： 1$ ps -ef | grep defunct | grep -v grep | wc -l 1 1$ top | head -2 (2) 获得杀僵尸进程语句 12$ ps -ef | grep defunct | grep -v grep | awk '&#123;print \"kill -9 \" $2,$3&#125;' //僵尸进程数会大大减少 (3）过一会儿检查当前僵尸进程信息 1$ ps -ef | grep defunct | grep -v grep | wc -l (4) 再次获得杀僵尸进程语句 12$ ps -ef | grep defunct | grep -v grep | awk '&#123;print \"kill -18 \" $3&#125;'//使用信号量18杀其父进程, 僵尸进程应该会全部消失 清除ZOMBIE(僵尸)进程原理: 1$ kill -18 PPID PPID是其父进程, 这个信号是告诉父进程, 该子进程已经死亡了, 请收回分配给他的资源.如果还不行则看先看其父进程又无其他子进程, 如果有, 可能需要先kill其他子进程, 也就是兄弟进程.方法是: 12$ kill -15 PID1 PID2 //PID1,PID2是僵尸进程的父进程的其它子进程.:$ kill -15 PPID //再kill父进程 杀死进程：Kill 234 //杀死pid 为234的进程kill -TERM 234 //杀死进程和子进程 -15kill -9 323 //彻底杀死进程kill -HUP 456 //重跑 (restart) 进程killall python //通过进程名字结束进程 5种IO模型1.阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作2.非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。3.信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。4.IO复用/多路转接IO:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数5.异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。 阻塞，非阻塞，同步，异步阻塞和非阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。同步和异步：调用者必须循环自己去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步 异步编程的事件循环事件循环就是不停循环等待事件的发生，然后将这个事件的所有处理器，以及他们订阅这个事件的时间顺序依次依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。当同时并发地处理多个请求时，以上的概念也是正确的，可以这样理解：在单个的线程中，事件处理器是一个一个按顺序执行的。即如果某个事件绑定了两个处理器，那么第二个处理器会在第一个处理器执行完毕后，才开始执行。在这个事件的所有处理器都执行完毕之前，事件循环不会去检查是否有新的事件触发。在单个线程中，一切都是有顺序地一个一个地执行的！ page cache加快从磁盘读取文件的速率。page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache项，一个是radix tree，另一个是双向链表。Radix tree 是一种搜索树，Linux内核利用这个数据结构来通过文件内偏移快速定位Cache 项 select、poll、epoll的区别IO多路复用：一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。Linux中的 select，poll，epoll 都是IO多路复用的机制。epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现。 select 时间复杂度O(n)select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。缺点：单个进程可监视的fd数量被限制；线性扫描，即采用轮询的方法，效率较低；需要维护一个用来存放大量fd的数据结构，用户空间和内核空间在传递该结构时复制开销大。它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流，只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。 poll 时间复杂度O(n)poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，但是它没有最大连接数的限制，原因是它是基于链表来存储的。poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。 epoll 时间复杂度O(1)epoll可以理解为event poll，epoll会把哪个流发生了怎样的I/O事件通知我们。 epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。水平触发——只要满足条件，就触发一个事件(只要有数据没有被获取，内核就不断通知你)；边缘触发——每当状态变化时，触发一个事件。epoll的优点：1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。3、epoll使用mmap减少复制开销。 select、poll、epoll区别| 区别 | select| poll | epoll||–|–|–|–|| 支持一个进程所能打开的最大连接数| 单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32*32）| poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的 | 虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接|| FD剧增后带来的IO效率问题| 因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。| 同左 | 因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。|| 消息传递方式 | 内核需要将消息传递到用户空间，都需要内核拷贝动作 | 同左 | epoll通过内核和用户空间共享一块内存来实现的。| epoll怎么实现的Linux epoll机制是通过红黑树和双向链表实现的。3个epoll系统调用: 123int epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout); Linux epoll机制是通过红黑树和双向链表实现的。 首先通过epoll_create()系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过epoll_ctl()系统调用，向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，返回就绪好的事件。 进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞1、进程的五种基本状态： 创建状态：进程正在被创建就绪状态：进程被加入到就绪队列中等待CPU调度运行执行状态：进程正在被运行等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。终止状态：进程运行完毕2、交换技术当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。针对以上问题，提出了两种解决方法：1）交换技术：换出一部分进程到外存，腾出内存空间。2）虚拟存储技术：每个进程只能装入一部分程序和数据。在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。3、活动阻塞，静止阻塞，活动就绪，静止就绪1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。2）静止阻塞：进程在外存，同时被某种原因阻塞了。3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。从而出现了：活动就绪 —— 静止就绪 （内存不够，调到外存）活动阻塞 —— 静止阻塞 （内存不够，调到外存）执行 —— 静止就绪 （时间片用完） 伙伴系统、slab缓存伙伴系统、slab缓存是linux系统物理内存分配时所用到的技术。Linux内核内存管理的一项重要工作就是如何在频繁申请释放内存的情况下，避免碎片的产生。Linux采用伙伴系统解决外部碎片的问题，采用slab解决内部碎片的问题。伙伴系统 （分配的大小由一个页框4k到1024个页框4M）使用场景：内核中很多时候要求分配连续页，为快速检测内存中的连续区域采用的一种技术。Linux内核引入了伙伴系统，把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1、2、4、8、16、32、64、128、256、512和1024个连续页框的页框块。最大可以申请1024个连续页框，也即4MB大小的连续空间。假设要申请一个256个页框的块，先从256个页框的链表中查找空闲块，如果没有，就去512个页框的链表中找，找到了即将页框分为两个256个页框的块，一个分配给应用，另外一个移到256个页框的链表中。如果512个页框的链表中仍没有空闲块，继续向1024个页框的链表查找，如果仍然没有，则返回错误。页框块在释放时，会主动将两个连续的页框块合并成一个较大的页框块。slab缓存适用场景：内核本身经常需要比完整页帧小的多的内存块。slab的目的在于避免内部碎片。从buddy系统获取的内存至少是一个页，也就是4K，如果仅仅需要8字节的内存，显然巨大的内部碎片无法容忍。slab从buddy系统申请空间，将较大的连续内存拆分成一系列较小的内存块。申请空间时从slab中获取大小最相近的小块内存，这样可以有效减少内部碎片。在slab最大的块为8K，slab中所有块在物理上也是连续的。slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免这些内碎片。 在内核中想要分配一段连续的内存，首先向slab系统申请，如果不满足（超过两个页面，也就是8K），直接向buddy系统申请。如果还不满足（超过4M，也就是1024个页面），将无法获取到连续的物理地址。可以通过vmalloc获取虚拟地址空间连续，但物理地址不连续的更大的内存空间。 linux内核中的Timer 定时器机制hrtimer采用红黑树进行高精度定时器的管理，而不是时间轮； 高精度时钟定时器不在依赖系统的tick中断，而是基于事件触发。旧内核的定时器实现依赖于系统定时器硬件定期的tick，基于该tick，内核会扫描timer wheel处理超时事件，会更新jiffies，wall time(墙上时间，现实时间)，process的使用时间等等工作。新的内核不再会直接支持周期性的tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了hrtimer(high resolution timer)：于事件触发。hrtimer的工作原理：通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的Timer 的时间，时钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。 docker下次单独出篇博客总结。。。。。","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"}],"tags":[{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/tags/后台开发/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"},{"name":"Linux 内核","slug":"Linux-内核","permalink":"http://yoursite.com/tags/Linux-内核/"}]},{"title":"C++后台开发知识总结（三）计算机网络","slug":"28","date":"2019-09-26T17:01:31.000Z","updated":"2019-12-18T04:21:50.877Z","comments":true,"path":"2019/09/27/28/","link":"","permalink":"http://yoursite.com/2019/09/27/28/","excerpt":"相关：C++后台开发知识总结（一）C++基础C++后台开发知识总结（二）数据库C++后台开发知识总结（三）计算机网络C++后台开发知识总结（四）操作系统/Linux 内核 OSI与TCP/IP各层的结构与功能，都有哪些协议 OSI七层模型及其包含的协议如下:物理层：在物理媒体上传输原始的数据比特流,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45","text":"相关：C++后台开发知识总结（一）C++基础C++后台开发知识总结（二）数据库C++后台开发知识总结（三）计算机网络C++后台开发知识总结（四）操作系统/Linux 内核 OSI与TCP/IP各层的结构与功能，都有哪些协议 OSI七层模型及其包含的协议如下:物理层：在物理媒体上传输原始的数据比特流,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45 数据链路层：将数据分成一个个数据帧，以数据帧为单位传输。有应有答，遇错重发。传输单位为帧,主要包括的协议为MAC VLAN PPP网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP 会话层： 建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS表示层： 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII应用层： 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS TCP/IP 4层模型包括：网络接口层：MAC VLAN网络层:IP ARP ICMP传输层:TCP UDP应用层:HTTP DNS SMTP TCP/IP/数据链路层的交互过程网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器 传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文根据端口区分；看ip头中的协议标识字段，17是udp，6是tcp 输入网址后发生了什么，用到哪些协议 http、dns、tcp、ip、arp地址解析协议、OSPF链路状态路由协议 1、首先，在浏览器地址栏中输入url2、查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。3、在发送http请求前，需要域名解析(DNS解析)解析获取相应的IP地址。4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。5、握手成功后，浏览器向服务器发送http请求，请求数据包。6、服务器处理收到的请求，将数据返回至浏览器7、浏览器收到HTTP响应8、读取页面内容，浏览器渲染，解析html源码9、生成Dom树、解析css样式、js交互10、客户端和服务器交互11、ajax查询 TCP三次握手和四次挥手 两个序号和三个标志位：（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。（2）确认序号：ack序号，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：ACK：确认序号有效； SYN：发起一个新连接； FIN：释放一个连接 客户端–发送带有SYN标志的数据包–一次握手–服务端服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端客户端–发送带有带有ACK标志的数据包–三次握手–服务端客户端-发送一个FIN，用来关闭客户端到服务器的数据传送服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。服务器-关闭与客户端的连接，发送一个FIN给客户端客户端-发回ACK报文确认，并将确认序号设置为收到序号加1为什么要四次挥手？任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 TIME_WAIT：作用以及如何避免1：主机1发送FIN；此时，主机1进入FIN_WAIT_1状态；2：主机2收到FIN，向主机1回一个ACK报文段；主机1进入FIN_WAIT_2状态；3：主机2发送FIN，请求关闭连接，同时主机2进入LAST_ACK状态；4：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。MSL是指数据包在网络中的最大生存时间 为什么要有TIME_WAIT这个状态：（1）TCP实现必须可靠地终止连接的两个方向(全双工关闭)，主机1必须进入 TIME_WAIT 状态，因为主机1可能面临重发最终ACK的情形。假设最终的ACK丢失，主机2将重发FIN，主机1必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果主机2认为发生错误。（2）避免上一个连接延迟到达的数据包被下一个连接错误接收。如果在被推迟的报文未抵达前接收方断开了连接，随后又建立了一个与之前相同IP、Port的连接，而之前被推迟的报文在这时恰好到达，而此时此新连接非彼连接，从而会发生数据错乱。 出现太多TIME_WAIT可能导致的后果：在高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接。这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。高并发可以让服务器在短时间范围内同时占用大量端口。短连接比如，取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在TIMEWAIT状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的。服务器干正经事的时间和端口（资源）被挂着无法被使用的时间的比例是 1：几百，服务器资源严重浪费。 linux 大量的TIME_WAIT解决办法：通过调整内核参数解决vi /etc/sysctl.conf编辑文件，加入以下内容：net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_fin_timeout = 30 net.ipv4.tcp_syncookies = 1表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；net.ipv4.tcp_tw_reuse = 1表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；net.ipv4.tcp_tw_recycle = 1表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。net.ipv4.tcp_fin_timeout修改系統默认的TIMEOUT时间 TCP、UDP协议的区别 UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式（一般用于即时通信），比如： QQ语音 QQ视频 、直播等等TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP一般用于文件传输、发送和接收 TCP怎么保证可靠性TCP保证可靠性：（1）序列号、确认应答、超时重传数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。（2）窗口控制与高速重发控制/快速重传（重复确认应答）TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒……（3）拥塞控制如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小2。*拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。**快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。 GET 和 POST 的本质区别 GET POST 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 历史 参数保留在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 GET请求的参数是放在URL里的； URL 的最大长度是 2048 个字符 POST请求参数是放在请求body里的，无限制 对数据类型的限制 只允许 ASCII字符 没有限制。也允许二进制数据 安全性 GET的安全性较差，因为所发送的数据是URL的一部分 POST 比GET 更安全，因为参数不会被保存在浏览器历史或web服务器日志中 可见性 数据在URL中对所有人都是可见的 数据不会显示在 URL 中 本质区别: GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 HTTP状态码 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success （成功状态码） 请求正常处理完毕 3XX Redirection （重定向状态码） 需要进行附加操作以完成请求 4XX Client Error （客户端错误状态码） 服务器无法处理请求 5XX Server Error （服务器错误状态码） 服务器处理请求出错 常见状态代码、状态描述的详细说明如下。 200 OK：客户端请求成功。 206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围 300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。 301 moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。 302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得， 304 not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。 403 Forbidden：服务器收到请求，但是拒绝提供服务。 404 not Found：请求资源不存在，举个例子：输入了错误的URL。 HTTP长连接、短连接在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：Connection:keep-alive复制代码在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP和HTTPS的区别HTTPS即加密的HTTP，HTTPS并不是一个新协议，而是HTTP+SSL（TLS）。原本HTTP先和TCP（假定传输层是TCP协议）直接通信，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。而加了SSL后，就变成HTTP先和SSL通信，再由SSL和TCP通信，相当于SSL被嵌在了HTTP和TCP之间，所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份. HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书HTTP协议端口是80，HTTPS协议端口是443 HTTPS优点：HTTPS传输数据过程中使用密钥进行加密，所以安全性更高HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器HTTPS缺点：HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高 数字证书是什么，里面都包含那些内容数字证书是在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。 各种协议与HTTP协议之间的关系 IP地址作用，以及MAC地址作用MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。 流量控制流量控制：防止发送方发的太快，耗尽接收方的资源，从而使接收方来不及处理依据：接收端缓冲区的大小实现流量控制：滑动窗口： 在确认应答策略中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，这样做有一个比较大的缺点，就是性能比较差，尤其是数据往返的时间长的时候，使用滑动窗口，就可以一次发送多条数据，从而就提高了性能。（1）接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK来通知发送端（2）窗口大小指的是不需要接收端的应答，可以一次连续的发送数据（3）操作系统内核为了维护滑动窗口，需要开辟发送缓冲区，来记录当前还有那些数据没有应答，只有确认应答过的数据，才能从缓冲区删掉（4）滑动窗口中的数据类型：发送了尚未确认的，没有发送，但是等待发送的。接收端窗口就是等待确认的数据序号组成。 拥塞控制拥塞控制：防止发送方发的太快，使得网络来不及处理，从而导致网络拥塞拥塞控制的表现：丢包、延时变长拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。拥塞窗口的大小取决于网络的拥塞情况，并且是动态变化的，发送方一般让自己的发送窗口不大于拥塞窗口。1、慢开始TCP 连接开始，cwnd设置为1，字节未超过阈值ssthresh，接到确认呈指数型增长2、拥塞避免超过阈值变为线性增长。一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。3、快重传接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。4、快恢复当发送方连续收到了三个重复确认（为什么是3个？因为1-2个重复ACK，很有可能是乱序，只有在3个及以上的时候才是有可能丢包了）时，把慢开始门限减半，由于发送方现在认为网络很可能没有发生拥塞，跳过指数增加，直接使拥塞窗口的线性增大。采用快恢复算法时，慢开始只在建立连接和网络超时才使用。采用慢开始和拥塞避免算法的时候1.一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度2.一旦出现丢包的情况，就重新进行慢开始，减慢增长速度采用快恢复和快重传算法的时候1.一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度2.一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度流量控制和拥塞控制的区别相同点：现象都是丢包；实现机制都是让发送方发的慢一点，发的少一点不同点：（1）丢包位置：流量控制丢包位置是在接收端上、拥塞控制丢包位置是在路由器上（2）作用的对象：流量控制的对象是接收方，怕发送方发的太快，使得接收方来不及处理拥塞控制的对象是网络，怕发送发发的太快，造成网络拥塞，使得网络来不及处理 DdosDos拒绝服务攻击攻击原理：DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。dos攻击与ddos攻击的区别就是，它是一对一的攻击，而ddos是分布式的攻击。最常见的DoS攻击有对计算机网络的带宽攻击和连通性攻击。带宽攻击： 指以极大的通信量冲击网络，使得所有可用网络资源都被消耗殆尽，最后导致合法的用户请求无法通过。连通性攻击： 指用大量的连接请求冲击计算机，使得所有可用的操作系统资源都被消耗殆尽，最终计算机无法再处理合法用户的请求。传统上，攻击者所面临的主要问题是网络带宽，由于较小的网络规模和较慢的网络速度的限制，攻击者无法发出过多的请求。大多数的DoS攻击还是需要相当大的带宽的，而以个人为单位的黑客们很难使用高带宽的资源。为了克服这个缺点，DoS攻击者开发了分布式的攻击。攻击者简单利用工具集合许多的网络带宽来同时对同一个目标发动大量的攻击请求，这就是DDoS攻击SYN泛洪：攻击主机C(地址伪装后为C)—–大量SYN包—-&gt;被攻击主机 C&lt;——-SYN/ACK包—-被攻击主机由于C地址不可达，被攻击主机等待超时。攻击主机通过发大量SYN包填满未连接队列，导致正常SYN包被拒绝服务。（防范：给每一个请求连接的IP地址分配一个Cookie）常见的dos攻击：死亡之ping：故意产生畸形的测试Ping包，声称自己的尺寸超过64KB上限，使未采取保护措施的网络系统出现内存分配错误，导致TCP/IP协议栈崩溃，最终接收方宕机。泪滴：某些TCP/IP协议栈在收到含有重叠偏移的伪造分段时将崩溃。UDP泛洪：伪造与某一主机的Chargen服务之间的一次的UDP连接，回复地址指向开着Echo服务的一台主机，通过将Chargen和Echo服务互指，来回传送毫无用处且占满带宽的垃圾数据常见的Ddos攻击：Smurf攻击：用一个伪造的源地址连续ping一个或多个计算机网络，这就导致所有计算机所响应的那个计算机并不是实际发送这个信息包的那个计算机。这个伪造的源地址，实际上就是攻击的目标，它将被极大数量的响应信息量所淹没。 XSS和 CSRFXSS跨站脚本攻击，这些可执行的脚本由攻击者提供，最终为用户浏览器加载，不同于大多数攻击，有存储型和反射型。防御方式:编码，过滤，解码CSRF跨站请求伪造（攻击者盗用你的身份，以你的身份发送恶意请求），一次CSRF攻击的步骤：登录受信任的网站A，并在本地生成cookie在不登出A的情况下，访问危险网站B防御的方法：总的思想在客户端页面增加伪随机值Cookie Hashing 所有的表单都包含一个伪随机值验证码不同的表单包含一个不同的伪随机值 socket编程什么是 socketsocket 的原意是“插座”，在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。UNIX/Linux 中的 socket在 UNIX/Linux 系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。为了表示和区分已经打开的文件，UNIX/Linux 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为文件描述符（File Descriptor）。 通过 socket() 函数来创建一个网络连接，或者说打开一个网络文件，socket() 的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如：用 read() 读取从远程计算机传来的数据；用 write() 向远程计算机写入数据。 socket有哪些类型流格式套接字（SOCK_STREAM）SOCK_STREAM 是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送。使用了 TCP 协议（The Transmission Control Protocol，传输控制协议）应用场景：浏览器所使用的 http 协议就基于面向连接的套接字数据报格式套接字（SOCK_DGRAM）计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为数据报套接字所做的校验工作少，所以在传输效率方面比流格式套接字要高。使用 UDP 协议（User Datagram Protocol，用户数据报协议）。应用场景：QQ 视频聊天和语音聊天 常用函数： 12#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; 1、socket()描述字建立函数 12//int socket(int domain, int type, int protocol);int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); domain 指明所使用的协议族，通常为AF_INET，表示互联网协议族（TCP/IP协议族）AF_INET IPv4因特网域，AF_INET6 IPv6因特网域，AF_UNIX Unix域，AF_ROUTE 路由套接字，AF_KEY 密钥套接字，AF_UNSPEC 未指定type 指定socket的类型SOCK_STREAM，SOCK_DGRAM，SOCK_RAW protocolprotocol 通常赋值”0“。 0 选择type类型对应的默认协议，IPPROTO_TCP TCP传输协议，IPPROTO_UDP UDP传输协议，IPPROTO_SCTP SCTP传输协议，IPPROTO_TIPC TIPC传输协议 2、bind()函数：IP号端口号与相应描述字赋值函数 1234567891011121314151617181920212223242526272829303132//int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);//将套接字和IP、端口绑定struct sockaddr_in serv_addr;memset(&amp;serv_addr, 0, sizeof(serv_addr)); //每个字节都用0填充serv_addr.sin_family = AF_INET; //使用IPv4地址serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); //具体的IP地址serv_addr.sin_port = htons(1234); //端口bind(serv_sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));//ipv4对应的是： /*struct sockaddr&#123;unisgned short as_family; // 协议族char sa_data[14]; // IP+端口 &#125;;*///同等替换：/*struct sockaddr_in &#123; sa_family_t sin_family; // 协议族 in_port_t sin_port; // 端口号 struct in_addr sin_addr; // IP地址结构体 unsigned char sin_zero[8]; // 填充 &#125;;*///两个结构是等同的可以先互转换，第一个结构将地址和端口绑定了，第二个结构将两者分开表示*///IP地址结构如下：为32位字 /*struct in_addr &#123; uint32_t s_addr; &#125;;*/ 3、listen()函数：监听设置函数 12//int listen(int sockfd, int backlog);listen(serv_sock, 20); //请求队列中允许的最大请求数20 4、accept()函数：用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程被投入睡眠。 12345//int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);//接收客户端请求struct sockaddr_in clnt_addr;socklen_t clnt_addr_size = sizeof(clnt_addr);int clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size); 5、connect()函数:客户机连接主机 12//int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);connect(sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)); 基于TCP的socket：服务器端程序：1创建一个socket，用函数socket()2绑定IP地址、端口等信息到socket上，用函数bind()3设置允许的最大连接数，用函数listen()4接收客户端上来的连接，用函数accept()5收发数据，用函数send()和recv()，或者read()和write()6关闭网络连接 客户端程序：1创建一个socket，用函数socket()2设置要连接的对方的IP地址和端口等属性3连接服务器，用函数connect()4收发数据，用函数send()和recv()，或read()和write()5关闭网络连接 socket 编程1：读取一个字符串并打印出来。服务器端代码 server.cpp： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;int main()&#123; //创建套接字 int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); //将套接字和IP、端口绑定 struct sockaddr_in serv_addr; memset(&amp;serv_addr, 0, sizeof(serv_addr)); //每个字节都用0填充 serv_addr.sin_family = AF_INET; //使用IPv4地址 serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); //具体的IP地址 serv_addr.sin_port = htons(1234); //端口 bind(serv_sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)); //进入监听状态，等待用户发起请求 listen(serv_sock, 20); //请求队列中允许的最大请求数20 //接收客户端请求 struct sockaddr_in clnt_addr; socklen_t clnt_addr_size = sizeof(clnt_addr); int clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size); //向客户端发送数据 char str[] = \"http://c.biancheng.net/socket/\"; write(clnt_sock, str, sizeof(str)); //关闭套接字 close(clnt_sock); close(serv_sock); return 0;&#125; 客户端代码 client.cpp： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;int main()&#123; //创建套接字 int sock = socket(AF_INET, SOCK_STREAM, 0); //向服务器（特定的IP和端口）发起请求 struct sockaddr_in serv_addr; memset(&amp;serv_addr, 0, sizeof(serv_addr)); //每个字节都用0填充 serv_addr.sin_family = AF_INET; //使用IPv4地址 serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); //具体的IP地址 serv_addr.sin_port = htons(1234); //端口 connect(sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)); //读取服务器传回的数据 char buffer[40]; read(sock, buffer, sizeof(buffer)-1); printf(\"Message form server: %s\\n\", buffer); //关闭套接字 close(sock); return 0;&#125; 启动一个终端（Shell），先编译 server.cpp 并运行：[admin@localhost ~]$ g++ server.cpp -o server[admin@localhost ~]$ ./server #等待请求的到来正常情况下，程序运行到 accept() 函数就会被阻塞，等待客户端发起请求。接下再启动一个终端，编译 client.cpp 并运行：[admin@localhost ~]$ g++ client.cpp -o client[admin@localhost ~]$ ./clientMessage form server: http://c.biancheng.net/socket/client 接收到从 server发送过来的字符串就运行结束了，同时，server 完成发送字符串的任务也运行结束了。 socket 编程2：文件传输Server端代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;netinet/in.h&gt; // sockaddr_in#include&lt;sys/types.h&gt; // socket#include&lt;sys/socket.h&gt; // socket#include&lt;stdio.h&gt; // printf#include&lt;stdlib.h&gt; // exit#include&lt;string.h&gt; // bzero#define SERVER_PORT 8000#define LENGTH_OF_LISTEN_QUEUE 20#define BUFFER_SIZE 1024#define FILE_NAME_MAX_SIZE 512int main(void)&#123; // 声明并初始化一个服务器端的socket地址结构 struct sockaddr_in server_addr; bzero(&amp;server_addr, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = htons(INADDR_ANY); server_addr.sin_port = htons(SERVER_PORT); // 创建socket，若成功，返回socket描述符 int server_socket_fd = socket(PF_INET, SOCK_STREAM, 0); if(server_socket_fd &lt; 0) &#123; perror(\"Create Socket Failed:\"); exit(1); &#125; int opt = 1; setsockopt(server_socket_fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); // 绑定socket和socket地址结构 if(-1 == (bind(server_socket_fd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)))) &#123; perror(\"Server Bind Failed:\"); exit(1); &#125; // socket监听 if(-1 == (listen(server_socket_fd, LENGTH_OF_LISTEN_QUEUE))) &#123; perror(\"Server Listen Failed:\"); exit(1); &#125; while(1) &#123; // 定义客户端的socket地址结构 struct sockaddr_in client_addr; socklen_t client_addr_length = sizeof(client_addr); // 接受连接请求，返回一个新的socket(描述符)，这个新socket用于同连接的客户端通信 // accept函数会把连接到的客户端信息写到client_addr中 int new_server_socket_fd = accept(server_socket_fd, (struct sockaddr*)&amp;client_addr, &amp;client_addr_length); if(new_server_socket_fd &lt; 0) &#123; perror(\"Server Accept Failed:\"); break; &#125; // recv函数接收数据到缓冲区buffer中 char buffer[BUFFER_SIZE]; bzero(buffer, BUFFER_SIZE); if(recv(new_server_socket_fd, buffer, BUFFER_SIZE, 0) &lt; 0) &#123; perror(\"Server Recieve Data Failed:\"); break; &#125; // 然后从buffer(缓冲区)拷贝到file_name中 char file_name[FILE_NAME_MAX_SIZE+1]; bzero(file_name, FILE_NAME_MAX_SIZE+1); strncpy(file_name, buffer, strlen(buffer)&gt;FILE_NAME_MAX_SIZE?FILE_NAME_MAX_SIZE:strlen(buffer)); printf(\"%s\\n\", file_name); // 打开文件并读取文件数据 FILE *fp = fopen(file_name, \"r\"); if(NULL == fp) &#123; printf(\"File:%s Not Found\\n\", file_name); &#125; else &#123; bzero(buffer, BUFFER_SIZE); int length = 0; // 每读取一段数据，便将其发送给客户端，循环直到文件读完为止 while((length = fread(buffer, sizeof(char), BUFFER_SIZE, fp)) &gt; 0) &#123; if(send(new_server_socket_fd, buffer, length, 0) &lt; 0) &#123; printf(\"Send File:%s Failed./n\", file_name); break; &#125; bzero(buffer, BUFFER_SIZE); &#125; // 关闭文件 fclose(fp); printf(\"File:%s Transfer Successful!\\n\", file_name); &#125; // 关闭与客户端的连接 close(new_server_socket_fd); &#125; // 关闭监听用的socket close(server_socket_fd); return 0;&#125; 客户端代码 client.cpp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;netinet/in.h&gt; // sockaddr_in#include&lt;sys/types.h&gt; // socket#include&lt;sys/socket.h&gt; // socket#include&lt;stdio.h&gt; // printf#include&lt;stdlib.h&gt; // exit#include&lt;string.h&gt; // bzero #define SERVER_PORT 8000#define BUFFER_SIZE 1024#define FILE_NAME_MAX_SIZE 512 int main()&#123; // 声明并初始化一个客户端的socket地址结构 struct sockaddr_in client_addr; bzero(&amp;client_addr, sizeof(client_addr)); client_addr.sin_family = AF_INET; client_addr.sin_addr.s_addr = htons(INADDR_ANY); client_addr.sin_port = htons(0); // 创建socket，若成功，返回socket描述符 int client_socket_fd = socket(AF_INET, SOCK_STREAM, 0); if(client_socket_fd &lt; 0) &#123; perror(\"Create Socket Failed:\"); exit(1); &#125; // 绑定客户端的socket和客户端的socket地址结构 非必需 if(-1 == (bind(client_socket_fd, (struct sockaddr*)&amp;client_addr, sizeof(client_addr)))) &#123; perror(\"Client Bind Failed:\"); exit(1); &#125; // 声明一个服务器端的socket地址结构，并用服务器那边的IP地址及端口对其进行初始化，用于后面的连接 struct sockaddr_in server_addr; bzero(&amp;server_addr, sizeof(server_addr)); server_addr.sin_family = AF_INET; if(inet_pton(AF_INET, \"127.0.0.1\", &amp;server_addr.sin_addr) == 0) &#123; perror(\"Server IP Address Error:\"); exit(1); &#125; server_addr.sin_port = htons(SERVER_PORT); socklen_t server_addr_length = sizeof(server_addr); // 向服务器发起连接，连接成功后client_socket_fd代表了客户端和服务器的一个socket连接 if(connect(client_socket_fd, (struct sockaddr*)&amp;server_addr, server_addr_length) &lt; 0) &#123; perror(\"Can Not Connect To Server IP:\"); exit(0); &#125; // 输入文件名 并放到缓冲区buffer中等待发送 char file_name[FILE_NAME_MAX_SIZE+1]; bzero(file_name, FILE_NAME_MAX_SIZE+1); printf(\"Please Input File Name On Server:\\t\"); scanf(\"%s\", file_name); char buffer[BUFFER_SIZE]; bzero(buffer, BUFFER_SIZE); strncpy(buffer, file_name, strlen(file_name)&gt;BUFFER_SIZE?BUFFER_SIZE:strlen(file_name)); // 向服务器发送buffer中的数据 if(send(client_socket_fd, buffer, BUFFER_SIZE, 0) &lt; 0) &#123; perror(\"Send File Name Failed:\"); exit(1); &#125; // 打开文件，准备写入 FILE *fp = fopen(file_name, \"w\"); if(NULL == fp) &#123; printf(\"File:\\t%s Can Not Open To Write\\n\", file_name); exit(1); &#125; // 从服务器接收数据到buffer中 // 每接收一段数据，便将其写入文件中，循环直到文件接收完并写完为止 bzero(buffer, BUFFER_SIZE); int length = 0; while((length = recv(client_socket_fd, buffer, BUFFER_SIZE, 0)) &gt; 0) &#123; if(fwrite(buffer, sizeof(char), length, fp) &lt; length) &#123; printf(\"File:\\t%s Write Failed\\n\", file_name); break; &#125; bzero(buffer, BUFFER_SIZE); &#125; // 接收成功后，关闭文件，关闭socket printf(\"Receive File:\\t%s From Server IP Successful!\\n\", file_name); close(fp); close(client_socket_fd); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"}],"tags":[{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/tags/后台开发/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"C++后台开发知识总结（二）数据库","slug":"27","date":"2019-09-26T14:36:00.000Z","updated":"2019-12-18T04:21:55.732Z","comments":true,"path":"2019/09/26/27/","link":"","permalink":"http://yoursite.com/2019/09/26/27/","excerpt":"相关：C++后台开发知识总结（一）C++基础C++后台开发知识总结（二）数据库C++后台开发知识总结（三）计算机网络C++后台开发知识总结（四）操作系统/Linux 内核 数据库索引索引是存储引擎快速找到记录的一种数据结构。添加索引原则：在查询中很少使用或者参考的列不应该创建索引。","text":"相关：C++后台开发知识总结（一）C++基础C++后台开发知识总结（二）数据库C++后台开发知识总结（三）计算机网络C++后台开发知识总结（四）操作系统/Linux 内核 数据库索引索引是存储引擎快速找到记录的一种数据结构。添加索引原则：在查询中很少使用或者参考的列不应该创建索引。 只有很少数据值的列也不应该增加索引。定义为text、image和bit数据类型的列不应该增加索引。当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。 目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构B-TreeB-Tree是一种平衡的多路查找(又称排序)树，在文件系统中和数据库系统中有所应用。主要用作文件的索引。其中的B就表示平衡(Balance) 。定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：1.d&gt;=2，即B-Tree的度；2.h为B-Tree的高；3.每个非叶子结点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d；4.每个叶子结点至少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶结点的指针均为NULL；5.所有叶结点都在同一层，深度等于树高h；6.key和指针相互间隔，结点两端是指针；7.一个结点中的key从左至右非递减排列；8.如果某个指针在结点node最左边且不为null，则其指向结点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。9.如果某个指针在结点node最右边且不为null，则其指向结点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。10.如果某个指针在结点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向结点的所有key小于v(keyi+1)且大于v(keyi)。一个d=2的B-Tree示意图: B-Tree是一个非常有效率的索引数据结构。这主要得益于B-Tree的度可以非常大，高度会变的非常小，只需要二分几次就可以找到数据。例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2))，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。B+Tree的特性区别于B-Tree:每个节点的指针上限为2d而不是2d+1内节点不存储data，只存储key；叶子节点不存储指针带有顺序访问指针的B+Tree 数据库添加索引1.普通索引：仅加速查询 最基本的索引，没有任何限制，是大多数情况下使用到的索引。CREATE INDEX index_name on user_info(name) #创建表的时候同时创建索引： 1234567create table healerjean ( id bigint(20) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT '主键', name VARCHAR(32) NOT NULL COMMENT '姓名', email VARCHAR(64) NOT NULL COMMENT '邮箱', message text DEFAULT NULL COMMENT '个人信息', INDEX index_name (name) COMMENT '索引name') COMMENT = '索引测试表'; #在存在的表上创建索引 1create index index_name on healerjean(name) #对于创建索引时如果是blob 和 text 类型，必须指定length。 12create index ix_extra on in1(message(200));alter table employee add index emp_name (name); 2.唯一索引：与普通索引类型不同的是：加速查询 + 列值唯一（可以有null）CREATE UNIQUE INDEX mail on user_info(name)3.全文索引：全文索引（FULLTEXT）仅可以适用于MyISAM引擎的数据表；作用于CHAR、VARCHAR、TEXT数据类型的列。4.组合索引：将几个列作为一条索引进行检索，使用最左匹配原则。create index ind_sales2_companyid_moneys on sales2(company_id,moneys) 想要查看表有几个字段设置了索引, show index from healerjean MySQL索引实现MyISAM索引实现MyISAM引擎使用B+Tree作为索引结构，叶结点的data域存放的是数据记录的地址。 MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。MyISAM的索引方式也叫做“非聚集”的。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。 InnoDB索引实现InnoDB的数据文件本身就是索引文件。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。 叶结点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。 数据库事务：底层如何实现事务数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。一个数据库事务通常包含了一个序列的对数据库的读/写操作。作用：1.为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。2.当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。当事务被提交给了DBMS（数据库管理系统），则DBMS（数据库管理系统）需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态;同时，该事务对数据库或者其他事务的执行无影响。一个逻辑工作单元要成为事务，必须满足ACID（原子性、一致性、隔离性和持久性） 属性。原子性（Atomicity）：事务作为一个整体被执行，事物的所有操作要不成功，要不失败回滚而回滚可以通过日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。一致性（Consistency）：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中。 数据库事务隔离同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 MySQL 4 种隔离级别未提交读READ UNCOMMITTED：一个事务在提交之前，对其他事务是可见的，即事务可以读取未提交的数据。存在“脏读”（读到了脏数据）问题；提交读READ COMMITTED：事务在提交之前，对其它事务是不可见的。存在“不可重复读”（两次查询的得到的结果可能不同，即可能在查询的间隙，有事务提交了修改）问题。解决了“脏读”问题。可重复读REPEATABLE READ：在同一事务中多次读取的数据是一致的。解决了脏读和不可重复读问题，存在“幻读”（在事务两次查询间隙，有其他事务又插入或删除了新的记录）。— MySQL默认隔离级别。 可串行化SERIALIZABLE：强制事务串行化执行。即一个事物一个事物挨个来执行，可以解决上述所有问题。 mysql的MVCC机制MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。 SQL优化在经常性的检索列上，建立必要索引，以加快搜索速率，避免全表扫描（索引覆盖扫描）；多次查询同样的数据，可以考虑缓存该组数据；审视select * form tables, 你需要所有列数据吗？切分查询（大查询切分成为小查询，避免一次性锁住大量数据）分解关联查询（单表查询，结果在应用程序中进行关联，可以减少处理过程中的锁争用）尽量先做单表查询； inner join和left joinleft join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录inner join(等值连接) 只返回两个表中联结字段相等的行 表A、 B记录如下：| aID | aNum | |bID | ||–|–|-|–|–|| 1 | a20050111 | | 1| 2006032401|| 2 | a20050112|| 2|2006032402 || 3 | a20050113 || 3|2006032403 || 4 | a20050114|| 4| 2006032404|| 5 | a20050115| |8 | 2006032408|sql语句如下: 123select * from Aleft join B on A.aID = B.bID 结果如下:| aID | aNum | |bID | ||–|–|-|–|–|| 1 | a20050111 | | 1| 2006032401|| 2 | a20050112|| 2|2006032402 || 3 | a20050113 || 3|2006032403 || 4 | a20050114|| 4| 2006032404|| 5 | a20050115| |NULL | NULL| 数据库引擎innoDB与MyISAM数据库引擎是用于存储、处理和保护数据的核心服务。在Mysql数据库中，常用的引擎为innoDB和MyISAM（MySQL5.6版本开始Innodb已经成为Mysql的默认引擎，之前是MyISAM）。 数据库引擎 innoDB与MyIASM区别：1.InnoDB支持事务，支持外键，MyISAM都不支持;2.InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的; 行数保存： InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快； Innodb不支持全文索引，MyISAM支持全文索引，查询效率上MyISAM要高于Innodb； 如何选择存储引擎如果在应用中执行大量select(查询)操作，应该选MyIASM，如果在应用中执行大量的insert（插入）和update（更新）操作，应该选择innoDB如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个好的选择 #查看数据库支持的存储引擎show engines #查看数据库当前使用的存储引擎,就是默认引擎是什么。show variables like &#39;storage_engine&#39;也可以在MySQL配置文件中查看。windows - my.ini Linux - my.cnf #查看数据库表所用的存储引擎show create table table_name #创建表指定存储引擎create table table_name (column_name column_type) engine = engine_name #修改表的存储引擎alter table table_name engine=engine_name #修改默认的存储引擎在MySQL配置文件中修改下述内容：default-storage-engine=INNODBMySQL的端口号是多少，如何修改这个端口号查看端口号:登录mysql: mysql -u root –p查看端口号: show global variables like &#39;port&#39;mysql的默认端口是3306。（补充：sqlserver默认端口号为：1433；oracle默认端口号为：1521；DB2默认端口号为：5000；PostgreSQL默认端口号为：5432）修改端口号：编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。重启mysql。 存储过程存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。目的：把处理封装，简化复杂的操作；所有开发人员和应用程序都使用同一存储过程，防止错误保证了数据的一致性；简化对变动的管理，只需要更改存储过程的代码。 #创建存储过程 1234create procedure porcedureName () begin select name from user; end; #调用存储过程： 1call procedureName (); #删除存储过程 1DROP PROCEDURE IF EXISTS porcedureName; #含参数 123456789create procedure getTotalById ( in userId int, out total decimal(8,2) ) BEGIN select SUM(r.price) from order r where r.u_id = userId into total; END; 调用 12call getTotalById(1, @total); select @total; 数据库的第一二三范式第一范式（1NF）数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。通俗讲就是：一个字段只存储一项信息。第二范式如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式（属性完全依赖于每一个主键）。满足第一范式前提，当一个主键由多个属性共同组成时，才会发生不符合第二范式的情况。比如有两个属性的主键，不能存在这样的属性，它只依赖于主键中的一个属性，这就是不符合第二范式 。非主键列是否完全依赖于主键，还是依赖于主键的一部分？第三范式定义：第三范式（属性不能传递依赖于主属性）。满足第二范式前提，如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。非主键列是直接依赖于主键，还是直接依赖于非主键列？ delete、truncate、drop的区别及应用场所1、delete属于DML（数据库操作语言），DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作，truncate、drop属于DDL（数据库定义语言），不能回滚2、在速度上，一般来说，drop&gt; truncate &gt; delete3、TRUNCATE 和DELETE只删除数据， DROP则删除整个表（结构和数据）4、Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。实例：删除学生表1、当你不再需要该表时， 用 drop;2、当你仍要保留该表，但要删除所有记录时， 用 truncate;3、当你要删除部分记录时， 用 delete。drop table table_name : 删除表全部数据和表结构，立刻释放磁盘空间，不管是 Innodb 和 MyISAM;truncate table table_name : 删除表全部数据，保留表结构，立刻释放磁盘空间 ，不管是 Innodb 和 MyISAM;delete from table_name :删除表全部数据，表结构不变，对于 MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间;delete from table_name where xxx : 带条件的删除，表结构不变，不管是 innodb 还是 MyISAM 都不会释放磁盘空间;delete 操作以后，使用 optimize table table_name 会立刻释放磁盘空间，不管是 innodb 还是 myisam; DELETE FROM users WHERE name = ‘Mike’ ORDER BY id DESC LIMIT 6; Redis数据类型Redis通常被称为数据结构服务器Redis支持五种数据类型：1）String: 字符串：整数值、embstr编码的简单动态字符串、简单动态字符串（SDS)2）List: 列表：压缩列表、双端链表3）Hash: 哈希：压缩列表、字典4）Set: 集合：整数集合、字典5）Sorted Set: 有序集合：压缩列表、跳跃表和字典 mongodb和redis的区别内存管理机制上： Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。支持的数据结构上： Redis 支持的数据结构丰富，包括hash、set、list等。MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富 Redis是单线程的，但是为什么这么高效呢?I/O多路复用监听多个套接字完全基于内存，内存操作快速单进程单线程不用考虑切换/锁的问题 单进程多线程模型：MySQL、Memcached、Oracle（win）多进程模型：Oracle（Linux） Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?因为redis是单线程，当K很多时，如果一次性将键值对全部rehash，庞大的计算量会影响服务器性能，甚至可能会导致服务器在一段时间内停止服务。不可能一步完成整个rehash操作，所以redis是分多次、渐进式的rehash。渐进性哈希分为两种：1）操作redis时，额外做一步rehash对redis做读取、插入、删除等操作时，会把位于table[dict-&gt;rehashidx]位置的链表移动到新的dictht中，然后把rehashidx做加一操作，移动到后面一个槽位。2）后台定时任务调用rehash后台定时任务rehash调用链，同时可以通过server.hz控制rehash调用频率","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/tags/后台开发/"}]},{"title":"C++后台开发知识总结（一）C++基础","slug":"26","date":"2019-09-26T11:13:52.000Z","updated":"2019-12-18T04:20:53.805Z","comments":true,"path":"2019/09/26/26/","link":"","permalink":"http://yoursite.com/2019/09/26/26/","excerpt":"相关：C++后台开发知识总结（一）C++基础C++后台开发知识总结（二）数据库C++后台开发知识总结（三）计算机网络C++后台开发知识总结（四）操作系统/Linux 内核 extern “C”的作用extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。","text":"相关：C++后台开发知识总结（一）C++基础C++后台开发知识总结（二）数据库C++后台开发知识总结（三）计算机网络C++后台开发知识总结（四）操作系统/Linux 内核 extern “C”的作用extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。 原因是：C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 12345678910#ifndef __INCvxWorksh /*防止该头文件被重复引用*/#define __INCvxWorksh#ifdef __cplusplus //告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的extern \"C\"&#123;#endif /*…*/#ifdef __cplusplus&#125;#endif#endif /*end of __INCvxWorksh*/ C++和C的区别设计思想上：C++是面向对象的语言，而C是面向过程的结构化编程语言语法上：C++具有封装、继承和多态三种特性C++相比C，增加多许多类型安全的功能，比如强制类型转换C++支持范式编程，比如模板类、函数模板等 C/C++ const关键字（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；可以阻止用户修改返回值。返回值也要相应的付给一个常量或常指针。（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量。 C/C++ static关键字1.全局静态变量在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.静态存储区，在整个程序运行期间一直存在。初始化：未经初始化的全局静态变量会被自动初始化为0作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。2.局部静态变量在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。内存中的位置：静态存储区初始化：未经初始化的全局静态变量会被自动初始化为0作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变； 1234int fun()&#123; static int count = 10; //在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1 return count--; //以后每次进入该函数，a就不会被再次初始化了，仅进行自减1的操作 &#125; 3.静态函数在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突； warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；4.类的静态成员及静态成员函数对象与对象之间的成员变量是相互独立的。要想共用数据，则需要使用静态成员和静态方法。只要在类中声明静态成员变量，即使不定义对象，也可以为静态成员变量分配空间，进而可以使用静态成员变量。静态成员变量是在程序编译时分配空间，而在程序结束时释放空间。初始化静态成员变量要在类的外面进行。不能用参数初始化表，对静态成员变量进行初始化。 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。可以通过类名/对象名直接访问类的公有静态成员函数 12345678910111213141516171819202122232425class test&#123;private: static int m_value; //定义私有类的静态成员变量 public: static int getValue() //定义类的静态成员函数 &#123; return m_value; &#125;&#125;;int test::m_value = 0; //类的静态成员变量需要在类外分配内存空间 int main()&#123; test t1; test t2; test t3; //通过类名直接调用公有静态成员函数，获取对象个数 cout &lt;&lt; \"test::m_value2 = \" &lt;&lt; test::getValue() &lt;&lt; endl; //通过对象名调用静态成员函数获取对象个数 cout &lt;&lt; \"t3.getValue() = \" &lt;&lt; t3.getValue() &lt;&lt; endl; system(\"pause\");&#125; C/C++ volatile关键字volatile是“易变的”、“不稳定”的意思。volatile是C的一个较为少用的关键字，它用来解决变量在“共享”环境下容易出现读取错误的问题变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确的处理，凡是申明为volatile的变量，每次都是从内存中读取变量的值，而不是在某些情况下直接从寄存器中取值。（有可能被其他的程序（如中断程序、另外的线程等）所修改） 应用场景：（1）并行设备的硬件寄存器（如状态寄存器）反复读操作，编译器在优化后，也许读操作只做了一次（2）一个中断服务子程序中访问到的变量（3）多线程应用中被多个任务共享的变量当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入CPU寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。 （1）一个参数既可以是const还可以是volatile吗？为什么？是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。（2）一个指针可以是volatile吗？为什么？是的。尽管这并不很常见。一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时（3）下面的函数有什么错误？ 1234567891011int square(volatile int *ptr) &#123; return *ptr * *ptr; &#125;//正确的代码如下：long square(volatile int *ptr) &#123; int a; a = *ptr; return a * a; &#125; volatile能够避免编译器优化带来的错误，但使用volatile的同时，也需要注意频繁地使用volatile很可能会增加代码尺寸和降低性能，因此要合理的使用volatile。 C/C++ restrict关键字12const int a=10;int * b=&amp;a; //警告：初始化丢弃了指针目标类型的限定 b失去了对目标对象的const的限定，并且可以通过指针b更改它们共同指向的空间。const是无法保证某个对象不被更改的，restrict关键字是修饰指针的，对该指针指向的空间的访问，只能从这个指针进入。 什么是右值引用，跟左值又有什么区别？主要目的有两个方面：1.消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。2.能够更简洁明确地定义泛型函数。左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。 右值引用和左值引用的区别：（1）左值可以寻址，而右值不可以。（2）左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。（3）左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。 1int i = getVar(); 从getVar()函数获取一个整形值，然而，这行代码会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。 1int i = 0; i 是左值，0 是字面量，就是右值。在上面的代码中，i 可以被引用，0 就不可以了。 1int&amp;&amp; k = getVar(); 对右值的引用就是右值引用，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。 C++11有哪些新特性1.auto关键字编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导2.nullptr关键字nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。3.智能指针C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。4.初始化列表使用初始化列表来对类进行初始化 1234567891011121314151617181920class Line&#123; public: double getLength( void ); Line(double len); private: double length;&#125;;// 成员函数定义，包括构造函数Line::Line( double len)&#123; cout &lt;&lt; \"Object is being created, length = \" &lt;&lt; len &lt;&lt; endl; length = len;&#125;// 等同于Line::Line( double len): length(len)&#123; cout &lt;&lt; \"Object is being created, length = \" &lt;&lt; len &lt;&lt; endl;&#125; 5.右值引用基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率6.lambdaLambda表达式定义一个匿名函数，并且可以捕获一定范围内的变量[捕获列表] (参数列表) mutable或exception声明 -&gt;返回值类型 {函数体}[捕获列表]，捕获上下文变量以供lambda使用。标识一个Lambda的开始，这部分必须存在，不能省略。(参数列表)，与普通函数的参数列表一致，如果不需要传递参数，则可以连通括号一起省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。mutable是修饰符，默认情况下lambda函数总是一个const函数，Mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略。-&gt;返回值类型, 当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。{函数体}，内容与普通函数一样，除了可以使用参数之外，还可以使用所捕获的变量。Lambda表达式与普通函数最大的区别就是其可以通过捕获列表访问一些上下文中的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051vector&lt;int&gt; vctTemp;vctTemp.push_back(1);vctTemp.push_back(2);&#123; // 无函数对象参数，输出：1 2 for_each(vctTemp.begin(), vctTemp.end(), [](int v)&#123; cout &lt;&lt; v &lt;&lt; endl; &#125;);&#125;&#123; // 以值方式传递作用域内所有可见的局部变量（包括this），输出：11 12 int a = 10; for_each(vctTemp.begin(), vctTemp.end(), [=](int v)&#123; cout &lt;&lt; v+a &lt;&lt; endl; &#125;);&#125;&#123; // 以引用方式传递作用域内所有可见的局部变量（包括this），输出：11 13 12 int a = 10; for_each(vctTemp.begin(), vctTemp.end(), [&amp;](int v)mutable&#123; cout &lt;&lt; v+a &lt;&lt; endl; a++; &#125;); cout &lt;&lt; a &lt;&lt; endl;&#125;&#123; // 以值方式传递局部变量a，输出：11 13 10 int a = 10; for_each(vctTemp.begin(), vctTemp.end(), [a](int v)mutable&#123; cout &lt;&lt; v+a &lt;&lt; endl; a++; &#125;); cout &lt;&lt; a &lt;&lt; endl;&#125;&#123; // 以引用方式传递局部变量a，输出：11 13 12 int a = 10; for_each(vctTemp.begin(), vctTemp.end(), [&amp;a](int v)&#123; cout &lt;&lt; v+a &lt;&lt; endl; a++; &#125;); cout &lt;&lt; a &lt;&lt; endl;&#125;&#123; // 传递this，输出：21 22 for_each(vctTemp.begin(), vctTemp.end(), [this](int v)&#123; cout &lt;&lt; v+m_nData &lt;&lt; endl; &#125;);&#125;&#123; // 除b按引用传递外，其他均按值传递，输出：11 12 17 int a = 10; int b = 15; for_each(vctTemp.begin(), vctTemp.end(), [=, &amp;b](int v)&#123; cout &lt;&lt; v+a &lt;&lt; endl; b++; &#125;); cout &lt;&lt; b &lt;&lt; endl;&#125;&#123; // 操作符重载函数参数按引用传递，输出：2 3 for_each(vctTemp.begin(), vctTemp.end(), [](int &amp;v)&#123; v++; &#125;); for_each(vctTemp.begin(), vctTemp.end(), [](int v)&#123; cout &lt;&lt; v &lt;&lt; endl; &#125;);&#125;&#123; // 空的Lambda表达式 []()&#123;&#125;(); []&#123;&#125;();&#125; 7.可变参数模板C++11的可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为：在class或typename后面带上省略号。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。 1234567891011121314151617181920//递归终止函数template&lt;typename T&gt;void myprint(T end)//递归到最后一次，调用单参数函数&#123; cout &lt;&lt; \"parameter \" &lt;&lt; end &lt;&lt; endl;&#125;//展开函数template&lt;typename T, class ...Args&gt;void myprint(T head, Args... rest)&#123; cout &lt;&lt; \"parameter \" &lt;&lt; head &lt;&lt; endl; myprint(rest...);&#125;int main()&#123; myprint(1, 2, 3, 4); return 0;&#125; 8.atomic原子操作用于多线程资源互斥操作9.新增STL容器array以及tuple C++智能指针智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。 C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。#include&lt;memory&gt;1.unique_ptr（替换auto_ptr）保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。 123unique_ptr&lt;string&gt; p3 (new string (\"auto\")); //#4unique_ptr&lt;string&gt; p4； //#5p4 = p3;//此时会报错！！ 编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如： 12345unique_ptr&lt;string&gt; pu1(new string (\"hello world\"));unique_ptr&lt;string&gt; pu2;pu2 = pu1; // #1 not allowedunique_ptr&lt;string&gt; pu3;pu3 = unique_ptr&lt;string&gt;(new string (\"You\")); // #2 allowed 其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，能够将一个unique_ptr赋给另一个。 shared_ptr多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。成员函数： use_count 返回引用计数的个数unique 返回是否是独占所有权( use_count 为 1)swap 交换两个 shared_ptr 对象(即交换所拥有的对象)reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr sp(new int(1)); sp 与 sp.get()是等价的 weak_ptrweak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr.weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。12345678910111213141516171819202122232425262728293031class B;class A&#123; public: shared_ptr&lt;B&gt; pb_; ~A()&#123; cout&lt;&lt;\"A delete\\n\"; &#125;&#125;;class B&#123; public: shared_ptr&lt;A&gt; pa_; ~B()&#123; cout&lt;&lt;\"B delete\\n\"; &#125;&#125;;void fun()&#123; shared_ptr&lt;B&gt; pb(new B()); shared_ptr&lt;A&gt; pa(new A()); pb-&gt;pa_ = pa; pa-&gt;pb_ = pb; cout&lt;&lt;pb.use_count()&lt;&lt;endl; //2 cout&lt;&lt;pa.use_count()&lt;&lt;endl; //2&#125;int main()&#123; fun(); return 0;&#125; 可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下 ，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); 因为pb_是一个weak_ptr，应该先把它转化为shared_ptr,如： 12shared_ptr p = pa-&gt;pb_.lock();p-&gt;print(); 隐式类型转换隐式转换指的是不需要用户干预，编译器私下进行的类型转换行为。首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换。如： int 到 double 123456789101112131415//混合类型的算术运算表达式中int a = 3;double b = 4.5;double c = a + b; // a 将被自动转换为 double 类型，再加法。//不同类型的赋值操作中//int a = true; // bool 类型转换为 int 类型int *ptr = null; // null 被转换为 int * 类型//函数参数传值void func(double a) &#123;&#125;;func(1); // 1 被隐式的转换为 double 类型1.0//函数返回值double add(int a, int b)&#123; return a + b; // 运算的结果会被隐式的转换为 double 类型再返回&#125; 其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。 1234BOOK A(\"A-A-A\");BOOK B(\"B-B-B\");cout&lt;&lt;A.isSameISBN(B)&lt;&lt;endl; //正经地进行比较，无需发生转换cout&lt;&lt;A.isSameISBN(string(\"A-A-A\"))&lt;&lt;endl; //此处即发生一个隐式转换：string类型--&gt;BOOK类型，借助BOOK的构造函数进行转换，以满足isSameISBN函数的参数期待。 禁止隐式转换：explicit，该关键字只能用来修饰类内部的构造函数； 1explicit BOOK(string ISBN,float price=0.0f):_bookISBN(ISBN),_price(price)&#123;&#125; C++四种类型转换C风格的强制类型转换很简单，均用 Type b = (Type)a 形式转换。C++风格的类型转换提供了4种类型转换操作符来应对不同场合的应用1、const_cast 去掉类型的const或volatile属性去掉类型的const或volatile属性 12345678struct T &#123; int i;&#125;;const T a;//a.i = 10; //直接修改const类型，编译错误T &amp;b = const_cast&lt;T&amp;&gt;(a);b.i = 10; 2、static_cast 无条件转换，静态类型转换基类和子类之间的转换：其中子类指针转换为父类指针是安全的，但父类指针转换为子类指针是不安全的（基类和子类之间的动态类型转换建议用dynamic_cast）。基本数据类型转换，enum，struct，int，char，float等。static_cast不能进行无关类型（如非基类和子类）指针之间的转换。把任何类型的表达式转换成void类型。3、dynamic_cast 有条件转换，动态类型转换，运行时检查类型安全更多使用static_cast，dynamic本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常4、reinterpret_cast 仅重新解释类型，但没有进行二进制的转换可以用于任意类型的指针之间的转换，对转换的结果不做任何保证为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 C++源文件从文本到可执行文件经历的过程对于C++源文件，从文本到可执行文件一般需要四个过程：预处理阶段：主要处理源代码文件中的以“#”开头的预编译指令。对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件 静态链接和动态链接1、静态链接：函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。 2、动态链接：动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。 include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。对于使用双引号包含的头文件，查找头文件路径的顺序为：当前头文件目录 -&gt; 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径 -&gt; 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径对于使用尖括号包含的头文件，查找头文件的路径顺序为：编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）-&gt; 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径 什么时候会发生段错误段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：使用野指针(指向一个不存在的对象或者未申请访问受限内存区域的指针)试图修改字符串常量的内容 C++ 模板模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector &lt;int&gt; 或 vector &lt;string&gt;函数模板 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; template &lt;typename T&gt;inline T const&amp; Max (T const&amp; a, T const&amp; b) &#123; return a &lt; b ? b:a; &#125; int main ()&#123; int i = 39; int j = 20; cout &lt;&lt; \"Max(i, j): \" &lt;&lt; Max(i, j) &lt;&lt; endl; //Max(i, j): 39 double f1 = 13.5; double f2 = 20.7; cout &lt;&lt; \"Max(f1, f2): \" &lt;&lt; Max(f1, f2) &lt;&lt; endl; //Max(f1, f2): 20.7 string s1 = \"Hello\"; string s2 = \"World\"; cout &lt;&lt; \"Max(s1, s2): \" &lt;&lt; Max(s1, s2) &lt;&lt; endl; //Max(s1, s2): World return 0;&#125; 类模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;stdexcept&gt; using namespace std; template &lt;class T&gt;class Stack &#123; private: vector&lt;T&gt; elems; // 元素 public: void push(T const&amp;); // 入栈 void pop(); // 出栈 T top() const; // 返回栈顶元素 bool empty() const&#123; // 如果为空则返回真 return elems.empty(); &#125; &#125;; template &lt;class T&gt;void Stack&lt;T&gt;::push (T const&amp; elem) &#123; // 追加传入元素的副本 elems.push_back(elem); &#125; template &lt;class T&gt;void Stack&lt;T&gt;::pop () &#123; if (elems.empty()) &#123; throw out_of_range(\"Stack&lt;&gt;::pop(): empty stack\"); &#125; // 删除最后一个元素 elems.pop_back(); &#125; template &lt;class T&gt;T Stack&lt;T&gt;::top () const &#123; if (elems.empty()) &#123; throw out_of_range(\"Stack&lt;&gt;::top(): empty stack\"); &#125; // 返回最后一个元素的副本 return elems.back(); &#125; int main() &#123; try &#123; Stack&lt;int&gt; intStack; // int 类型的栈 Stack&lt;string&gt; stringStack; // string 类型的栈 // 操作 int 类型的栈 intStack.push(7); cout &lt;&lt; intStack.top() &lt;&lt;endl; //7 // 操作 string 类型的栈 stringStack.push(\"hello\"); cout &lt;&lt; stringStack.top() &lt;&lt; std::endl; //hello stringStack.pop(); stringStack.pop(); Exception: Stack&lt;&gt;::pop(): empty stack &#125; catch (exception const&amp; ex) &#123; cerr &lt;&lt; \"Exception: \" &lt;&lt; ex.what() &lt;&lt;endl; return -1; &#125; &#125; C++ string实现原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;assert.h&gt;using namespace std; class String&#123; public: String(const char *str = NULL); // 普通构造函数 String(const String &amp;other); // 拷贝构造函数 ~ String(void); // 析构函数 String &amp; operator =(const String &amp;other); // 赋值函数 private: char *m_data; // 用于保存字符串 &#125;; //普通构造函数String::String(const char *str) &#123; if(str==NULL) &#123; m_data = new char[1]; // 得分点：对空字符串自动申请存放结束标志'\\0'的空 //加分点：对m_data加NULL 判断 *m_data = '\\0'; &#125; else &#123; int length = strlen(str); m_data = new char[length+1]; strcpy(m_data, str); &#125;&#125;// String的析构函数String::~String(void) &#123; delete [] m_data; // 或delete m_data;&#125;//拷贝构造函数String::String(const String &amp;other) // 得分点：输入参数为const型&#123; int length = strlen(other.m_data); m_data = new char[length+1]; strcpy(m_data, other.m_data); &#125;//赋值函数String &amp; String::operator =(const String &amp;other) // 得分点：输入参数为const型&#123; if(this == &amp;other) //得分点：检查自赋值 return *this; delete [] m_data; //得分点：释放原有的内存资源 int length = strlen( other.m_data ); m_data = new char[length+1]; strcpy( m_data, other.m_data ); return *this; //得分点：返回本对象的引用&#125; int main(char argc, char *argv)&#123; String s1; String s2(\"222\"); s1 = s2; return 0;&#125; C++ map、set实现原理:红黑树1、红黑树：红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡。红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。性质：(1)每个节点非红即黑(2)根节点是黑的;(3)每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;(4)如果一个节点是红色的，则它的子节点必须是黑色的。(5)对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点; 2、平衡二叉树（AVL树）：红黑树是在AVL树的基础上提出来的。平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差不超过1。 3、红黑树较AVL树的优点：AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。 所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括set、map底层实现都是使用的红黑树。4、红黑树旋转：旋转：红黑树的旋转是一种能保持二叉搜索树性质的搜索树局部操作。有左旋和右旋两种旋转，通过改变树中某些结点的颜色以及指针结构来保持对红黑树进行插入和删除操作后的红黑性质。左旋：对某个结点x做左旋操作时，假设其右孩子为y：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的左孩子，y的左孩子成为x的右孩子。 右旋：对某个结点x做右旋操作时，假设其左孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的右孩子，y的右孩子成为x的左孩子。 哈夫曼编码JPEG中就应用了哈夫曼编码。哈夫曼编码是哈夫曼树的一种应用，广泛用于数据文件压缩。哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的带权路径长度记为WPL= (W1L1 + W2L2 + W3L3 + … + WnLn)，N个权值Wi(i=1,2,…n)构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li(i=1,2,…n)。可以证明哈夫曼树的WPL是最小的。哈夫曼编码步骤：一、对给定的n个权值{W1,W2,W3,…,Wi,…,Wn}构成n棵二叉树的初始集合F= {T1,T2,T3,…,Ti,…,Tn}，其中每棵二叉树Ti中只有一个权值为Wi的根结点，它的左右子树均为空。（为方便在计算机上实现算 法，一般还要求以Ti的权值Wi的升序排列。）二、在F中选取两棵根结点权值最小的树作为新构造的二叉树的左右子树，新二叉树的根结点的权值为其左右子树的根结点的权值之和。三、从F中删除这两棵树，并把这棵新的二叉树同样以升序排列加入到集合F中。四、重复二和三两步，直到集合F中只有一棵二叉树为止。哈夫曼编码是一种无前缀编码。解码时不会混淆。其主要应用在数据压缩，加密解密等场合。a b c d e :5 4 3 2 1 vector、list、deque、set、map的应用场景1、set和map共同点：都是C++的关联容器,只是通过它提供的接口对里面的元素进行访问，底层都是采用红黑树实现不同点：set：用来判断某一个元素是不是在一个组里面，使用的比较少；map：映射，相当于字典，把一个值映射成另一个值，可以创建字典优点：查找某一个数的时间为O(logn)；遍历时采用iterator，效果不错缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响2、vector是动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放；如果新值大于当前大小时才会重新分配内存。特点：拥有一段连续的内存空间，并且起始地址不变，因此能够非常好的支持随机存取，即[]操作符；对头部和中间进行添加删除元素操作需要移动内存，如果元素是结构或类，那么移动的同时还会进行构造和析构操作，所以性能不高；对任何元素的访问时间都是O(1)，所以常用来保存需要经常进行随机访问的内容，并且不需要经常对中间元素进行添加删除操作3、list双向链表，元素也存放在堆中，每个元素都是放在一块内存中，他的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供[]操作符的重载。但是由于链表的特点，它可以很有效率的支持任意地方的删除和插入操作。特点在哪里添加删除元素性能都很高，不需要移动内存，当然也不需要对每个元素都进行构造与析构了，所以常用来做随机插入和删除操作容器；访问开始和最后两个元素最快，其他元素的访问时间都是O(n)4、deque分段连续线性空间，支持[]操作符，也就是支持随机存取，有比较高的随机存取速度，由于deque需要处理内部跳转，因此速度上没有vector快 deque vector 组织方式 按页或块来分配存储器的，每页包含固定数目的元素 分配一段连续的内存来存储内容 效率 即使在容器的前端也可以提供常数时间的insert和erase操作，而且在体积增长方面也比vector更具有效率 只是在序列的尾端插入元素时才有效率，但是随机访问速度要比deque快 总结vector list deque| |vector|list|deque||–|–|–|–||特点|快速的随机存取，快速的在最后插入删除元素|可以快速的在任意位置添加删除元素，只能快速的访问最开始和最后面的元素|在开始和最后添加删除元素一样快，并且提供了随机访问的方法||适用|需要高效的随机存取，不在于插入删除的效率|需要大量的插入和删除操作，不关心随机存取|需要随机存取，也需要高效的在两端进行插入删除操作 vector和list的区别1）vector底层实现是数组；list是双向链表。2）vector是顺序内存,支持随机访问，list不行。4）vector在中间节点进行插入删除会导致内存拷贝，list不会。5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。 vector、list、map、set迭代器失效1.对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器； iter =cont.erase(iter)2.对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可；erase(iter++)3.对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。| |vector|deque|list|set、map||–|–|–|–|–||内部数据结构|数组(一段连续内存空间)|数组(多段连续内存空间)|双向环状链表|红黑树||插入操作|插入后元素总数不大于capacity，插入位置之后的迭代器会失效；大于capacity,所有迭代器都会失效|两端插入, 不会引起迭代器失效；中间插入, 所有迭代器失效|不会出现迭代器失效|不会出现迭代器失效||删除操作|删除位置之后的迭代器都会失效,但是erase会返回下一个有效的迭代器|两端删除, 被删除元素的迭代器失效中间删除, 所有迭代器失效|被删除节点的迭代器失效|被删除节点的迭代器失效|解决方法| iter =cont.erase(iter)| |iter =cont.erase(iter)或者m.erase(iter++)|m.erase(iter++) 解决方式1： iter =cont.erase(iter) 1234567891011121314151617181920//要求只是删除值为偶数的节点 , vector&lt;int&gt; vec&#123; 1, 2, 3, 4, 5 &#125;; vector&lt;int&gt; ::iterator it1 = vec.begin(); //错误实现：链表删除节点导致的迭代器失效，容易造成访问野指针的问题，导致程序崩溃 while (it1 != vec.end()) &#123; if (*it1 % 2 == 0)&#123; vec.erase(it1); &#125; it1++; &#125; //正确实现：利用erase()函数的返回值为iterator，返回的是删除节点的下一个位置的迭代器 while (it1 != vec.end()) &#123; if (*it1 % 2 == 0)&#123; it1 = vec.erase(it1); //重点！！！ &#125; else&#123; it1++; &#125; &#125; 解决方式2：erase(iter++) 1234567891011121314151617181920//要求删除键值为偶数的键值对map&lt;int, int&gt;::iterator it = m.begin();//错误实现：while (it != m.end())&#123; if(it-&gt;second % 2 == 0)&#123; m.erase(it); &#125; it++;&#125;//正确实现：while (it != m.end())&#123; if(it-&gt;second % 2 == 0)&#123; m.erase(it++); //重点！！！ &#125; else&#123; it++; &#125;&#125; C++内存分配管理 在C++中，虚拟内存分为text代码段、data数据段、bss段、heap堆区、文件映射区以及stack栈区六部分。3G用户空间和1G内核空间代码段 包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。数据段 存储程序中已初始化的全局变量和静态变量bss 段 存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。堆区 调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。映射区 存储动态链接库以及调用mmap函数进行的文件映射栈 使用栈空间存储函数的返回地址、参数、局部变量、返回值 内存分配方式有三种：[1]从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。[2]在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。[3]从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。 A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节的空间（0x000m），分配给指针a。2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。3）a = new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。4）a-&gt;i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。 给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布1、static修饰符1）static修饰成员变量无论类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。2）static修饰成员函数与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。Static修饰的成员函数，在代码区分配内存。 2、C++继承和虚函数C++多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。动态多态实现有几个条件：(1) 虚函数；(2) 一个基类的指针或引用指向派生类的对象；基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。 3、virtual修饰符如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。 如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。如果类中成员是virtual属性，会隐藏父类对应的属性。 静态变量什么时候初始化静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造 STL的allocatorSTL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容delete运算分两个阶段：(1)调用对象析构函数；(2)掉用::operator delete释放内存 为了精密分工，STL allocator将两个阶段操作区分开来：内存配置由alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。 同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器，使用malloc()、realloc()、free()函数进行内存空间的分配和释放；当分配的空间大小小于128B时，将使用第二级空间配置器，采用了内存池技术，通过空闲链表来管理内存。 malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap(内存映射)在映射区分配。 C++ STL 的内存优化1）二级配置器结构STL内存管理使用二级内存配置器。1、第一级配置器 分配的区块大于128bytes第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。2、第二级配置器 分配的区块小于128bytes在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。内存池管理: 每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块如果内存池空间足够，则取出内存如果不够分配20块，则分配最多的块数给自由链表如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器 2）二级内存池二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。如何分配内存：它的内存分配主要分为以下几种情况：1、对应的free_list不为空所需空间大小提升为8的倍数后(如需要13bytes空间，我们会给它分配16bytes大小)，所对应的free_list不为空时，直接从对应的free_list中拔出，第一位置向后移动指向。2、对应的free_list为空，其内存池不为空时：（1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) *20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接从 free-list 中拨出。（2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。（3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存。3、内存池为空，申请内存此时二级空间配置器会使用malloc()从heap上申请内存。4、malloc没有成功在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从任意一个比它所需节点空间大的free_list中拔除一个节点来使用。5、查找失败，调用一级空间配置器释放内存 用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。 否则按照其大小找到合适的自由链表，并将其插入。 new/delete和 malloc/free的区别1、new/delete是C++关键字支持重载，需要编译器支持。malloc/free是库函数，需要头文件stdlib.h支持。2、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；3、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。4、new不仅分配一段内存，而且会调用构造函数，malloc不会。5、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。6、malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。8、new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆 1234567891011//申请ArraySize大小的数组int* Array = (int*)malloc(ArraySize * sizeof(int)); // 在堆中申请内存memset(Array, 0, ArraySize * sizeof(int)); // 初始化数组全为 0free(Array); // 释放内存int* Array = new int[ArraySize]; // 申请内存，不初始化//int* Array = new int[ArraySize](); // 初始化数组全为 0//int* Array = new int[5]&#123; 1,2,3,4,5 &#125;; // 初始化数组为 1,2,3,4,5（VS2015支持）//int* Array = new int[5]&#123; 1 &#125;; // 初始化数组为 1,0,0,0,0memset(Array, 1, ArraySize * sizeof(int)); // 初始化数组全为 1delete[] Array; // 释放内存 memory leak，内存泄漏内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。可以使用Valgrind, mtrace进行内存泄漏检查。 内存泄漏的分类：1.堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.2.系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。3.没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。 STL有什么基本组成算法、容器、迭代器 STL中map与unordered_map底层实现：map底层是基于红黑树实现的，因此map内部元素排列是有序的。而unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。map ：优点：1)有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作2)map的查找、删除、增加等一系列操作时间复杂度稳定，都为O(logn )缺点：查找、删除、增加等操作平均时间复杂度较慢，与n相关unordered_map：优点：查找、删除、添加的速度快，时间复杂度为常数级O(c )unordered_map 缺点：因为unordered_map内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c )，取决于哈希函数。极端情况下可能为O(n) STL中迭代器的作用，有指针为何还要迭代器Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。迭代器和指针的区别:迭代器不是指针，是类模板，表现的像指针。他模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、- -等，提供了比指针更高级的行为，可以根据不同类型的数据结构来实现不同的++，- -等操作。 STL里resize和reserve的区别resize()：改变当前容器内含有元素的数量(size()) 123vector&lt;int&gt;v&#123;1 ,2&#125;; v.resize(4);v.push_back(5); //1 2 0 0 5 v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1； reserve()：改变当前容器的最大容量（capacity）如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存； 注意：当v.resize(len)中len&gt;v.capacity()，则v中的size和capacity均设置为len； 当v.resize(len) 中len&lt;=v.capacity()，则v中的size设置为len，而capacity不变;如果此时len&lt;v.size(),那么多出的那些对象(v[len], v[len+1]…)会被销毁，v[0]-v[len-1]仍保留在原地；当v.reserve(len)中len&lt;=v.capacity()，则v中的capacity不变，size不变，即不对容器做任何改变。 12345678910vector&lt;int&gt; a;a.reserve(100);a.resize(50);cout&lt;&lt;a.size()&lt;&lt;\" \"&lt;&lt;a.capacity()&lt;&lt;endl; //50 100a.resize(150);cout&lt;&lt;a.size()&lt;&lt;\" \"&lt;&lt;a.capacity()&lt;&lt;endl; //150 150a.reserve(50);cout&lt;&lt;a.size()&lt;&lt;\" \"&lt;&lt;a.capacity()&lt;&lt;endl; //150 150a.resize(50);cout&lt;&lt;a.size()&lt;&lt;\" \"&lt;&lt;a.capacity()&lt;&lt;endl; //50 150 size可能改变capacity，但capacity不会改变size C++函数重载、覆盖、隐藏重载:函数重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中运算符重载：Box operator+(const Box&amp;); //返回类型 Box覆盖/重写:子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写隐藏:派生类的函数屏蔽了与其同名的基类函数。 不能重载的运算符：“.” “.*” “?:” “sizeof()” “typeid()” “static_cast&lt;&gt;” “dynamic_cast&lt;&gt;” “const_cast&lt;&gt;” “#” “##” C++编译时多态与运行时多态多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数。静态多态 123456789101112131415int Add(int left, int right)&#123; return left + right;&#125;double Add(double left, int right)&#123; return left + right;&#125;int main()&#123; Add(10, 20); Add(10.0,20); //正常代码 return 0;&#125; 动态多态 1234567891011121314151617181920class Father&#123;public: virtual void Say()&#123; //重点！！！ cout &lt;&lt; \"Father say hello\" &lt;&lt; endl; &#125;&#125;;class Son:public Father&#123;public: void Say()&#123; cout &lt;&lt; \"Son say hello\" &lt;&lt; endl; &#125;&#125;;void main()&#123; Father *pFather; Son son; pFather = &amp;son; pFather-&gt;Say(); //Son say hello&#125; 虚函数的实现在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。 如何实现只能动态分配类对象，不能静态分配动态分配就是用运算符new来创建一个类的对象，在堆上分配内存。静态分配就是A a;这样来由编译器来创建一个对象，在栈 上分配内存。1、动态分配（在堆上分配内存）将类的构造函数和析构函数设为protected属性，这样类对象不能够访问，但是派生类能够访问，能够正常的继承。同时创建另外两个create和destory函数类创建对象。（将create设为static原因是：创建对象的时候是A *p = A::create(); 只有静态成员函数才能够通过类名来访问。） 123456789101112131415class A &#123; protected: A()&#123;&#125; ~A()&#123;&#125; public: static A* create() &#123; return new A(); &#125; void destory() &#123; delete this; &#125; &#125;; 2、只能静态创建对象只有使用new运算符，对象才会被建立在堆上。因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设为私有，实现如下： 123456789class A &#123; private: void* operator new(size_t t)&#123;&#125; void operator delete(void* ptr)&#123;&#125; public: A()&#123;&#125; ~A()&#123;&#125; &#125;; C++中类成员的访问权限C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。 无论共有继承、私有和保护继承，私有成员不能被“派生类”访问，基类中的共有和保护成员能被“派生类”访问。对于共有继承，只有基类中的共有成员能被“派生类对象”访问，保护和私有成员不能被“派生类对象”访问。对于私有和保护继承，基类中的所有成员不能被“派生类对象”访问。 C++类内可以定义引用数据成员吗？可以，必须通过成员函数初始化列表初始化。 动态链接库与静态链接库的区别1、 静态链接库的后缀名为lib，动态链接库的导入库的后缀名也为lib。不同的是，静态库中包含了函数的实际执行代码，而对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息；2、由于静态库是在编译期间直接将代码合到可执行程序中，而动态库是在执行期时调用DLL中的函数体，所以执行速度比动态库要快一点；3、 静态库链接生成的可执行文件体积较大，且包含相同的公共代码，造成内存浪费；4、 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；5、 DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性，适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。 C++中struct和class的区别在c中，struct不能包含任何函数, 在C++中struct得到了很大的扩充：1.struct可以包括成员函数2.struct可以实现继承3.struct可以实现多态。在C++中struct和class的区别并不是很大，两者之间有很大的相似性。那么为什么还要保留struct,这是因为C++是向下兼容的，因此C++中保留了很多C的东西。区别：1.默认的继承访问权。struct的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。2.另外，class还可以定义模板类形参，比如template &lt;class T, int i&gt;。 C++接口（抽象类）如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类，纯虚函数是通过在声明中使用 “= 0” 来指定的。设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。 123456789101112131415161718class soapBase&#123; public: virtual ~soapBase()&#123;&#125;; virtual void show() = 0;&#125;; class SFJSoap:public soapBase&#123; public: void show() &#123;cout&lt;&lt;\"SFJ Soap!\"&lt;&lt;endl;&#125;&#125;; class XSLSoap:public soapBase&#123; public: void show() &#123;cout&lt;&lt;\"XSL Soap!\"&lt;&lt;endl;&#125;&#125;; 虚函数与纯虚函数区别C++的虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现。子类可以重写父类的虚函数实现子类的特殊化。C++中的纯虚函数更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”。 C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。 构造函数、析构函数构造函数 会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。使用初始化列表来初始化字段 1C::C( double a, double b, double c): X(a), Y(b), Z(c)&#123;....&#125; 析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。 1234567891011121314151617181920212223242526class Line &#123; public: void setLength( double len ); double getLength( void ); Line(); // 这是构造函数声明 ~Line(); // 这是析构函数声明 private: double length;&#125;; // 成员函数定义，包括构造函数Line::Line(void)&#123; cout &lt;&lt; \"Object is being created\" &lt;&lt; endl;&#125;Line::~Line(void) &#123; cout &lt;&lt; \"Object is being deleted\" &lt;&lt; endl;&#125; void Line::setLength( double len ) &#123; length = len;&#125; double Line::getLength( void ) &#123; return length;&#125; 为什么析构函数必须是虚函数？将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。 为什么C++默认的析构函数不是虚函数C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。 静态函数和虚函数的区别静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销 指针和引用的区别12int a=1;int *p=&amp;a;int a=1;int &amp;b=a; 指针是一个变量，存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，是原变量的一个别名。区别：1、指针有自己的一块空间，而引用只是一个别名；2、使用sizeof看一个指针的大小是4（32位），而引用则是被引用对象的大小；3、指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；4、作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；5、可以有const指针，但是没有const引用；6、指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；7、指针可以有多级指针（**p），而引用至于一级；8、指针和引用使用++运算符的意义不一样。 实际上”引用”可以做的任何事情”指针”也都能够做，为什么还要”引用”这东西？答案是 指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。如果的确只需要借用一下某个对象的”别名”，那么就用”引用”，而不要用”指针”，以免发生意外。 数组和指针的区别 指针 数组 保存数据的地址 保存数据 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 直接访问数据 通常用于动态的数据结构 通常用于固定数目且数据类型相同的元素 通过Malloc分配内存，free释放内存 隐式的分配和删除 通常指向匿名数据，操作匿名函数 自身即为数据名 # 函数指针 函数指针是指向函数的指针变量。 函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数 123456789bool LengthCompare(const string &amp;,const string &amp;)//想要声明一个指向改函数的指针，只需要用指针替换函数名即可bool (*pf)(const string&amp;, const string&amp;);//未初始化 pf=LengthCompare;//pf=&amp;LengthCompare;bool b1=pf(\"hello\",\"goodbye\");bool b2=(*pf)(\"hello\",\"goodbye\");bool b3=LengthCompare(\"hello\",\"goodbye\");//三个等价调用 const char *，char *，const char crr[]，char drr[]123456789const char * arr = \"123\";//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改//但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样char * brr = \"123\";//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改\"123\"的值const char crr[] = \"123\";//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区char drr[] = \"123\";//字符串123保存在栈区，可以通过drr去修改 C++里是怎么定义常量的？常量存放在内存的哪个位置？常量在C++里的定义const加上对象类型，常量定义必须初始化。对于局部常量，存放在栈区；对于全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；字面值常量，比如字符串，放在常量区。 sizeofsizeof和new、delete等一样，是关键字，不是函数或者宏sizeof返回内存中分配的字节数，它和操作系统的位数有关。例如在常见的32位系统中，int类型占4个字节；但是在16位系统中，int类型占2个字节。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 在32位系统中不同类型的内存分配// 基本类型sizeof(int); // = 4 sizeof(double); // = 8 sizeof(char); // = 1 sizeof(bool); // = 1 sizeof(short); // = 2 sizeof(float); // = 4 sizeof(long); // = 4 // 指针sizeof(int *); // = 4 sizeof(double *); // = 4 sizeof(char *); // = 4 //函数void fn() &#123; &#125; sizeof(fn); // error：函数 sizeof(fn()); // error：不能确定类型 //sizeof对函数调用求值结果是函数返回值类型的大小，函数并不会被调用int fun() &#123; return 3;&#125; sizeof(fun); // = sizeof(int) = 4// 数组 int ai[] = &#123;1, 2&#125;; //数组的sizeof返回整个数组所占的字节数，即（数组元素个数×每个元素所占字节）。sizeof(ai); // = 2*4 = 8 // 常量字符串与字符数组的内存分配方式相同char ac[] = \"abcd\"; //注意数组末尾的字符串终结符'\\0' sizeof(ac); // = 5*1 = 5 //注意！！！sizeof(\"abcd\"); // = 5*1 = 5 // 数组和指针所占的字节数不同int *pi = new int[10]; //这是指针 sizeof(pi); // = 4 int ai[10]; int *p = ai; //这还是指针 sizeof(p); // = 4 double* (*a)[3][6]; //看成(double *) (*a)[3][6]，即一个3×6的二维数组，数组元素为指针，指向double类型。 sizeof(a); // = 4，a为指向上述二维数组的指针 sizeof(*a); // = sizeof(double *)*3*6 = 72，*a表示上述二维数组 sizeof(**a); // = sizeof(double *)*6 = 24，**a即*(*a)，表示double*[6]，是元素为double指针的一维数组。 sizeof(***a); // = sizeof(double *) = 4，表示上述一维数组中的第一个元素，元素类型为double指针。 sizeof(****a); // = sizeof(double) = 8，表示上述数组首元素指向的double类型。 // 函数形式参数中的数组会蜕变为指针，原因是数组参数“传址调用”void aif(int p[]) //参数类型是int[]，表示指向int的指针 &#123; sizeof( p ); // = 4 &#125; void pif(int (*p)[6]) //参数类型是int (*)[6]，表示指向int数组的指针 &#123; sizeof( p); // = 4 sizeof( *p ); // = sizeof(int)*6 = 24 &#125; void ppf(int *p[6]) //参数类型是int *[]，表示指向int指针的指针 &#123; sizeof( p ); // = 4 sizeof( *p ); // = 4 &#125; // 32位 类和结构体的内存分配// 空类或空结构体占一个字节class CEmpty &#123; &#125;; sizeof(CEmpty); // = 1 struct SEmpty &#123; &#125;; sizeof(SEmpty); // = 1 // 非空类和结构体所占字节为所有成员占字节的和，但是不包括成员函数和静态成员所占的空间class CInt : public CEmpty &#123; int i;&#125;; sizeof(CInt); // = 4; class CFunc &#123; void f()&#123;&#125; &#125;; sizeof(CFunc); // = 1; struct SInt : SEmpty &#123; static int i;&#125;; sizeof(SInt); // = 1; // 字节对齐struct SByte1 &#123; double d; // 长度8，偏移量为0；存放位置区间[0,7] char j; // 长度1，偏移量为8；存放位置区间[8] int a; // 长度4，偏移量12；存放位置区间[12，15] &#125;; sizeof(SByte1); // = 16 struct SByte2 &#123; char j; // 长度1，偏移量为0；存放位置区间[0,1] double d; // 长度8，偏移量8；存放位置区间[8,15] int a; // 长度4，偏移量16；存放位置区间[16,19]&#125;; sizeof(SByte2); // = 24，为了凑成8的倍数，填充20~23 //可以通过#pragma pack(n)来设定变量以n字节对齐方式，n=1,2,4,8,16#pragma pack(push) //保存对齐状态 #pragma pack(4) //设定为4字节对齐 class CByte &#123; char c; //长度1 &lt; 4 按1对齐；偏移量为0；存放位置区间[0,1] double d; //长度8 &gt; 4 按4对齐；偏移量为4；存放位置区间[4,11] int i; //长度4 = 4 按4对齐；偏移量为12；存放位置区间[12,15]&#125;; #pragma pack(pop) //恢复对齐状态 sizeof(CByte); // = 16 // 联合union U &#123; int i; char c; double d; &#125;; sizeof(U); // = Max(sizeof(i), sizeof(c), sizeof(d)) = sizeof(d) = 8 空类的大小是多少，如果是派生类呢为何空类的大小不是0呢？为了确保两个不同对象的地址不同，必须如此。类的实例化是在内存中分配一块地址，每个实例在内存中都有独一无二的二地址。同样，空类也会实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化后就有独一无二的地址了。所以，空类的sizeof为1，而不是0. 12345678class A&#123; virtual void f()&#123;&#125; &#125;; //4 具有虚函数表的地址class B:public A&#123;&#125; //4 具有虚函数的类sizeof都是4class A&#123;&#125;; //1 A是空类，其大小为1class B:public virtual A&#123;&#125;; //4 class Father1&#123;&#125;; class Father2&#123;&#125;; //1 1class Child:Father1, Father2&#123;&#125;; //1 多重继承的空类的大小也是1 何时共享虚函数地址表：如果派生类继承的第一个是基类，且该基类定义了虚函数地址表，则派生类就共享该表首址占用的存储单元。对于除前述情形以外的其他任何情形，派生类在处理完所有基类或虚基类后，根据派生类是否建立了虚函数地址表，确定是否为该表首址分配存储单元。 1234567class X&#123;&#125;; //sizeof(X):1class Y : public virtual X &#123;&#125;; //sizeof(Y):4class Z : public virtual X &#123;&#125;; //sizeof(Z):4class A : public virtual Y &#123;&#125;; //sizeof(A):8class B : public Y, public Z&#123;&#125;; //sizeof(B):8class C : public virtual Y, public virtual Z &#123;&#125;; //sizeof(C):12class D : public virtual C&#123;&#125;; //sizeof(D):16 C语言是怎么进行函数调用的eip是指令指针，即指向下一条即将执行的指令的地址；ebp为基址指针，常用来指向栈底；esp为栈指针，常用来指向栈顶。假设函数A调用函数B，我们称A函数为”调用者”,B函数为“被调用者”则函数调用过程可以这么描述：(1)先将调用者(A)的堆栈的基址(ebp)入栈，以保存之前任务的信息。(2)然后将调用者(A)的栈顶指针(esp)的值赋给ebp，作为新的基址(即被调用者B的栈底)。(3)然后在这个基址(被调用者B的栈底)上开辟(一般用sub指令)相应的空间用作被调用者B的栈空间。…执行 B函数的主体机器指令段…(4)函数B返回后，从当前栈帧的ebp即恢复为调用者A的栈顶(esp)，使栈顶恢复函数B被调用前的位置;然后调用者A再从恢复后的栈顶可弹出之前的ebp值(可以这么做是因为这个值在函数调用前一步被压入堆栈)。这样，ebp和esp就都恢复了调用函数B前的位置，也就是栈恢复函数B调用前的状态。 每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。参数压栈顺序：从右到左 C++如何处理返回值生成一个临时变量，把它的引用作为函数参数传入函数内。C++中拷贝赋值函数的形参能否进行值传递不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。 Hash函数哈希的过程中需要使用哈希函数进行计算。哈希函数是一种映射关系，根据数据的关键词 key ，通过一定的函数关系，计算出该元素存储位置的函数。表示为：address = H [key]几种常见的哈希函数（散列函数）构造方法直接定址法取关键字或关键字的某个线性函数值为散列地址。即 H(key) = key 或 H(key) = akey + b，其中a和b为常数*除留余数法** 取关键字被某个不大于散列表长度 m 的数 p 求余，得到的作为散列地址。即 H(key) = key % p, p &lt; m。数字分析法当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列地址仅适用于所有关键字都已知的情况下，根据实际应用确定要选取的部分，尽量避免发生冲突。平方取中法先计算出关键字值的平方，然后取平方值中间几位作为散列地址。随机分布的关键字，得到的散列地址也是随机分布的。折叠法（叠加法）将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。用于关键字位数较多，并且关键字中每一位上数字分布大致均匀。随机数法选择一个随机函数，把关键字的随机函数值作为它的哈希值。通常当关键字的长度不等时用这种方法。当关键字是整数类型时就可以用除留余数法；如果关键字是小数类型，选择随机数法会比较好。 哈希冲突的解决加载因子：hash表中已经存储的关键字个数，与可以散列位置的比值，表示Hsah表中元素的填满的程度.若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.冲突的机会越大,则查找的成本越高.反之,查找的成本越小.因而,查找时间就越小.选用哈希函数计算哈希值时，可能不同的 key 会得到相同的结果，一个地址怎么存放多个数据呢？这就是冲突。1、开放地址法（前提是散列表的长度大于等于所要存放的元素）发生哈希冲突后，按照某一次序找到下一个空闲的单元，把冲突的元素放入。线性探查法 从发生冲突的单元开始探查，依次查看下一个单元是否为空，如果到了最后一个单元还是空，那么再从表首依次判断。如此执行直到碰到了空闲的单元或者已经探查完所有单元。平方探查法 从发生冲突的单元加上1^2,2^2,3^2,…,n^2，直到遇到空闲的单元双散列函数探查法定义两个散列函数，分别为s1和s2，s1的算法和前面一致，s2取一个1～m-1之间并和m互为素数的数。s2作为步长。更适合于造表前无法确定表长的情况；平均查找长度较短；适合结点规模较大时2、链地址法 将哈希值相同的元素构成一个链表，head放在散列表中。一般链表长度超过了8就转为红黑树，长度少于6个就变为链表。 缺点：指针需要额外的空间3、再哈希法 同时构造多个不同的哈希函数，Hi = RHi(key) i= 1,2,3 … k;当H1 = RH1(key) 发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。缺点：每次冲突都要重新散列，计算时间增加 设计模式（一）：工厂模式工厂模式的两个最重要的功能：定义创建对象的接口，封装了对象的创建；使得具体化类的工作延迟到了子类中。对于工厂模式，为了使其能更好的解决多种情况的问题，将其分为三类：简单工厂模式（Simple Factory），工厂方法模式（Factory Method），抽象工厂模式（Abstract Factory）。简单工厂模式（Simple Factory）简单设计模式存在的目的很简单：定义一个用于创建对象的接口。缺点：对修改不封闭，新增加产品要修改工厂。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;enum PRODUCTTYPE &#123;SFJ,XSL,NAS&#125;;class soapBase&#123; public: virtual ~soapBase()&#123;&#125;; virtual void show() = 0;&#125;; class SFJSoap:public soapBase&#123; public: void show() &#123;cout&lt;&lt;\"SFJ Soap!\"&lt;&lt;endl;&#125;&#125;; class XSLSoap:public soapBase&#123; public: void show() &#123;cout&lt;&lt;\"XSL Soap!\"&lt;&lt;endl;&#125;&#125;; class NASSoap:public soapBase&#123; public: void show() &#123;cout&lt;&lt;\"NAS Soap!\"&lt;&lt;endl;&#125;&#125;; class Factory&#123; public: soapBase * creatSoap(PRODUCTTYPE type) &#123; switch(type) &#123; case SFJ: return new SFJSoap(); break; case XSL: return new XSLSoap(); break; case NAS: return new NASSoap(); break; default:break; &#125; &#125;&#125;; int main()&#123; Factory factory; soapBase* pSoap1 = factory.creatSoap(SFJ); pSoap1-&gt;show(); soapBase* pSoap2 = factory.creatSoap(XSL); pSoap2-&gt;show(); soapBase* pSoap3 = factory.creatSoap(NAS); pSoap3-&gt;show(); delete pSoap1; delete pSoap2; delete pSoap3; return 0;&#125; 工厂模式（Factory Method）工厂方法模式的应用并不是只是为了封装对象的创建，而是要把对象的创建放到子类中实现：Factory中只是提供了对象创建的接口，其实现将放在Factory的子类ConcreteFactory中进行缺点：每增加一种产品，就需要增加一个对象的工厂。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;using namespace std;enum SOAPTYPE &#123;SFJ,XSL,NAS&#125;; class soapBase&#123; public: virtual ~soapBase()&#123;&#125;; virtual void show() = 0;&#125;; class SFJSoap:public soapBase&#123; public: void show() &#123;cout&lt;&lt;\"SFJ Soap!\"&lt;&lt;endl;&#125;&#125;; class XSLSoap:public soapBase&#123; public: void show() &#123;cout&lt;&lt;\"XSL Soap!\"&lt;&lt;endl;&#125;&#125;; class NASSoap:public soapBase&#123; public: void show() &#123;cout&lt;&lt;\"NAS Soap!\"&lt;&lt;endl;&#125;&#125;; class FactoryBase&#123; public: virtual soapBase * creatSoap() = 0;&#125;; class SFJFactory:public FactoryBase&#123; public: soapBase * creatSoap() &#123; return new SFJSoap(); &#125;&#125;; class XSLFactory:public FactoryBase&#123; public: soapBase * creatSoap() &#123; return new XSLSoap(); &#125;&#125;; class NASFactory:public FactoryBase&#123; public: soapBase * creatSoap() &#123; return new NASSoap(); &#125;&#125;; int main()&#123; SFJFactory factory1; soapBase* pSoap1 = factory1.creatSoap(); pSoap1-&gt;show(); XSLFactory factory2; soapBase* pSoap2 = factory2.creatSoap(); pSoap2-&gt;show(); NASFactory factory3; soapBase* pSoap3 = factory3.creatSoap(); pSoap3-&gt;show(); delete pSoap1; delete pSoap2; delete pSoap3; return 0;&#125; 抽象工厂模式（Abstract Factory） 抽象工厂模式：给客户端提供一个接口，可以创建多个产品族中的产品对象 ，而且使用抽象工厂模式还要满足一下条件：1)系统中有多个产品族，而系统一次只可能消费其中一族产品。2)同属于同一个产品族的产品以其使用。 Eg：搞两个厂房，一个生产低档的牙膏和肥皂，一个生产高档的牙膏和肥皂。比如，厂房一生产中华牙膏、娜爱斯肥皂，厂房二生产黑人牙膏和舒肤佳牙膏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;using namespace std;enum SOAPTYPE &#123;SFJ,XSL,NAS&#125;;enum TOOTHTYPE &#123;HR,ZH&#125;; class SoapBase&#123; public: virtual ~SoapBase()&#123;&#125;; virtual void show() = 0;&#125;; class SFJSoap:public SoapBase&#123; public: void show() &#123;cout&lt;&lt;\"SFJ Soap!\"&lt;&lt;endl;&#125;&#125;; class NASSoap:public SoapBase&#123; public: void show() &#123;cout&lt;&lt;\"NAS Soap!\"&lt;&lt;endl;&#125;&#125;; class ToothBase&#123; public: virtual ~ToothBase()&#123;&#125;; virtual void show() = 0;&#125;; class HRTooth:public ToothBase&#123; public: void show() &#123;cout&lt;&lt;\"Hei ren Toothpaste!\"&lt;&lt;endl;&#125;&#125;; class ChinaTooth:public ToothBase&#123; public: void show() &#123;cout&lt;&lt;\"China Toothpaste!\"&lt;&lt;endl;&#125;&#125;; class FactoryBase&#123; public: virtual SoapBase * creatSoap() = 0; virtual ToothBase * creatToothpaste() = 0;&#125;; class FactoryA :public FactoryBase&#123; public: SoapBase * creatSoap() &#123; return new SFJSoap(); &#125; ToothBase * creatToothpaste() &#123; return new HRTooth(); &#125;&#125;; class FactoryB :public FactoryBase&#123; public: SoapBase * creatSoap() &#123; return new NASSoap(); &#125; ToothBase * creatToothpaste() &#123; return new ChinaTooth(); &#125;&#125;; int main()&#123; FactoryA factory1; FactoryB factory2; SoapBase *pSoap1 = NULL; ToothBase *pToothpaste1 = NULL; pSoap1 = factory1.creatSoap(); pToothpaste1 = factory1.creatToothpaste(); pSoap1-&gt;show(); pToothpaste1-&gt;show(); SoapBase *pSoap2 = NULL; ToothBase *pToothpaste2 = NULL; pSoap2 = factory2.creatSoap(); pToothpaste2 = factory2.creatToothpaste(); pSoap2-&gt;show(); pToothpaste2-&gt;show(); delete pSoap1; delete pSoap2; delete pToothpaste1; delete pToothpaste2; return 0;&#125; 设计模式（二）：单例模式单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例的实现主要是通过以下两个步骤：将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。 懒汉：懒汉式的特点是延迟加载，比如配置文件，在第一次用到类实例的时候才会去实例化；懒汉加载，如果并发访问：使用锁机制，防止多次访问,可以这样，第一次判断为空不加锁，若为空，再进行加锁判断是否为空，若为空则生成对象。在访问量较小时，采用懒汉实现。这是以时间换空间。饿汉：饿汉式的特点是一开始就加载了，在单例类定义的时候就进行实例化。由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。 1234567891011121314151617181920212223242526272829303132//懒汉式 第一次用到类的实例的时候才回去实例化class singleton&#123;private: singleton()&#123;&#125; //构造函数私有 static singleton* _instance; public: static singleton* Get_instance() &#123; if(_instance == NULL)&#123; //判断是否第一次调用 Lock(); if(_instance == NULL)&#123; _instance = new singleton(); &#125; UnLock(); &#125; return _instance; &#125;&#125;;//饿汉式 单例类定义的时候就进行实例化class singleton &#123; private: singleton()&#123;&#125; //私有构造函数 public: static singleton* Get_instance() &#123; static singleton _instance; return &amp;_instance; &#125; &#125;; 应用场景：Windows的Task Manager（任务管理器）就是很典型的单例模式，你不能同时打开两个任务管理器。Windows的回收站也是同理。应用程序的日志应用，一般都可以用单例模式实现，只能有一个实例去操作文件。读取配置文件，读取的配置项是公有的，一个地方读取了所有地方都能用，没有必要所有的地方都能读取一遍配置。数据库连接池，多线程的线程池。","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/tags/后台开发/"}]},{"title":"刷题汇总（三）leetcode 精选50题 C++答案总结","slug":"25","date":"2019-09-25T17:49:22.000Z","updated":"2019-12-18T04:20:26.679Z","comments":true,"path":"2019/09/26/25/","link":"","permalink":"http://yoursite.com/2019/09/26/25/","excerpt":"题目来源 腾讯精选练习（50 题） 相关：刷题汇总（一）leetcode 精选50题 JavaScript答案总结刷题汇总（二）剑指Offer 66题 C++答案总结刷题汇总（四）技术类编程题汇总 C++刷题汇总（五）leetcode 热题 HOT 100 C++ 答案总结刷题汇总（六）leetcode 多线程 / Shell PDF版 code （提取码：0wxr ） 1、两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。","text":"题目来源 腾讯精选练习（50 题） 相关：刷题汇总（一）leetcode 精选50题 JavaScript答案总结刷题汇总（二）剑指Offer 66题 C++答案总结刷题汇总（四）技术类编程题汇总 C++刷题汇总（五）leetcode 热题 HOT 100 C++ 答案总结刷题汇总（六）leetcode 多线程 / Shell PDF版 code （提取码：0wxr ） 1、两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* res = new ListNode(0); ListNode* head = res; int flag = 0; while(l1 || l2)&#123; int x = l1?l1-&gt;val:0; int y = l2?l2-&gt;val:0; head-&gt;next = new ListNode((x+y+flag)%10); flag = x+y+flag&gt;9?1:0; if(l1) l1= l1-&gt;next; if(l2) l2 = l2-&gt;next; head = head-&gt;next; &#125; if(flag) head-&gt;next = new ListNode(1); return res-&gt;next; &#125;&#125;; 2、寻找两个有序数组的中位数给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。 示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 123456789101112131415161718192021class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(); int n = nums2.size(); if(m &gt; n) return findMedianSortedArrays(nums2, nums1); //保证nums1更短 int lMax1,rMin1,lMax2,rMin2,c1,c2,low=0,high=2*m; while(low &lt;= high)&#123; c1 = (low + high)/2; c2 = m + n - c1; lMax1 = c1==0? INT_MIN:nums1[(c1-1)/2]; rMin1 = c1==2*m? INT_MAX:nums1[c1/2]; lMax2 = c2==0? INT_MIN:nums2[(c2-1)/2]; rMin2 = c2==2*n? INT_MAX:nums2[c2/2]; if(lMax1 &gt; rMin2) high=c1-1; else if(lMax2 &gt; rMin1) low=c1+1; else break; &#125; return (max(lMax1,lMax2)+min(rMin1,rMin2))/2.0; &#125;&#125;; 3、最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 输入: “cbbd”输出: “bb” 1234567891011121314151617181920212223class Solution &#123;public: // 时间复杂度：O(n^2)，空间复杂度：O(1) string longestPalindrome(string s) &#123; int start=0, len=0; for(int i=0;i&lt;s.size();i++)&#123; int tmp = max(getsub(i,i,s),getsub(i,i+1,s)); if(tmp&gt;len)&#123; len = tmp; start = i-(len-1)/2; &#125; &#125; return s.substr(start,len); &#125; int getsub(int i,int j,string s)&#123; while(i&gt;=0 &amp;&amp; j&lt;s.size() &amp;&amp; s[i]==s[j])&#123; i--; j++; &#125; return j-i-1; &#125;&#125;; 4、整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 输入: 123输出: 321 输入: -123输出: -321 输入: 120输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 12345678910111213class Solution &#123;public: int reverse(int x) &#123; int res=0; while(x!=0)&#123; if(res&gt;INT_MAX/10 || res==INT_MAX/10 &amp;&amp; x%10&gt;7) return 0; if(res&lt;INT_MIN/10 || res==INT_MIN/10 &amp;&amp; x%10&lt;-8) return 0; res=res*10+x%10; x=x/10; &#125; return res; &#125;&#125;; 5、字符串转换整数 (atoi)请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回 0。说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 输入: “42”输出: 42 输入: “ -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。 输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。 输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 12345678910111213141516171819class Solution &#123;public: int myAtoi(string str) &#123; int res = 0; bool flag = true; int i = 0; while(i&lt;str.size() &amp;&amp; str[i]==' ') i++; if(str[i] == '+')&#123;flag=true;i++;&#125; else if(str[i] == '-')&#123;flag=false;i++;&#125; for(;i&lt;str.size();i++)&#123; if(str[i]&lt;='9' &amp;&amp; str[i]&gt;='0')&#123; if(res&gt;INT_MAX/10 || res==INT_MAX/10&amp;&amp;(str[i]-'0')&gt;7) return flag?INT_MAX:INT_MIN; res = res*10+(str[i]-'0'); &#125; else return flag?res:-res; &#125; return flag?res:-res; &#125;&#125;; 6、回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 输入: 121输出: true 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 12345678910111213141516class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0) return false; string s = to_string(x); int l=0,r=s.size()-1; while(l&lt;=r)&#123; if(s[l] == s[r])&#123; l++; r--; &#125; else return false; &#125; return true; &#125;&#125;; 7、盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 输入: [1,8,6,2,5,4,8,3,7]输出: 49 1234567891011121314class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int smax = 0; int i = 0,j = height.size()-1; while(i&lt;=j)&#123; int s = min(height[i],height[j])*(j-i); if(s &gt; smax) smax = s; if(height[i]&lt;height[j]) i++; else j--; &#125; return smax; &#125;&#125;; 8、最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 输入: [“flower”,”flow”,”flight”]输出: “fl” 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。 1234567891011121314151617class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; int imin = 0; //最短的字符串 for(int i=0;i&lt;strs.size();i++)&#123; if(strs[i].size()&lt;strs[imin].size()) imin = i; &#125; string res; for(int i=0;i&lt;strs[imin].size();i++)&#123; for(int j=0;j&lt;strs.size();j++)&#123; if(strs[j][i] != strs[imin][i]) return res; &#125; res.push_back(strs[imin][i]); &#125; return res; &#125;&#125;; 9、三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); vector&lt;vector&lt;int&gt; &gt; res; int add; for(int i=0;i&lt;nums.size();i++)&#123; if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) continue; //i和前面一样，跳过 if((add = nums[i])&gt;0) break; int l = i+1, r = nums.size()-1; //双指针，找和为add while(l&lt;r)&#123; if(nums[l]+nums[r]+add&gt;0) r--; else if(nums[l]+nums[r]+add&lt;0) l++; else &#123; res.push_back(&#123;add,nums[l],nums[r]&#125;); l++;r--; while(l&lt;r &amp;&amp; nums[l] == nums[l-1]) l++; while(l&lt;r &amp;&amp; nums[r] == nums[r+1]) r--; &#125; &#125; &#125; return res; &#125;&#125;; 10、最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 12345678910111213141516171819202122232425class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(),nums.end()); int add = 0,dis = INT_MAX; for(int i=0;i&lt;nums.size();i++)&#123; int l = 0, r = nums.size()-1; while(l&lt;r)&#123; if(l==i) l++; if(r==i) r--; if(l&gt;=r) break; int tadd = nums[i]+nums[l]+nums[r]; int tdis = abs(tadd-target); if(tdis &lt; dis)&#123; add = tadd; dis = tdis; &#125; if(tadd == target) return add; if(tadd &lt; target) l++; else r--; &#125; &#125; return add; &#125;&#125;; 11、有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 输入: “()”输出: true 输入: “()[]{}”输出: true 输入: “(]”输出: false 输入: “([)]”输出: false 输入: “{[]}”输出: true 12345678910111213141516class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; stack; for(int i=0;i&lt;s.size();i++)&#123; if(!stack.empty() &amp;&amp; check(stack.top(),s[i])) stack.pop(); else stack.push(s[i]); &#125; return stack.empty(); &#125; bool check(char a,char b) &#123; if(a=='('&amp;&amp;b==')' || a=='['&amp;&amp;b==']' || a=='&#123;'&amp;&amp;b=='&#125;') return true; return false; &#125;&#125;; 12、合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4···c 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* res = new ListNode(0); ListNode* head = res; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; head-&gt;next = l1; l1 = l1-&gt;next; &#125; else&#123; head-&gt;next = l2; l2 = l2-&gt;next; &#125; head = head-&gt;next; &#125; head-&gt;next = l1?l1:l2; return res-&gt;next; &#125;&#125;; 13、合并K个排序链表合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6] 输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode* list = NULL; for(int i=0;i&lt;lists.size();i++)&#123; list = merge2Lists(list,lists[i]); &#125; return list; &#125; ListNode* merge2Lists(ListNode* l1, ListNode* l2) &#123; ListNode* res = new ListNode(0); ListNode* head = res; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; head-&gt;next = l1; l1 = l1-&gt;next; &#125; else&#123; head-&gt;next = l2; l2 = l2-&gt;next; &#125; head = head-&gt;next; &#125; head-&gt;next = l1?l1:l2; return res-&gt;next; &#125;&#125;; 14、删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 1234567891011121314class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int i = 0; //双指针 for(int j=1;j&lt;nums.size();j++)&#123; if(nums[i] != nums[j])&#123; i++; nums[i]=nums[j]; &#125; &#125; return i+1; &#125;&#125;; 15、搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。 输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 1234567891011121314151617181920class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; return helper(nums,target,0,nums.size()-1); &#125; int helper(vector&lt;int&gt;&amp; nums, int target, int i, int j) &#123; if(i&gt;j) return -1; int mid = (i+j)/2; if(nums[mid] == target) return mid; if(nums[mid] &lt; nums[j])&#123; //7 8 1 2 3 4 旋转点在左，右顺序 if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[j]) return helper(nums,target,mid+1,j); else return helper(nums,target,i,mid-1); &#125; else&#123; //3 4 7 8 1 2 旋转点在右，左顺序 if(nums[mid] &gt; target &amp;&amp; target &gt;= nums[i]) return helper(nums,target,i,mid-1); else return helper(nums,target,mid+1,j); &#125; &#125;&#125;; 16、字符串相乘给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 输入: num1 = “2”, num2 = “3”输出: “6” 输入: num1 = “123”, num2 = “456”输出: “56088”说明： num1 和 num2 的长度小于110。num1 和 num2 只包含数字 0-9。num1 和 num2 均不以零开头，除非是数字 0 本身。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 123456789101112131415161718class Solution &#123;public: string multiply(string num1, string num2) &#123; int len1 = num1.size(),len2 = num2.size(); string res(len1+len2,'0'); for(int i=len1-1;i&gt;=0;i--)&#123; for(int j=len2-1;j&gt;=0;j--)&#123; int t = (res[i+j+1]-'0')+(num1[i]-'0')*(num2[j]-'0'); res[i+j+1] = t%10 +'0'; res[i+j] += t/10; &#125; &#125; for(int i=0;i&lt;len1+len2;i++)&#123; if(res[i] != '0') return res.substr(i); &#125; return \"0\"; &#125;&#125;; 17、全排列给定一个没有重复数字的序列，返回其所有可能的全排列。 输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; backtrack(nums,res,0); return res; &#125; void backtrack(vector&lt;int&gt; &amp;nums,vector&lt;vector&lt;int&gt;&gt; &amp;res,int n) &#123; if(n == nums.size()-1) res.push_back(nums); else&#123; for(int i=n;i&lt;nums.size();i++)&#123; swap(nums[i],nums[n]); backtrack(nums,res,n+1); swap(nums[i],nums[n]); &#125; &#125; &#125; void swap(int &amp;i ,int &amp;j) &#123; int t = i; i = j; j = t; &#125;&#125;;//剑指offer 27题 字典序输出有重复字符串序列的全排列/* 问题转换为先固定第一个字符，求剩余字符的排列 再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合 a b b c: a+f(bbc),b+f(abc),c+f(cbba); 遍历出所有可能出现在第一个位置的字符 f(bbc)=b+f(bc),c+f(bb); f(bc)=b+f(c),c+f(b); f(c)=c;class Solution &#123;public: vector&lt;string&gt; Permutation(string str) &#123; vector&lt;string&gt; res; helper(str,res,0); sort(res.begin(),res.end()); return res; &#125; void helper(string s, vector&lt;string&gt; &amp;res, int n) &#123; if(n == s.size()-1)&#123; //终止条件 if(find(res.begin(),res.end(),s) == res.end()) res.push_back(s); &#125; else&#123; for(int i=n;i&lt;s.size();i++)&#123; swap(s[i],s[n]); helper(s,n+1); swap(s[i],s[n]); &#125; &#125; &#125; void swap(char &amp;i ,char &amp;j) &#123; char t = i; i = j; j = t; &#125;&#125;;*/ 18、最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 12345678910111213class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int max = nums[0]; int add = 0; for(int i=0;i&lt;nums.size();i++)&#123; add += nums[i]; if(add &gt; max) max = add; if(add &lt; 0) add = 0; &#125; return max; &#125;&#125;; 19、螺旋矩阵给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] 输出: [1,2,3,6,9,8,7,4,5] 输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]] 输出: [1,2,3,4,8,12,11,10,9,5,6,7] 12345678910111213141516171819202122232425262728class Solution &#123;public: /* m n i 1 2 3 4 5 6 j 7 8 9 */ vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return &#123;&#125;; vector&lt;int&gt; res; int i=0,j=matrix.size()-1,m=0,n=matrix[0].size()-1; while(i&lt;=j &amp;&amp; m&lt;=n)&#123; for(int k=m;k&lt;=n;k++) res.push_back(matrix[i][k]); i++; if(i&gt;j) break; for(int k=i;k&lt;=j;k++) res.push_back(matrix[k][n]); n--; if(m&gt;n) break; for(int k=n;k&gt;=m;k--) res.push_back(matrix[j][k]); j--; if(i&gt;j) break; for(int k=j;k&gt;=i;k--) res.push_back(matrix[k][m]); m++; &#125; return res; &#125;&#125;; 20、螺旋矩阵 II给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 输入: 3输出:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; arr(n,vector&lt;int&gt;(n,0)); int c = 1,k = 0; while(c&lt;=n*n)&#123; for(int i=k;i&lt;n-k;i++) arr[k][i]=c++; for(int i=k+1;i&lt;n-k;i++) arr[i][n-k-1]=c++; for(int i=n-k-2;i&gt;=k;i--) arr[n-k-1][i]=c++; for(int i=n-k-2;i&gt;=k+1;i--) arr[i][k]=c++; k++; &#125; return arr; &#125;&#125;; 21、旋转链表给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; //1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 if(k==0 || !head) return head; int len = getlen(head); if((k = k%len)==0) return head; ListNode* pre = head; //1-&gt;2-&gt;3-&gt;NULL ListNode* cur = pre; for(int i=0;i&lt;len-k-1;i++)&#123; cur = cur-&gt;next; &#125; ListNode* last = cur-&gt;next; //4-&gt;5-&gt;NULL cur-&gt;next = NULL; cur = last; while(cur-&gt;next)&#123; cur = cur-&gt;next; &#125; cur-&gt;next = head; //4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL return last; &#125; int getlen(ListNode* head)&#123; int res = 0; ListNode* root = head; while(root)&#123; res++;root = root-&gt;next; &#125; return res; &#125;&#125;; 22、不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？例如，上图是一个7 x 3 的网格。有多少可能的路径？说明：m 和 n 的值均不超过 100。 输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右 输入: m = 7, n = 3输出: 28 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0));//m*n零矩阵 for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(i==0 || j==0) dp[i][j]=1; else dp[i][j] = dp[i-1][j]+dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 23、爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。 输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 输入： 3输出： 3解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶1234567891011121314//当n=45时，结果已经超出了返回值类型int有效范围无法通过，不知道测试怎么回事，同剑指offer 8，剑指可通过class Solution &#123;public: int climbStairs(int n) &#123; int i=1,j=1; while(n &gt; 0)&#123; int t = i; i = j; j = t+j; n--; &#125; return i; &#125;&#125;; 24、子集给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。 输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int l = 1 &lt;&lt; nums.size(); for(int i=0;i&lt;l;i++)&#123; vector&lt;int&gt; tmp; for(int j=0;j&lt;nums.size();j++)&#123; if(i&amp;(1&lt;&lt;j)) tmp.push_back(nums[j]); &#125; res.push_back(tmp); &#125; return res; &#125;&#125;; 25、合并两个有序数组给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。说明:初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 12345678910111213141516171819202122class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i=m-1,j=n-1,cur=n+m-1; while(i&gt;=0 &amp;&amp; j&gt;=0)&#123; if(nums1[i]&lt;nums2[j])&#123; nums1[cur]=nums2[j]; j--; &#125;else&#123; nums1[cur]=nums1[i]; i--; &#125; cur--; &#125; while(i&gt;=0)&#123; nums1[cur]=nums1[i];i--;cur--; &#125; while(j&gt;=0)&#123; nums1[cur]=nums2[j];j--;cur--; &#125; &#125;&#125;; 26、格雷编码格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。 输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2 对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1 输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 123456789101112131415161718192021222324252627class Solution &#123;public:/*n: 0 1 2 3 0 0 00 000 1 10 100 010 01 110 11 001 101 011 111*/ vector&lt;int&gt; grayCode(int n) &#123; if(n==0) return &#123;0&#125;; vector&lt;int&gt; res&#123;0,1&#125;; for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;res.size();j++)&#123; res[j]*=2; //末位加0 &#125; for(int j=res.size()-1;j&gt;=0;j--)&#123; res.push_back(res[j]+1); //末位加1 &#125; &#125; return res; &#125;&#125;; 27、二叉树的最大深度给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。 给定二叉树 [3,9,20,null,null,15,7]， 3 / 9 20 / 15 7返回它的最大深度 3 。 12345678910111213141516/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(!root) return 0; return max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+1; &#125;&#125;; 28、买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int max = 0; for(int i=0;i&lt;prices.size();i++)&#123; for(int j=i+1;j&lt;prices.size();j++)&#123; if(prices[j]-prices[i]&gt;max)&#123; max = prices[j]-prices[i]; &#125; &#125; &#125; return max; &#125;&#125;; 29、买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int max = 0; for(int i=0;i&lt;prices.size()-1;i++)&#123; if(prices[i+1]&gt;prices[i]) max += prices[i+1]-prices[i]; &#125; return max; &#125;&#125;; 30、二叉树中的最大路径和给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 输入: [1,2,3] 1 / 2 3输出: 6 输入: [-10,9,20,null,null,15,7] -10 / 9 20 / 15 7输出: 42 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int res = INT_MIN; int maxPathSum(TreeNode* root) &#123; submax(root); return res; &#125; int submax(TreeNode* root) &#123; //从root向下走的最长距离 if(!root) return 0; int l = max(0,submax(root-&gt;left)); int r = max(0,submax(root-&gt;right)); if(root-&gt;val+l+r &gt; res) res=root-&gt;val+l+r; return root-&gt;val+max(l,r); &#125;&#125;; 31、只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 输入: [2,2,1]输出: 1 输入: [4,1,2,1,2]输出: 4 12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(int i=0;i&lt;nums.size();i++)&#123; res ^= nums[i]; &#125; return res; &#125;&#125;; 32、环形链表给定一个链表，判断链表中是否有环。 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(!head) return false; ListNode *fast = head; ListNode *slow = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow == fast) return true; &#125; return false; &#125;&#125;; 33、环形链表 II给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表。 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(!head) return NULL; bool loop = false; ListNode* slow = head; ListNode* fast = head; while(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow == fast)&#123; loop = true; break; &#125; &#125; if(loop)&#123; ListNode* res = head; while(res!=slow)&#123; res = res-&gt;next; slow = slow-&gt;next; &#125; return res; &#125; return NULL; &#125;&#125;; 34、LRU缓存机制运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 进阶:你是否可以在 O(1) 时间复杂度内完成这两种操作？ LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得密钥 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得密钥 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4 123456789101112131415161718192021222324252627282930313233343536373839class LRUCache &#123;public: LRUCache(int capacity) &#123; _cap = capacity; &#125; int get(int key) &#123; auto iter = _map.find(key); if(iter == _map.end()) return -1; int res = iter-&gt;second-&gt;second; _list.erase(iter-&gt;second); _list.push_front(make_pair(key,res)); _map[key] = _list.begin(); return res; &#125; void put(int key, int value) &#123; auto iter = _map.find(key); if(iter != _map.end()) _list.erase(iter-&gt;second); _list.push_front(make_pair(key,value)); _map[key] = _list.begin(); if(_list.size()&gt;_cap)&#123; int t = _list.back().first; _map.erase(t); _list.pop_back(); &#125; &#125;private: unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; _map; list&lt;pair&lt;int,int&gt;&gt; _list; int _cap;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */ 35、排序链表在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head; ListNode* fast = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; ListNode* bk = slow-&gt;next; slow-&gt;next = NULL; ListNode* l1 = sortList(head); ListNode* l2 = sortList(bk); //合并有序链表 ListNode* res = new ListNode(0); ListNode* h = res; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val&gt;l2-&gt;val)&#123; h-&gt;next = l2; l2 = l2-&gt;next; &#125; else&#123; h-&gt;next = l1; l1 = l1-&gt;next; &#125; h = h-&gt;next; &#125; h-&gt;next = l1?l1:l2; return res-&gt;next; &#125;&#125;; 36、最小栈设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。push(x) – 将元素 x 推入栈中。pop() – 删除栈顶的元素。top() – 获取栈顶元素。getMin() – 检索栈中的最小元素。 MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; 返回 -3.minStack.pop();minStack.top(); –&gt; 返回 0.minStack.getMin(); –&gt; 返回 -2. 12345678910111213141516171819202122232425262728293031323334353637class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; if(smin.empty() || x &lt;= smin.top()) smin.push(x); s.push(x); &#125; void pop() &#123; if(smin.top() == s.top()) smin.pop(); s.pop(); &#125; int top() &#123; return s.top(); &#125; int getMin() &#123; return smin.top(); &#125;private: stack&lt;int&gt; s; stack&lt;int&gt; smin;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */ 37、相交链表编写一个程序，找到两个单链表相交的起始节点。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; int len1 = getlen(headA); int len2 = getlen(headB); int step = abs(len1-len2); while(step!=0)&#123; if(len1&gt;len2) headA = headA-&gt;next; else headB = headB-&gt;next; step--; &#125; while(headA)&#123; if(headA == headB) return headA; headA = headA-&gt;next; headB = headB-&gt;next; &#125; return NULL; &#125; int getlen(ListNode* l) &#123; int res = 0; while(l)&#123; res++; l = l-&gt;next; &#125; return res; &#125;&#125;; 38、求众数给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。 输入: [3,2,3]输出: 3 输入: [2,2,1,1,1,2,2]输出: 2 12345678910111213141516171819202122class Solution &#123;public: /* 如果重复的次数超过一半的话，一定有相邻的数字相同这种情况的 对数组同时去掉两个不同的数字，到最后剩下的一个数就是该数字 */ int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int res = nums[0]; int count = 1; for(int i=1;i&lt;nums.size();i++)&#123; if(nums[i] == res) count++; else&#123; count--; if(count == 0)&#123; res = nums[i]; count = 1; &#125; &#125; &#125; return res; &#125;&#125;; 39、反转链表反转一个单链表。 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* res = NULL; while(head)&#123; ListNode* tmp = new ListNode(head-&gt;val); tmp-&gt;next = res; res = tmp; head = head-&gt;next; &#125; return res; &#125;&#125;; 40、数组中的第K个最大元素在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 123456789101112131415161718class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q; for(int i=0;i&lt;nums.size();i++)&#123; if(q.size()==k)&#123; if(q.top()&lt;nums[i])&#123; q.pop(); q.push(nums[i]); &#125; &#125; else&#123; q.push(nums[i]); &#125; &#125; return q.top(); &#125;&#125;; 41、存在重复元素给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 输入: [1,2,3,1]输出: true 输入: [1,2,3,4]输出: false 1234567891011class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int,int&gt; m; for(int i=0;i&lt;nums.size();i++)&#123; if(m.find(nums[i]) != m.end()) return true; else m[nums[i]] = 1; &#125; return false; &#125;&#125;; 42、二叉搜索树中第K小的元素给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int res; int cur = 0; int kthSmallest(TreeNode* root, int k) &#123; midfor(root, k); return res; &#125; void midfor(TreeNode* root, int k) &#123; if(!root) return; if(cur != k) midfor(root-&gt;left,k); cur++; if(cur == k)&#123; res = root-&gt;val; &#125; if(cur != k) midfor(root-&gt;right,k); &#125;&#125;; 43、2的幂给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 123456789101112131415class Solution &#123;public: bool isPowerOfTwo(int n) &#123; if(n&lt;=0) return false; while(n!=1)&#123; double t = n/2.0; if(!isint(t)) return false; n /= 2; &#125; return true; &#125; bool isint(double d)&#123; return abs(d-(int)d)&lt;1e-5; &#125;&#125;; 44、 二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6解释: 节点 2 和节点 8 的最近公共祖先是 6。 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。 12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* res; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; search(root,p,q); return res; &#125; void search(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if((root-&gt;val-p-&gt;val)*(root-&gt;val-q-&gt;val)&lt;=0) res = root; else if(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) search(root-&gt;right,p,q); else search(root-&gt;left,p,q); &#125;&#125;; 45、二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(!root) return NULL; if(root == p || root == q) return root; TreeNode* l = lowestCommonAncestor(root-&gt;left,p,q); TreeNode* r = lowestCommonAncestor(root-&gt;right,p,q); if(l&amp;&amp;r) return root; if(l) return l; if(r) return r; return NULL; &#125;&#125;; 46、删除链表中的节点请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。现有一个链表 – head = [4,5,1,9]，它可以表示为: 输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 123456789101112131415/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next; &#125;&#125;; 47、除自身以外数组的乘积给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 输入: [1,2,3,4]输出: [24,12,8,6]说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int l=1, r=1; vector&lt;int&gt; res(nums.size()); for(int i=0;i&lt;nums.size();i++)&#123; res[i] = l; l *= nums[i]; &#125; for(int i=nums.size()-1;i&gt;=0;i--)&#123; res[i] *= r; r *= nums[i]; &#125; return res; &#125;&#125;; 48、Nim 游戏你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。 输入: 4输出: false解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛； 因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。 123456class Solution &#123;public: bool canWinNim(int n) &#123; return !(n%4==0); &#125;&#125;; 49、反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 输入：[“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”] 输入：[“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”]· 12345678910class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int i=0,j=s.size()-1; while(i&lt;j)&#123; swap(s[i],s[j]); i++;j--; &#125; &#125;&#125;; 50、反转字符串中的单词 III给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 输入: “Let’s take LeetCode contest”输出: “s’teL ekat edoCteeL tsetnoc”注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 123456789101112131415161718192021222324class Solution &#123;public: string reverseWords(string s) &#123; string res; stack&lt;char&gt; stack; for(int i=0;i&lt;s.size();i++)&#123; if(s[i] == ' ')&#123; while(!stack.empty())&#123; res.push_back(stack.top()); stack.pop(); &#125; res.push_back(' '); &#125; else&#123; stack.push(s[i]); &#125; &#125; while(!stack.empty())&#123; res.push_back(stack.top()); stack.pop(); &#125; return res; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"},{"name":"CodeCode","slug":"CodeCode","permalink":"http://yoursite.com/categories/CodeCode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"常见算法的c++实现总结","slug":"24","date":"2019-08-07T03:11:48.000Z","updated":"2019-12-18T04:19:53.589Z","comments":true,"path":"2019/08/07/24/","link":"","permalink":"http://yoursite.com/2019/08/07/24/","excerpt":"目录一、七大排序算法二、大整数计算三、编kmp辑距离问题四、kmp算法五、dijkstra算法六、0/1背包问题 一、七大排序算法","text":"目录一、七大排序算法二、大整数计算三、编kmp辑距离问题四、kmp算法五、dijkstra算法六、0/1背包问题 一、七大排序算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void swap(int &amp;a, int &amp;b) &#123; int tmp; tmp = a; a = b; b = tmp;&#125;//一、插入排序//1.1 直接插入排序 时间复杂度O(n^2) 空间复杂度O(1) 稳定//构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。void insert_sort(vector&lt;int&gt; &amp;nums) &#123; for (int i = 0; i &lt; nums.size(); i++)&#123; for (int j = i; j &gt; 0; j--)&#123; if (nums[j] &lt; nums[j - 1]) swap(nums[j], nums[j - 1]); &#125; &#125;&#125;//1.2 希尔排序 时间复杂度O(n^1.3) 空间复杂度O(1) 不稳定//按照一定步长分成子序列进行排序，然后逐步递减步长来完成最终排序。增量 d = 1时， 就是插入排序void shell_sort(vector&lt;int&gt; &amp;nums) &#123; for (int gap = nums.size() &gt;&gt; 1; gap&gt;0; gap &gt;&gt;= 1)&#123; for (int i = gap; i &lt; nums.size(); i++) &#123; int tmp = nums[i]; int j = i - gap; for (; j &gt;= 0 &amp;&amp; nums[j] &gt; tmp; j -= gap)&#123; nums[j + gap] = nums[j]; &#125; nums[j + gap] = tmp; &#125; &#125;&#125;//二、选择排序//2.1 选择排序 时间复杂度O(n^2) 空间复杂度O(1) 不稳定//先进行第一轮循环比较相邻两项，找到最小值得下标，将最小值与第一项交换，然后重复排序剩余部分。void select_sort(vector&lt;int&gt; &amp;nums) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; int min = i; for (int j = i + 1; j &lt; nums.size(); j++)&#123; if (nums[j] &lt; nums[min]) min = j; &#125; swap(nums[i], nums[min]); &#125;&#125;//2.2 堆排序 时间复杂度O(nlgn) 空间复杂度O(1) 稳定//构造一个最大堆（完全二叉树），父结点大于左右子结点，然后取出根结点（最大值）与最后一个结点交换，重复调整剩余的结点成最大堆，得到有序的序列。void max_heapify(vector&lt;int&gt; &amp;nums, int l, int r) &#123; int curr = l; int child = curr * 2 + 1; while (child &lt; r) &#123; if (child + 1 &lt; r &amp;&amp;nums[child] &lt; nums[child + 1]) child++; if (nums[curr] &lt; nums[child]) &#123; swap(nums[curr], nums[child]); curr = child; child = 2 * curr + 1; &#125; else break; &#125;&#125;void heap_sort(vector&lt;int&gt; &amp;nums) &#123; for (int i = nums.size() / 2 - 1; i &gt;= 0; i--) &#123; max_heapify(nums, i, nums.size()); &#125; for (int i = nums.size() - 1; i &gt; 0; i--) &#123; swap(nums[0], nums[i]); max_heapify(nums, 0, i); &#125;&#125;//三、交换排序//3.1 冒泡排序 时间复杂度O(n^2) 空间复杂度O(1) 稳定//每次通过两两比较交换位置，选出剩余无序序列里最大（小）的数据元素放到队尾。void bubble_sort(vector&lt;int&gt; &amp;nums) &#123; for (int i = 0; i &lt; nums.size() - 1; i++)&#123; for (int j = 0; j &lt; nums.size() - i - 1; j++)&#123; if (nums[j] &gt; nums[j + 1]) swap(nums[j], nums[j + 1]); &#125; &#125;&#125;//3.2快速排序 时间复杂度O(nlgn) 空间复杂度O(1) 不稳定//将无序序列分隔成两部分，左边均比右边小，分别对这两部分进行排序void quick_sort(vector&lt;int&gt; &amp;nums, int l, int r) &#123; if (l &lt; r) &#123; int i = l, j = r; while (i &lt; j) &#123; while (nums[j] &gt;= nums[l] &amp;&amp; i &lt; j) j--; while (nums[i] &lt;= nums[l] &amp;&amp; i &lt; j) i++; swap(nums[i], nums[j]); &#125; swap(nums[l], nums[i]); quick_sort(nums, l, i-1); quick_sort(nums, i + 1, r); &#125;&#125;//四、归并排序 时间复杂度O(nlgn) 空间复杂度O(n) 稳定//将序列递归分成单位为1的小序列，然后两两合并排序，最终得到有序的序列。void merge_sort(vector&lt;int&gt; &amp;nums, int l, int r, vector&lt;int&gt; &amp;tmp) &#123; if (l &gt;= r) return; int m = (l + r) / 2; merge_sort(nums, l, m, tmp); merge_sort(nums, m + 1, r, tmp); int i = l, j = m + 1, index = l; while (i &lt;= m &amp;&amp; j &lt;= r) &#123; if (nums[i] &lt; nums[j]) tmp[index++] = nums[i++]; else tmp[index++] = nums[j++]; &#125; while (i &lt;= m) tmp[index++] = nums[i++]; while (j &lt;= r) tmp[index++] = nums[j++]; for (int i = l; i &lt;= r; i++) nums[i] = tmp[i];&#125;int main() &#123; cout &lt;&lt; \"原始数列：8, 3, 1, 4, 11, 2, 2, 1, 5, 2, 7, 9, 1, 6 \" &lt;&lt; endl; cout &lt;&lt; \"请选择排序算法：\" &lt;&lt; endl; cout &lt;&lt; \"1 插入排序，2 希尔排序，3 选择排序，4 堆排序，5 冒泡排序，6 快速排序，7 归并排序\" &lt;&lt; endl; int index; while (cin &gt;&gt; index)&#123; vector&lt;int&gt; nums&#123; 8, 3, 1, 4, 11, 2, 2, 1, 5, 2, 7, 9, 1, 6 &#125;; int len = nums.size(); switch (index)&#123; case 1: insert_sort(nums); //插入排序 break; case 2: shell_sort(nums); //希尔排序 break; case 3: select_sort(nums); //选择排序 break; case 4: heap_sort(nums); //堆排序 break; case 5: bubble_sort(nums); //冒泡排序 break; case 6: quick_sort(nums, 0, len - 1); //快速排序 break; case 7: vector&lt;int&gt; tmp(len); merge_sort(nums, 0, len - 1, tmp); //归并排序 break; &#125; for (int i = 0; i&lt;nums.size(); i++)&#123; cout &lt;&lt; nums[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 二、大整数计算12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//大数相加string addstr(string s1, string s2) &#123; if (s1.size()&gt;s2.size()) return addstr(s2, s1); //s1短 s1.insert(s1.begin(), s2.size() - s1.size(), '0'); string res(s2.size() + 1, '0'); for (int i = s2.size() - 1; i &gt;= 0; i--)&#123; int t = (s1[i] - '0') + (s2[i] - '0') + (res[i + 1] - '0'); res[i + 1] = t % 10 + '0'; res[i] = t / 10 + '0'; &#125; if (res[0] == '0') return res.substr(1); return res;&#125;//大数相乘string multiply(string num1, string num2) &#123; int len1 = num1.size(), len2 = num2.size(); string res(len1 + len2, '0'); for (int i = len1 - 1; i &gt;= 0; i--)&#123; for (int j = len2 - 1; j &gt;= 0; j--)&#123; int t = (res[i + j + 1] - '0') + (num1[i] - '0')*(num2[j] - '0'); res[i + j + 1] = t % 10 + '0'; res[i + j] += t / 10; &#125; &#125; for (int i = 0; i&lt;len1 + len2; i++)&#123; if (res[i] != '0') return res.substr(i); &#125; return \"0\";&#125;int main()&#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; cout &lt;&lt; \"相加:\" &lt;&lt; addstr(s1,s2) &lt;&lt; endl; cout &lt;&lt; \"相乘:\" &lt;&lt; multiply(s1, s2) &lt;&lt; endl; return 0;&#125; 三、编辑距离问题题目地址 编辑距离，又称Levenshtein距离，是指两个子串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。请尝试写出一个算法来计算两个字符串的编辑距离。 1、当min(i,j)=0时，f(i,j)=max(i,j)，一个字符串的长度为0，编辑距离是另一个字符串的长度2、当a[i]=b[j]时，f(i,j)=f(i−1,j−1)，比如xxcz和xyz的距离=xxc和xy的距离3、否则，lev(i,j)为如下三项的最小值： f(i−1,j)+1(在a中删除ai); f(i,j−1)+1(在a中插入bj); f(i−1,j−1)+1(在a中把ai替换bj)， 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;//编辑距离int EditDistance(string s1, string s2) &#123; int m = s1.size(), n = s2.size(); vector&lt;vector&lt;int&gt;&gt; arr(m + 1, vector&lt;int&gt;(n + 1)); for (int i = 0; i &lt;= m; i++)&#123; for (int j = 0; j &lt;= n; j++)&#123; if (i == 0 || j == 0)&#123; arr[i][j] = max(i, j); &#125; else if(s1[i-1] == s2[j-1])&#123; //注意 arr[i][j] = arr[i - 1][j - 1]; &#125; else&#123; arr[i][j] = min(arr[i - 1][j] + 1, min(arr[i][j-1] + 1, arr[i - 1][j - 1] + 1)); &#125; &#125; &#125; return arr[m][n];&#125;int main()&#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; cout &lt;&lt; EditDistance(s1, s2) &lt;&lt; endl; return 0;&#125; 时间复杂度O（nm)， 空间复杂度O（nm） 四、kmp算法题目地址 给定两个字符串str和match，长度分别为N和M。实现一个算法，如果字符串str中含有子串match，则返回match在str中的开始位置，不含有则返回-1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;// 暴力匹配算法int ViolentMatch(string s, string p) &#123; int i = 0, j = 0, slen = s.size(), plen = p.size(); while (i &lt; slen &amp;&amp; j &lt; plen) &#123; if (s[i] == p[j])&#123; i++; j++; &#125; else&#123; i = i - j + 1; j = 0; &#125; &#125; if (j == plen) return i - j; else return -1;&#125;// KMP算法int KMP(string s, string p, vector&lt;int&gt;next) &#123; int i = 0, j = 0, slen = s.size(), plen = p.size(); while (i &lt; slen &amp;&amp; j &lt; plen) &#123; if (j == -1 || s[i] == p[j])&#123; i++; j++; &#125; else&#123; j = next[j]; &#125; &#125; if (j == plen) return i - j; else return -1;&#125;// MultiKMP算法vector&lt;int&gt; MultiKMP(string s, string p, vector&lt;int&gt;next) &#123; vector&lt;int&gt; res; int i = 0, j = 0, slen = s.size(), plen = p.size(); while (i &lt; slen) &#123; if (j == -1 || s[i] == p[j])&#123; i++; j++; &#125; else&#123; j = next[j]; &#125; if (j == plen)&#123; res.push_back(i - j); j = 0; &#125; &#125; return res;&#125;// MultiKMP2算法vector&lt;int&gt; MultiKMP2(string s, string p, vector&lt;int&gt;next) &#123; vector&lt;int&gt; res; int i = 0, j = 0, slen = s.size(), plen = p.size(); while (i &lt; slen) &#123; if (j == -1 || s[i] == p[j])&#123; i++; j++; &#125; else&#123; j = next[j]; &#125; if (j == plen)&#123; res.push_back(i - j); i = i - j + 1; j = 0; &#125; &#125; return res;&#125;vector&lt;int&gt; GetNext(string p)&#123; vector&lt;int&gt; next(p.size()); next[0] = -1; int k = -1, j = 0; while (j &lt; p.size() - 1) &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k])&#123; ++k; ++j; if (p[j] != p[k]) next[j] = k; else next[j] = next[k]; &#125; else&#123; k = next[k]; &#125; &#125; return next;&#125;void printvec(vector&lt;int&gt; vec) &#123; if (!vec.empty())&#123; for (int i = 0; i &lt; vec.size(); i++)&#123; cout &lt;&lt; vec[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; -1 &lt;&lt; endl; &#125;&#125;int main()&#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; vector&lt;int&gt; next = GetNext(s2); // 暴力匹配第一次出现位置 cout &lt;&lt; ViolentMatch(s1, s2) &lt;&lt; endl; // KMP匹配第一次出现位置 cout &lt;&lt; KMP(s1, s2, next) &lt;&lt; endl; // KMP匹配无重复所有出现位置 vector&lt;int&gt; res = MultiKMP(s1, s2, next); printvec(res); // KMP匹配可重复所有出现位置 vector&lt;int&gt; res2 = MultiKMP2(s1, s2, next); printvec(res2); return 0;&#125; 算法详解 时间复杂度为O(m + n)扩展：BM算法、Sunday算法。 五、dijkstra算法迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。它解决的是带权重的有向图上单源最短路径问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int maxn = 100; // 最大顶点数int map[maxn][maxn]; // 邻接矩阵存图int dis[maxn]; // dist[i]表示距离源点的最短距离int vis[maxn]; // vis[i] = 1表示已加入集合Sint path[maxn]; // 记录路径int n, m, r;void dijk(int s) // 求顶点s到其他顶点的最短路径&#123; //初始化 memset(path, -1, sizeof(path)); /*INF使用0x3f3f3f3f的好处： * 1：满足无穷大加一个有穷的数依然是无穷大（在DijKstra算法松弛操作中避免了溢出而出现负数） * 2：满足无穷大加无穷大依然是无穷大（两个0x3f3f3f3f相加并未溢出） * 3：初始化时，由于每一个字节为0x3f，所以只需要memset（buf，0x3f,sizeof(buf)）即可 */ memset(dis, 0x3f, sizeof(dis)); //初始化为无穷大 memset(vis, 0, sizeof(vis)); dis[s] = 0; //自身到自身的距离为0 while (1) &#123; int k = 0; for (int j = 1; j &lt;= n; j++) &#123; if (!vis[j] &amp;&amp; dis[j]&lt;dis[k])//找未收录顶点中dis值最小的 k = j; //这里第一次找到的是起点 &#125; if (!k) return; //没有未收录的点，则返回 vis[k] = 1; //松弛操作 for (int j = 1; j &lt;= n; j++) &#123; //第一次循环只有起点的邻接点距离被更新，每次都更新新找到的点的邻接点 if (dis[j]&gt;dis[k] + map[k][j]) &#123; dis[j] = dis[k] + map[k][j]; path[j] = k;//路径被改变，重新记录前驱，最短路是由最短路+某一条固定路组成，所以前驱是有效的 &#125; &#125; &#125;&#125;void printPath(int x)&#123; if (x == -1) return; //递归 printPath(path[x]); if (x == r) cout &lt;&lt; x; else cout &lt;&lt; \" -&gt; \" &lt;&lt; x;&#125;/*问题描述：* 输入n,m和r，代表n个节点，m条边，出发点r，然后是m行输入，每行有x,y,z，代表x到y的路距离为z。* 问题：从r出发到各点的最短路径。*/int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; r; memset(map, 0x3f, sizeof(map)); int x, y, z; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; if (map[x][y] &gt; z)&#123; // 防止1-&gt;1的环 map[x][y] = z; //map[y][x] = z; // 无向图 &#125; &#125; dijk(r); for (int i = 1; i &lt;= n; i++)&#123; printPath(i); cout&lt;&lt; \" \"&lt;&lt; dis[i]; cout&lt;&lt; endl; &#125; return 0;&#125; 算法详解 算法详解 时间复杂度为O( n^2) 六、0/1背包问题0/1背包问题:满足总重量&lt;=背包重量限制，使价值最大。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int ZeroOnePack(int m, int s, vector&lt;int&gt; weight, vector&lt;int&gt; value) &#123; // F[i ][ v] 表示 前i件物品恰放入一个容量恰为v的背包可以获得的最大价值 vector&lt;vector&lt;int&gt; &gt; F(m + 1, vector&lt;int&gt;(s + 1)); for (int i = 0; i &lt;= s; i++) &#123; F[0][i] = 0; //如果要求恰好装满背包，除了F[0]为0，其余F[1 .. s]均设为-INF &#125; for (int i = 1; i &lt;= m; i++)&#123; for (int j = 0; j &lt;= s; j++)&#123; if (j &gt;= weight[i - 1]) F[i][j] = max(F[i - 1][j], F[i - 1][j - weight[i - 1]] + value[i - 1]); else F[i][j] = F[i - 1][j]; &#125; &#125; //打印哪几样物品能够获得最大价值 vector&lt;bool&gt; isAdd(m,false); int j = s; for (int i = m; i &gt;= 1; i--)&#123; if (F[i][j] != F[i - 1][j])&#123; isAdd[i - 1] = true; j = j - weight[i - 1]; &#125; &#125; for (int i = 0; i &lt; m; i++)&#123; cout &lt;&lt; isAdd[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; return F[m][s];&#125;int main() &#123; int m, s; // 物品种类m，背包总空间t，求最大价值 cin &gt;&gt; m &gt;&gt; s; vector&lt;int&gt; weight; vector&lt;int&gt; value; for (int i = 0; i &lt; m; i++)&#123; int t1, t2; cin &gt;&gt; t1 &gt;&gt; t2; weight.push_back(t1); value.push_back(t2); &#125; int res = ZeroOnePack(m, s, weight, value); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 算法详解","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"},{"name":"CodeCode","slug":"CodeCode","permalink":"http://yoursite.com/categories/CodeCode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"},{"name":"大整数计算","slug":"大整数计算","permalink":"http://yoursite.com/tags/大整数计算/"},{"name":"编辑距离","slug":"编辑距离","permalink":"http://yoursite.com/tags/编辑距离/"},{"name":"Kmp","slug":"Kmp","permalink":"http://yoursite.com/tags/Kmp/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://yoursite.com/tags/Dijkstra/"},{"name":"0/1背包","slug":"0-1背包","permalink":"http://yoursite.com/tags/0-1背包/"}]},{"title":"刷题汇总（二）剑指Offer 66题 C++答案总结","slug":"23","date":"2019-08-01T03:32:27.000Z","updated":"2019-12-18T04:18:44.657Z","comments":true,"path":"2019/08/01/23/","link":"","permalink":"http://yoursite.com/2019/08/01/23/","excerpt":"题目来源 剑指Offer 66题 相关：刷题汇总（一）leetcode 精选50题 JavaScript答案总结刷题汇总（三）leetcode 精选50题 C++答案总结刷题汇总（四）技术类编程题汇总 C++刷题汇总（五）leetcode 热题 HOT 100 C++ 答案总结刷题汇总（六）leetcode 多线程 / Shell PDF版 code （提取码：0wxr ） 1、二维数组中的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。","text":"题目来源 剑指Offer 66题 相关：刷题汇总（一）leetcode 精选50题 JavaScript答案总结刷题汇总（三）leetcode 精选50题 C++答案总结刷题汇总（四）技术类编程题汇总 C++刷题汇总（五）leetcode 热题 HOT 100 C++ 答案总结刷题汇总（六）leetcode 多线程 / Shell PDF版 code （提取码：0wxr ） 1、二维数组中的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345678910111213141516171819/* 3 4 5 4 5 6 6 7 8 从左下角开始查找，当target比左下角数字大时，右移；小时，上移*/class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int rows = array.size(), cols = array[0].size(); int i = rows - 1, j = 0; while(i&gt;=0&amp;&amp;j&lt;cols)&#123; if(array[i][j] == target) return true; else if(array[i][j] &gt; target) i--; else j++; &#125; return false; &#125;&#125;; 2、替换空格请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 1234567891011121314151617181920212223242526/* 从前往后替换，后面的字符要多次移动，效率低下 从后往前，先计算需要多少空间，每个字符只移动一次，效率更高 例如：a b c 从后往前，当前第i位为'c'（非空格），前有n个空格，则i+2*n位为c 当前第i位为' '（空格）,前有n个空格，则i+2*n位为%，i+2*n+1位为2，i+2*n+2位为0*/class Solution &#123;public: void replaceSpace(char *str,int length) &#123; int sum = 0; for(int i=0;i&lt;length;i++)&#123; if(str[i] == ' ') sum++; &#125; for(int i=length-1;i&gt;=0;i--)&#123; if(str[i] != ' ') str[i + 2*sum] = str[i]; else&#123; sum--; str[i + 2*sum] = '%'; str[i + 2*sum + 1] = '2'; str[i + 2*sum + 2] = '0'; &#125; &#125; &#125;&#125;;` 3、从尾到头打印链表输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 12345678910111213141516171819202122232425/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; res; stack&lt;int&gt; stack; while(head)&#123; stack.push(head-&gt;val); head = head-&gt;next; &#125; while(!stack.empty())&#123; res.push_back(stack.top()); stack.pop(); &#125; return res; &#125;&#125;; 4、重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 12345678910111213141516171819202122232425262728293031323334/* 前序遍历序列&#123;1,2,4,7,3,5,6,8&#125; 1是根元素 中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; 1之前4,7,2是左子树中序，之后5,3,8,6是右子树中序 前序中1后的3个是左子树前序，之后是右子树前序 问题转换为根元素已知，求左子树和右子树的重建二叉树，进行递归*//** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; return buildtree(pre,vin,0,pre.size()-1,0,vin.size()-1); &#125; TreeNode* buildtree(vector&lt;int&gt; pre,vector&lt;int&gt; vin,int pl,int pr,int vl,int vr) &#123; if(pl &gt; pr || vl &gt; vr) return NULL; TreeNode* root = new TreeNode(pre[pl]); int i; for(i=vl;i&lt;=vr;i++)&#123; if(vin[i] == pre[pl]) break; &#125; int num = i - vl; //左子树个数 root-&gt;left = buildtree(pre,vin,pl+1,pl+num,vl,vl+num-1); root-&gt;right = buildtree(pre,vin,pl+num+1,pr,vl+num+1,vr); return root; &#125;&#125;; 5、用两个栈实现队列用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 12345678910111213141516171819202122232425262728293031323334/* 用两个栈实现一个队列的功能 入队：将元素进栈A 出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈； 如果不为空，栈B直接出栈。 用两个队列实现一个栈的功能 入栈：将元素进队列A 出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素依次出队列并放入队列B，直到队列A中的元素留下一个，然后队列A出队列，再把队列B中的元素出队列以此放入队列A中。*/class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; while(!stack1.empty())&#123; stack2.push(stack1.top()); stack1.pop(); &#125; int res = stack2.top(); stack2.pop(); while(!stack2.empty())&#123; stack1.push(stack2.top()); stack2.pop(); &#125; return res; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; 6、旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 1234567891011121314151617181920class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; if(rotateArray.size() == 0) return 0; int i = 0, j = rotateArray.size()-1; while(i &lt; j)&#123; int mid = (i + j)/2; if(rotateArray[mid] &gt; rotateArray[j])&#123; i = mid + 1; //3 4 7 8 1 2 旋转点在右，左顺序 &#125; else if(rotateArray[mid] &lt; rotateArray[j])&#123; j = mid; //7 8 1 2 3 4 旋转点在左，右顺序 &#125; else&#123; //1 0 1 1 1 或 1 1 1 0 1 顺序部分为常数 i ++; //或 j --; &#125; &#125; return rotateArray[i]; &#125;&#125;; 7、斐波那契数列大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 12345678910111213class Solution &#123;public: int Fibonacci(int n) &#123; //0 1 1 2 3 5 …,使用动态规划 int i = 0, j = 1; while(n&gt;0)&#123; int tmp = j; j = i+j; i = tmp; n--; &#125; return i; &#125;&#125;; 8、跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 123456789101112131415161718/* 最后一步跳1，有f(n-1)种情况 最后一步跳2，有f(n-2)种情况 共f(n)=f(n-1)+f(n-2)，1 1 2 3 5（斐波那契数列）使用动态规划*/class Solution &#123;public: int jumpFloor(int number) &#123; int i = 1, j = 1; while(number&gt;0)&#123; int tmp = j; j = i + j; i = tmp; number--; &#125; return i; &#125;&#125;; 9、变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 1234567891011121314151617181920212223242526272829//f(n) = f(1) + f(2) + f(3) +...+ f(n-1) + 1//1 2 4 8 ...class Solution &#123;public: int jumpFloorII(int number) &#123; vector&lt;int&gt; step; while(number&gt;0)&#123; int sum = 0; for(int i=0;i&lt;step.size();i++)&#123; sum += step[i]; &#125; step.push_back(sum+1); number--; &#125; return step.back(); &#125;&#125;;/*class Solution &#123;public: int jumpFloorII(int number) &#123; int res = 1; for(int i=1;i&lt;number;i++)&#123; res += jumpFloorII(i); &#125; return res; &#125;&#125;;*/ 10、矩形覆盖我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 12345678910111213141516171819202122/*| | | | f(n-1)| | | | — — | | f(n-2)— — | |f(n) = f(n-1) + f(n-2),1 2 3 5 8…,动态规划*/class Solution &#123;public: int rectCover(int number) &#123; if(number == 0) return 0; int i = 1, j = 1; while(number&gt;0)&#123; int tmp = j; j = i + j; i = tmp; number--; &#125; return i; &#125;&#125;; 11、二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 1234567891011121314151617181920212223242526/* 将n与n-1相与会把n的最右边的1变为0，比如 1100&amp;1011 = 1000*/class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; while(n!=0)&#123; res++; n = n&amp;(n-1); &#125; return res; &#125;&#125;;/* #include &lt;bitset&gt;*/class Solution &#123;public: int NumberOf1(int n) &#123; bitset&lt;32&gt;a(n); //32位的2进制 return a.count(); //返回1的个数 &#125;&#125;; 12、数值的整数次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 12345678910111213141516171819/* 10^1101 = 10^0001*10^0100*10^1000，即base*1 * base^2 * base^4 * … 通过&amp;1和&gt;&gt;1来逐位读取1101*/class Solution &#123;public: double Power(double base, int exponent) &#123; double res = 1; int e = abs(exponent); while(e!=0)&#123; if(e&amp;1 == 1)&#123; res *= base; &#125; base *= base; e = e&gt;&gt;1; &#125; return exponent&gt;0?res:1/res; &#125;&#125;; 13、调整数组顺序使奇数位于偶数前面输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 12345678910111213141516171819202122232425/* 要想保证原有次序，则只能顺次移动或相邻交换。 1.i从左向右遍历，找到第一个偶数。 2.j从i+1开始向后找，找到第一个奇数。 3.将[i,...,j-1]的元素整体后移一位，将找到的奇数放入i位置*/class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; for(int i=0;i&lt;array.size();i++)&#123; if(array[i]%2 == 0)&#123; for(int j=i+1;j&lt;array.size();j++)&#123; if(array[j]%2 == 1)&#123; int tmp = array[j]; for(int k=j-1;k&gt;=i;k--)&#123; array[k+1] = array[k]; &#125; array[i] = tmp; break; &#125; &#125; &#125; &#125; &#125;&#125;; 14、链表中倒数第k个结点输入一个链表，输出该链表中倒数第k个结点。 123456789101112131415161718192021222324252627282930/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*//* 两指针指向头结点， 第一个指针走(k-1)步，到k节点 两个指针同时往后移动，当第一个结点到达末尾的时候，第二个结点所在位置就是倒数第k个节点*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; if(!pListHead || k==0) return NULL; ListNode* node1 = pListHead; ListNode* node2 = pListHead; int i = 0; while(node1)&#123; if(i&gt;=k)&#123; node2 = node2 -&gt; next; &#125; node1 = node1 -&gt; next; i++; &#125; return i&lt;k ? NULL : node2; &#125;&#125;; 15、反转链表输入一个链表，反转链表后，输出新链表的表头。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*//*1 2 3 4 5遍历链表，当前值为4时，相当于新建值为4的链表node，node-&gt;next = 前面链表反转，node即为所求当前值为5时，相当于新建值为5的链表node，node-&gt;next = 上一步的值*/class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; ListNode* res = NULL; while(pHead)&#123; ListNode* tmp = new ListNode(pHead-&gt;val); tmp -&gt; next = res; res = tmp; pHead = pHead -&gt; next; &#125; return res; &#125;&#125;;//原地修改/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; ListNode* res = NULL; while(pHead)&#123; ListNode* tmp = pHead-&gt;next; pHead-&gt;next = res; res = pHead; pHead = tmp; &#125; return res; &#125;&#125;; 16、合并两个排序的链表输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 1234567891011121314151617181920212223242526272829/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; ListNode* res = new ListNode(0);//初始化，取几不重要 ListNode* here = res; //标记位置 while(pHead1 &amp;&amp; pHead2)&#123; if(pHead1-&gt;val &lt; pHead2-&gt;val)&#123; res -&gt; next = pHead1; pHead1 = pHead1 -&gt; next; &#125; else&#123; res -&gt; next = pHead2; pHead2 = pHead2 -&gt; next; &#125; res = res -&gt; next; &#125; res -&gt; next = pHead1 ? pHead1:pHead2; return here-&gt;next; &#125;&#125;; 17、树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 123456789101112131415161718192021222324252627282930/*/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; if(pRoot1 &amp;&amp; pRoot2)&#123; return issub(pRoot1,pRoot2)|| HasSubtree(pRoot1-&gt;left,pRoot2)|| HasSubtree(pRoot1-&gt;right,pRoot2); &#125; return false; &#125; bool issub(TreeNode* l1, TreeNode* l2) &#123; if(l2)&#123; return l1&amp;&amp; l1-&gt;val==l2-&gt;val&amp;&amp; issub(l1-&gt;left,l2-&gt;left)&amp;&amp; issub(l1-&gt;right,l2-&gt;right); &#125; return true; &#125;&#125;; 18、二叉树的镜像操作给定的二叉树，将其变换为源二叉树的镜像。 12345678910111213二叉树的镜像定义： 源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 1234567891011121314151617181920/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if(!pRoot) return; TreeNode *tmp = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = tmp; Mirror(pRoot-&gt;left); Mirror(pRoot-&gt;right); &#125;&#125;; 19、顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 123456789101112131415161718192021222324252627/* m n i 1 2 3 4 5 6 j 7 8 9*/class Solution &#123;public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; vector&lt;int&gt; res; int i = 0,j = matrix.size()-1,m = 0,n = matrix[0].size()-1; while(i&lt;=j &amp;&amp; m&lt;=n)&#123; for(int k=m;k&lt;=n;k++) res.push_back(matrix[i][k]); i++;//削首行 if(i&gt;j) break; for(int k=i;k&lt;=j;k++) res.push_back(matrix[k][n]); n--;//削尾列 if(m&gt;n) break; for(int k=n;k&gt;=m;k--) res.push_back(matrix[j][k]); j--;//削尾行 if(i&gt;j) break; for(int k=j;k&gt;=i;k--) res.push_back(matrix[k][m]); m++;//削首列 &#125; return res; &#125;&#125;; 20、包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 1234567891011121314151617181920212223242526272829/* 用stack1保存数据，用stack2做辅助栈保存依次入栈最小的数 stack1:5, 4, 3, 8, 10, 11, 12, 1 stack2:5, 4, 3,no, no, no, no, 1 no代表此次不入栈 入栈，如果stack1的压入比stack2压入大，stack2不压;小于等于，两栈同时压入 出栈，如果两栈顶元素不等，stack1出，stack2不出;相等，都出*/class Solution &#123;public: stack&lt;int&gt; stack1,stack2; void push(int value) &#123; stack1.push(value); if(stack2.empty()) stack2.push(value); else&#123; if(value &lt;= stack2.top()) stack2.push(value); &#125; &#125; void pop() &#123; if(stack1.top() == stack2.top()) stack2.pop(); stack1.pop(); &#125; int top() &#123; return stack1.top(); &#125; int min() &#123; return stack2.top(); &#125;&#125;; 21、栈的压入、弹出序列输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 123456789101112131415class Solution &#123;public: bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; stack&lt;int&gt; s; int k = 0,len = pushV.size(); for(int i=0;i&lt;len;i++)&#123; s.push(pushV[i]); while(k&lt;len &amp;&amp; popV[k] == s.top())&#123; s.pop(); k++; &#125; &#125; return s.empty(); &#125;&#125;; 22、从上往下打印二叉树从上往下打印出二叉树的每个节点，同层节点从左至右打印。 123456789101112131415161718192021222324/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; vector&lt;int&gt; res; queue&lt;TreeNode* &gt; q; if(root) q.push(root); while(!q.empty())&#123; if(q.front()-&gt;left) q.push(q.front()-&gt;left); if(q.front()-&gt;right) q.push(q.front()-&gt;right); res.push_back(q.front()-&gt;val); q.pop(); &#125; return res; &#125;&#125;; 23、二叉搜索树的后序遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 12345678910111213141516171819/* 二叉搜索树BST 左子树值都比root小，右子树值都比root大。 去掉最后一个元素root，其他分成两段: 前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是BST的后序遍历*/class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if(sequence.size()==0) return false; return isok(sequence,0,sequence.size()-1); &#125; bool isok(vector&lt;int&gt; arr,int l,int r) &#123; if(l &gt;= r) return true; int i=l; while(i&lt;r &amp;&amp; arr[i]&lt;arr[r]) i++; //找到满足BST的右子树开头 for(int j=i;j&lt;r;j++) if(arr[j] &lt; arr[r]) return false; //判断剩下是否为右子树 return isok(arr,l,i-1)&amp;&amp; isok(arr,i,r-1); &#125; &#125;; 24、二叉树中和为某一值的路径输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 1234567891011121314151617181920212223242526/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123; if(root) helper(root,expectNumber); return res; &#125; void helper(TreeNode* root,int n) &#123; if(!root) return; tmp.push_back(root-&gt;val); if(root-&gt;val == n &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) res.push_back(tmp); helper(root-&gt;left,n-root-&gt;val); helper(root-&gt;right,n-root-&gt;val); tmp.pop_back(); &#125;&#125;; 25、复杂链表的复制输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*//* 复制节点，如：复制节点A得到A1，将A1插入节点A后面 复制random，遍历链表，A1-&gt;random = A-&gt;random-&gt;next; 将链表拆分成原链表和复制后的链表*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; if(!pHead) return NULL; RandomListNode* cur = pHead;//从头复制节点 A-&gt;B-&gt;C 变成A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C' while(cur)&#123; RandomListNode* copynode = new RandomListNode(cur-&gt;label); copynode -&gt; next = cur -&gt; next; cur-&gt;next = copynode; cur = cur -&gt; next -&gt; next; &#125; cur = pHead;//从头复制random,A1-&gt;random = A-&gt;random-&gt;next; while(cur)&#123; if(cur -&gt; random) cur -&gt; next -&gt; random = cur -&gt; random -&gt; next; cur = cur -&gt; next -&gt; next; &#125; cur = pHead;//从头将链表拆分成原链表和复制后的链表 RandomListNode* res = cur -&gt; next; //复制后的链表,标记位置 RandomListNode* tmp; while(cur -&gt; next)&#123; tmp = cur -&gt; next; cur -&gt; next = tmp -&gt; next; cur = tmp; &#125; return res; &#125;&#125;; 26、二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 12345678910111213141516171819202122232425262728293031323334/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: //树的线索化，利用了二叉树结点中的空指针，让它们分别指向本结点的前驱或者后继 TreeNode* head = NULL; TreeNode* res = NULL; TreeNode* Convert(TreeNode* pRootOfTree) &#123; if(!pRootOfTree) return NULL; helper(pRootOfTree); return res; &#125; void helper(TreeNode* root) &#123; if(!root) return; helper(root-&gt;left); if(!head)&#123; //中序遍历第一个，即树的左下角 head = root; res = root; &#125; else&#123; head -&gt; right = root; root -&gt; left = head; head = root; &#125; helper(root-&gt;right); &#125; &#125;; 27、字符串的排列输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 12345678910111213141516171819202122232425262728293031/* 问题转换为先固定第一个字符，求剩余字符的排列 再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合 a b b c: a+f(bbc),b+f(abc),c+f(abb); 遍历出所有可能出现在第一个位置的字符 f(bbc)=b+f(bc),b+f(bc),c+f(bb); f(bc)=b+f(c),c+f(b); f(c)=c;*/class Solution &#123;public: vector&lt;string&gt; res; vector&lt;string&gt; Permutation(string str) &#123; if(str.empty()) return res; help(str,0); sort(res.begin(),res.end()); return res; &#125; void help(string s,int n) &#123; if(n==s.size()-1)&#123; if(find(res.begin(),res.end(),s)==res.end()) res.push_back(s); &#125; else&#123; for(int i=0;i&lt;s.size();i++)&#123; swap(s[i],s[n]); help(s,n+1); swap(s[n],s[i]); &#125; &#125; &#125;&#125;; 28、数组中出现次数超过一半的数字数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 如果重复的次数超过一半的话，一定有相邻的数字相同这种情况的 对数组同时去掉两个不同的数字，到最后剩下的一个数就是该数字*/class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if(numbers.empty()) return 0; int res = numbers[0]; int times = 0; for(int i=0;i&lt;numbers.size();i++)&#123; if(numbers[i] == res) times++; else&#123; times--; if(times == 0)&#123; res = numbers[i]; times = 1; &#125; &#125; &#125; //check times = 0; for(int i=0;i&lt;numbers.size();i++)&#123; if(numbers[i] == res) times++; &#125; return times&gt;numbers.size()/2?res:0; &#125;&#125;;/* 涉及到快排sort，其时间复杂度为O(NlogN)并非最优class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; // 因为用到了sort，时间复杂度O(NlogN)，并非最优 if(numbers.empty()) return 0; sort(numbers.begin(),numbers.end()); int middle = numbers[numbers.size()/2];//假设存在众数may //check int count=0; // 出现次数 for(int i=0;i&lt;numbers.size();++i) &#123; if(numbers[i]==middle) ++count; &#125; return (count&gt;numbers.size()/2) ? middle : 0; &#125;&#125;;*/ 29、最小的k个数输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 12345678910111213141516171819202122232425262728/* 基于堆排序算法，构建最大堆。时间复杂度为O(nlogk) 用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，新数入堆 如果用快速排序，时间复杂度为O(nlogn)；*/class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; vector&lt;int&gt; res; priority_queue&lt;int&gt; q; //priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q;最小堆 if(input.empty() || k&gt;input.size() || k==0) return res; for(int i=0;i&lt;input.size();i++)&#123; if(i&lt;k) q.push(input[i]); else&#123; if(input[i] &lt; q.top())&#123; q.pop(); q.push(input[i]); &#125; &#125; &#125; while(!q.empty())&#123; res.push_back(q.top()); q.pop(); &#125; return res; &#125;&#125;; 30、连续子数组的最大和HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 12345678910111213class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; int res = array[0]; int max = 0; for(int i=0;i&lt;array.size();i++)&#123; max += array[i]; if(max &gt; res) res = max; if(max &lt; 0) max = 0; &#125; return res; &#125;&#125;; 31、整数中1出现的次数求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 12345678910111213141516171819202122232425262728293031/* n=10917 1~10917 所有数里在个位的1的数量： 前面为0~1090，个位后无，排列组合共1*1091种情况；前面为1091时，个位后为1。总共：1*1091+1(m=1，情况3) 所有数里在十位的1的数量： 前面为0~108，十位后为0~9，排列组合共10*109种情况；前面为109时，十位后为0~7。总共：10*109+8(m=8，情况2) 所有数里在百位的1的数量： 前面为0~9，百位后为0~99，排列组合共100*10种情况；前面为10时，百位后为0~99。总共：100*10+100(m=100，情况3) 所有数里在千位的1的数量： 前面为0~0，千位后为0~999，排列组合共1000*1种情况；前面为1时，千位后没有满足的。总共：1000*1+0(m=0，情况1) 所有数里在万位的1的数量： 前面为无，万位后为0~917。总共：1000*0+918(m=918，情况2) 精髓在于后面部分m值分三种情况： ①当前位为0时，m=0；②当前位为1时，m=后面值+1；③当前位为2~9时，m=10^(后面的位数)*/class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; if(n == 0) return 0; int res = 0; int base = 1,t = n,m; while(t!=0)&#123; if(t%10 == 0) m = 0; else if(t%10 == 1) m = n-t*base+1; else m = base; t/=10; res+=base*t+m; base*=10; &#125; return res; &#125;&#125;; 32、把数组排成最小的数输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 1234567891011121314151617class Solution &#123;public: //sort中的比较函数compare要声明为静态成员函数或全局函数，不能作为普通成员函数 string PrintMinNumber(vector&lt;int&gt; numbers) &#123; string res = \"\"; sort(numbers.begin(),numbers.end(),cmp); for(int i=0;i&lt;numbers.size();i++)&#123; res += to_string(numbers[i]); &#125; return res; &#125; static bool cmp(int &amp;i,int &amp;j) &#123; string si = to_string(i); string sj = to_string(j); return si+sj&lt;sj+si; // 2 23和23 2 &#125;&#125;; 33、丑数把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 1234567891011121314151617181920/* 如果p是丑数，那么p=2^x * 3^y * 5^z, 且x,y,z需满足是前面的丑数 初始x=y=z=1， 2^x、3^y、5^z最小的数2^x加进结果，x在结果中位置后移一位*/class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if(index &lt; 7) return index; vector&lt;int&gt; res(index); res[0] = 1; int x=0, y=0, z=0; for(int i=1;i&lt;index;i++)&#123; res[i] = min(min(res[x]*2,res[y]*3),res[z]*5); if(res[i] == res[x]*2) x++; if(res[i] == res[y]*3) y++; if(res[i] == res[z]*5) z++; &#125; return res[index-1]; &#125;&#125;; 34、第一个只出现一次的字符在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 123456789101112131415class Solution &#123;public: int FirstNotRepeatingChar(string str) &#123; //字符在计算机中以ASCII码的形式存储，当字符作为数组下标时，其表示的下标值为该字符的ASCII码的十进制值 //0-9: 48-57， A-Z: 65-90， a-z: 97-122 map&lt;char,int&gt; map; //map支持int，char，string for(int i=0;i&lt;str.size();i++)&#123; map[str[i]]++; &#125; for(int i=0;i&lt;str.size();i++)&#123; if(map[str[i]] == 1) return i; &#125; return -1; &#125;&#125;; 35、数组中的逆序对在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 12345678910输入描述:题目保证输入的数组中没有的相同的数字数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5示例:输入 1,2,3,4,5,6,7,0输出 7 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目 在统计逆序对的过程中，还需要对数组进行排序,每一次比较的时候 都把较大的数字从后面往前复制到一个辅助数组中，确保辅助数组copy中的数字是递增排序的 交换copy和data:在每次的操作中，当前传入函数中第一项，比较的结果都存放到第二项中,需要交叉保证下一次是排序的 输入[7,5,6,4], 最后的结果copy[4,5,6,7], data[5,7,4,6]*/class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; if(data.size()==0) return 0; vector&lt;int&gt;copy(data); //使用data初始化copy long long P = InversePairsCore(data,copy,0,data.size()-1); return P%1000000007; &#125; long long InversePairsCore(vector&lt;int&gt; &amp;data,vector&lt;int&gt; &amp;copy,int l,int r) &#123; if(l == r)&#123; copy[l] = data[l]; return 0; &#125; int mid = (l+r)/2; long long left = InversePairsCore(copy,data,l,mid); long long right = InversePairsCore(copy,data,mid+1,r); int i = mid,j = r; long long count = 0; //需要long long,int的话最后一个例子会溢出测试不通过 int cur = r; while(i&gt;=l &amp;&amp; j&gt;=mid+1)&#123; if(data[i]&gt;data[j])&#123; //3 8,4 6 8&gt;6 count += j-mid; copy[cur--] = data[i]; i--; &#125; else&#123; copy[cur--] = data[j]; j--; &#125; &#125; while(i&gt;=l)&#123; copy[cur--] = data[i]; i--; &#125; while(j&gt;=mid+1)&#123; copy[cur--] = data[j]; j--; &#125; return left+right+count; &#125;&#125;; 36、两个链表的第一个公共节点输入两个链表，找出它们的第一个公共结点。 1234567891011121314151617181920212223242526272829303132333435363738/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123; //找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走 int len1 = getlen(pHead1); int len2 = getlen(pHead2); int dis = len1-len2&gt;0?len1-len2:len2-len1; while(dis!=0)&#123; if(len1&gt;len2) pHead1 = pHead1-&gt;next; else pHead2 = pHead2-&gt;next; dis--; &#125; while(pHead1)&#123; if(pHead1 == pHead2) return pHead1; pHead1 = pHead1-&gt;next; pHead2 = pHead2-&gt;next; &#125; return NULL; &#125; int getlen(ListNode* p) &#123; int res = 0; ListNode* root = p; while(root)&#123; res++; root = root-&gt;next; &#125; return res; &#125;&#125;; 37、数字在排序数组中出现的次数统计一个数字在排序数组中出现的次数。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; if(data.empty()) return 0; int l=0,r=data.size()-1; while(l&lt;=r)&#123; int mid = (l+r)/2; if(data[mid]==k)&#123; //计数 int res=0,i=mid; while(i&gt;=l)&#123; if(data[i]==k)&#123; i--; res++; &#125; else break; &#125; i=mid+1; while(i&lt;=r)&#123; if(data[i]==k)&#123; i++; res++; &#125; else break; &#125; return res; &#125; else if(data[mid] &gt; k) r=mid-1; else l=mid+1; &#125; return 0; &#125;&#125;; 38、二叉树的深度输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 12345678910111213141516/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int TreeDepth(TreeNode* pRoot) &#123; if(!pRoot) return 0; return max(TreeDepth(pRoot-&gt;left),TreeDepth(pRoot-&gt;right))+1; &#125;&#125;; 39、平衡二叉树输入一棵二叉树，判断该二叉树是否是平衡二叉树。 1234567891011121314class Solution &#123;public: //左右子树均为平衡二叉树，且左右子树层高不超过1 bool IsBalanced_Solution(TreeNode* pRoot) &#123; if(!pRoot) return true; return IsBalanced_Solution(pRoot-&gt;left) &amp;&amp; IsBalanced_Solution(pRoot-&gt;right) &amp;&amp; abs(getlen(pRoot-&gt;left)-getlen(pRoot-&gt;right))&lt;=1; &#125; int getlen(TreeNode* p)&#123; if(!p) return 0; return max(getlen(p-&gt;left),getlen(p-&gt;right))+1; &#125;&#125;; 40、数组中只出现一次的数字一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 12345678910111213141516171819202122232425262728/* 异或性质： 交换律：a ^ b ^ c &lt;=&gt; a ^ c ^ b,俩两相同的移到一起 相同的数异或为0: n ^ n =&gt; 0 任何数于0异或为任何数 0 ^ n =&gt; n 遍历异或后，只剩下两单个的异或了，结果res的二进制至少有一位为1 取第一个1所在的位数index，原数组分成第index位为1和为0 相同的数肯定在一个组，两个单的在不同的组*/class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int add = 0; for(int i=0;i&lt;data.size();i++)&#123; add ^= data[i]; &#125; int index = 0; while((add&amp;1)==0)&#123; add = add &gt;&gt; 1; index++; &#125; for(int i=0;i&lt;data.size();i++)&#123; if((data[i]&gt;&gt;index&amp;1)==0) num1[0]^=data[i]; else num2[0]^=data[i]; &#125; &#125;&#125;; 41、和为S的连续正数序列小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述:输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; part; int i = 1,j = 2; while(i &lt; j)&#123; int count = (i+j)*(j-i+1)/2; //i~j的和 if(count == sum)&#123; //将i~j插入res part.clear(); for(int k=i;k&lt;=j;k++)&#123; part.push_back(k); &#125; res.push_back(part); i++; &#125; else if(count &lt; sum) j++; //右窗口右移 else i++; //左窗口右移 &#125; return res; &#125;&#125;; 42、和为S的两个数字输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。输出描述:对应每个测试案例，输出两个数，小的先输出。 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; vector&lt;int&gt; res; int i = 0, j = array.size()-1; while(i&lt;j)&#123; if(array[i]+array[j] == sum)&#123; //1 3 4 6,1*6&lt;3*4,越边边乘积越小 res.push_back(array[i]); res.push_back(array[j]); break; &#125; else if(array[i]+array[j] &gt; sum) j--; else i++; &#125; return res; &#125;&#125;; 43、左旋转字符串汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 12345678class Solution &#123;public: string LeftRotateString(string str, int n) &#123; if(str.empty()) return \"\"; n%=str.size(); return str.substr(n)+str.substr(0,n); &#125;&#125;; 44、翻转单词顺序列牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 123456789101112131415161718192021class Solution &#123;public: string ReverseSentence(string str) &#123; string res; stack&lt;string&gt; stack; string tmp; for(int i=0;i&lt;str.size();i++)&#123; if(str[i] == ' ')&#123; stack.push(tmp); tmp.clear(); &#125; else tmp.push_back(str[i]); &#125; stack.push(tmp); while(!stack.empty())&#123; res += ' ' + stack.top(); stack.pop(); &#125; return res.erase(0,1); &#125;&#125;; 45、扑克牌顺子LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 123456789101112131415161718192021222324/* max 记录 最大值,min 记录 最小值,min ,max 都不记0 满足条件 max - min &lt;5;除0外没有重复的数字(牌);数组长度 为5*/class Solution &#123;public: bool IsContinuous( vector&lt;int&gt; numbers ) &#123; // 5张牌 if(numbers.size()!=5) return false; int max = -1, min = 14; int* flag = new int[14](); //初始化数组全为 0 for(int i=0;i&lt;numbers.size();i++)&#123; if(numbers[i] == 0) continue; int tmp = numbers[i]; if(flag[tmp] == 1) return false; //重复 else&#123; if(tmp &lt; min) min = tmp; if(tmp &gt; max) max = tmp; flag[tmp] = 1; &#125; &#125; delete[] flag; return max-min&lt;5; &#125;&#125;; 46、孩子们的游戏（圆圈中最后剩下的数）每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 1234567891011121314151617181920class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if (m == 0 || n == 0) return -1; int* flag = new int[n]();//初始化数组全为 0 int i = -1,left = n,step = 0; while(left&gt;0)&#123; i++; //0 if(i == n) i = 0; //模拟环 if(flag[i] == 1) continue; //跳过被删除的对象 step++; if(step == m)&#123; step = 0; flag[i] = 1; left--; &#125; &#125; return i; &#125;&#125;; 47、求1+2+3+…+n求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 1234567891011121314151617/* int Sum_Solution(int n) &#123; if(n == 0) return 0; return n+Sum_Solution(n-1); &#125; 将此段代码改写成不使用for、while、if、else、switch、case等关键字及条件判断语句*/class Solution &#123;public: int Sum_Solution(int n) &#123; int res = n; res &amp;&amp; (res+=Sum_Solution(n-1)); //当n==0时，只执行前面的判断，为false，然后直接返回0； //当n&gt;0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n) return res; &#125;&#125;; 48、不用加减乘除做加法写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 12345678910111213141516/* 两数相与再左移一位，表示相加进位的值 101&amp;111=101 左移1，1010 两数异或，表示相加不算进位的值 101^111=010 两者相加为和，(101&amp;111)&lt;&lt;1 + 101^111 = 1100,即调用函数本身，直到进位为0*/class Solution &#123;public: int Add(int num1, int num2) &#123; while(num2!=0)&#123; int tmp = num1^num2; //相加不算进位的值 num2 = (num1&amp;num2)&lt;&lt;1; //相加进位的值 num1 = tmp; &#125; return num1; &#125;&#125;; 49、把字符串转换成整数将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。输入描述:输入一个字符串,包括数字字母符号,可以为空输出描述:如果是合法的数值表达则返回该数字，否则返回0 输入: +2147483647 , 1a33输出: 2147483647 , 0 1234567891011121314151617181920212223242526/* 字符\"0123456789\"的值是连续的，如果c\"0123456789\"范围内 int a = c - '0'就是对应整数值 从后往前，最后判断符号位*/class Solution &#123;public: int StrToInt(string str) &#123; if(str.empty()) return 0; int res = 0,base = 1; for(int i = str.size()-1;i&gt;=0;i--)&#123; if(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')&#123; res += base*(int)(str[i]-'0'); base *= 10; &#125; else if(str[i] == '-')&#123; if(i == 0) return -res; //-123 &#125; else if(str[i] == '+')&#123; if(i == 0) return res; //+123 &#125; else return 0; //1a3 &#125; return res; //123 &#125;&#125;; 50、数组中重复的数字在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 1234567891011121314151617181920212223242526/* 数字的范围保证在0 ~ n-1 之间，所以可以利用现有数组设置标志 当一个数字i被访问过后，可以设置对应位上的数numbers[i] += n 再次访问i时，发现numbers[i] &gt;=n，直接返回i*/class Solution &#123;public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate(int numbers[], int length, int* duplication) &#123; for(int i=0;i&lt;length;i++)&#123; //2,3,1,0,2,5,3 int cur = numbers[i]; if(cur &gt;= length) cur = cur-length; if(numbers[cur] &gt;= length)&#123; *duplication = cur; return true; &#125; numbers[cur] += length; &#125; return false; &#125;&#125;; 51、构建乘积数组给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 12345678910111213141516171819202122232425262728293031/* 1 第一项左侧 a[0] 第二项左侧 a[0]*a[1] a[0]*a[1]*a[2] a[0]*a[1]*a[2]...*a[n-2] 第n项左侧 1 第n项右侧 a[n-1] a[n-1]*a[n-2] a[n-1]*a[n-2]*a[n-3]...*a[2] 第二项左侧 a[n-1]*a[n-2]*a[n-3]...*a[1] 第一项右侧*/class Solution &#123;public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt; res; if(A.empty()) return res; int tmp = 1; for(int i=0;i&lt;A.size();i++)&#123; //左边乘 res.push_back(tmp); tmp *= A[i]; &#125; tmp = 1; for(int i=A.size()-1;i&gt;=0;i--)&#123; //右边乘 res[i] *= tmp; tmp *= A[i]; &#125; return res; &#125;&#125;; 52、正则表达式匹配请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 1234567891011121314151617181920212223242526272829303132/* 当第二个字符不是“*”时： 1、第一个字符匹配，字符串和模式后移1个字符，继续匹配 2、第一个字符不匹配，返回false 当第二个字符是“*”时： 1、第一个字符不匹配，模式后移2个字符，继续匹配 2、第一个字符匹配，可以有3种情况： （1）模式后移2字符，相当于x*被忽略，x出现0次； （2）字符串后移1字符，模式后移2字符，相当于x出现一次； （3）字符串后移1字符，模式不变，相当于x出现多次次； 注：匹配指值相同，或pattern为'.',字符串未到尾*/class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(*str == '\\0' &amp;&amp; *pattern == '\\0') return true; if(*str != '\\0' &amp;&amp; *pattern == '\\0') return false; if(*(pattern+1) != '*')&#123; if(*str==*pattern || *pattern=='.'&amp;&amp;*str!='\\0')&#123; return match(str+1,pattern+1); &#125; else return false; &#125; else&#123; if(*str==*pattern || *pattern=='.'&amp;&amp;*str!='\\0')&#123; return match(str,pattern+2)|| match(str+1,pattern+2)|| match(str+1,pattern); &#125; else return match(str,pattern+2); &#125; &#125;&#125;; 53、表示数值的字符串请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 123456789101112131415161718192021222324252627282930313233343536/* 1、+、- 第一次出现+-符号，且不在首位，必须紧接在e之后 第二次出现+-符号，必须紧接在e之后 2、e、E e后不为空 不能双e 3、. .前不能有.或e 4、其他 return false*/class Solution &#123;public: bool isNumeric(char* string) &#123; // 标记符号、小数点、e是否出现过 bool hasSign = false, hasPoint = false, hasE = false; for(int i=0;string[i];i++)&#123; if(string[i] == '+' || string[i] == '-')&#123; if(!hasSign &amp;&amp; i&gt;0 &amp;&amp; string[i-1]!='e' &amp;&amp; string[i-1]!='E') return false; if(hasSign &amp;&amp; string[i-1]!='e' &amp;&amp; string[i-1]!='E') return false; hasSign = true; &#125; else if(string[i] == 'e' || string[i] == 'E')&#123; if(string[i+1] == '\\0' || hasE) return false; hasE = true; &#125; else if(string[i] == '.')&#123; if(hasPoint || hasE) return false; hasPoint = true; &#125; else if(string[i] &lt; '0' || string[i] &gt; '9') return false; &#125; return true; &#125;&#125;; 54、字符流中第一个不重复的字符请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。输出描述:如果当前字符流没有存在出现一次的字符，返回#字符。 123456789101112131415161718192021/* 字符在计算机中以ASCII码的形式存储，当字符作为数组下标时，其表示的下标值为该字符的ASCII码的十进制值 0-9: 48-57 ,A-Z: 65-90 ,a-z: 97-122 ASCII码:0~127*/class Solution&#123;public: string s; char flag[128] = &#123;0&#125;; void Insert(char ch) &#123; s += ch; flag[ch]++; &#125; char FirstAppearingOnce() &#123; for(int i=0;i&lt;s.size();i++)&#123; if(flag[s[i]] == 1) return s[i]; &#125; return '#'; &#125;&#125;; 55、链表中环的入口结点给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 如果有环，快慢指针总会相遇 1——2——3——4——5——6 | | 9——8——7 假设快慢指针相遇在6，有1~6走的=6~6走的 1~6走的 = 1~入环点+入环点~6 6~6走的 = 6~入环点+入环点~6 则当快指针从1重新开始，两指针速度相同，再次相遇即为入口节点*//*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; //快慢指针，判断是否有环 bool hasLoop = false; ListNode* fast = pHead; ListNode* slow = pHead; while(fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow)&#123; hasLoop = true; break; &#125; &#125; //寻找环的入口节点 if(hasLoop)&#123; fast = pHead; while(fast != slow)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125; return NULL; &#125;&#125;; 56、删除链表中重复的结点在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 12345678910111213141516171819202122232425262728/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; ListNode* root = new ListNode(0);//设为几无所谓 ListNode* h = root; //标记当前位置 h-&gt;next = pHead; while(h-&gt;next &amp;&amp; h-&gt;next-&gt;next)&#123;//至少两个节点 ListNode* tmp = h-&gt;next-&gt;next; if(h-&gt;next-&gt;val == tmp-&gt;val)&#123;//两节点相同 while(tmp &amp;&amp; h-&gt;next-&gt;val == tmp-&gt;val)&#123; tmp = tmp-&gt;next; &#125; h-&gt;next = tmp; //删除操作 &#125; else h = h-&gt;next; &#125; return root-&gt;next; &#125;&#125;; 57、二叉树的下一个结点给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 123456789101112131415161718192021222324252627282930313233343536373839404142/* 3种情况： 1 1 1 / \\ / \\ / \\ 2 3 2 4 2 5 / \\ / / \\ 4 5 3 3 4 cur=1,next=4 cur=2,next=1 cur=4,next=1 情况1，有右子树，返回右子树的左下角 情况2，无右子树，且是父结点的左子树，返回父结点 情况3，无右子树，且是父结点的右子树，返回父结点的左上角的父结点*//*struct TreeLinkNode &#123; int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123; &#125;&#125;;*/class Solution &#123; public: TreeLinkNode* GetNext(TreeLinkNode* pNode) &#123; if(pNode-&gt;right)&#123; TreeLinkNode* res = pNode-&gt;right; while(res-&gt;left)&#123; res = res-&gt;left; &#125; return res; &#125; else&#123; while(pNode-&gt;next &amp;&amp; pNode-&gt;next-&gt;right == pNode)&#123; pNode = pNode-&gt;next; &#125; return pNode-&gt;next; &#125; &#125;&#125;; 58、对称的二叉树请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 12345678910111213141516171819202122/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NUL L) &#123; &#125;&#125;;*/class Solution &#123;public: bool isSymmetrical(TreeNode* pRoot)&#123; if(!pRoot) return true; return ismoir(pRoot-&gt;left,pRoot-&gt;right); &#125; bool ismoir(TreeNode* l,TreeNode* r)&#123;//是镜像的 if(!l &amp;&amp; !r) return true;//都不存在 if(l &amp;&amp; r) return l-&gt;val==r-&gt;val &amp;&amp; ismoir(l-&gt;left,r-&gt;right) &amp;&amp; ismoir(r-&gt;left,l-&gt;right); return false;// 有且仅有1个存在 &#125;&#125;; 59、按之字形顺序打印二叉树请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* 1 ——&gt; stack1 存奇数层，顺序 / \\ 2 3 &lt;—— stack2 存偶数层，逆序,先left后right / \\ / \\ 4 5 6 7 ——&gt; stack1 存奇数层，顺序,先right后left*//*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt; &gt; res; if(!pRoot) return res; stack&lt;TreeNode*&gt; stack1,stack2; stack1.push(pRoot); while(!stack1.empty() || !stack2.empty())&#123; if(!stack1.empty())&#123; vector&lt;int&gt; tmp; while(!stack1.empty())&#123; if(stack1.top()-&gt;left) stack2.push(stack1.top()-&gt;left); if(stack1.top()-&gt;right) stack2.push(stack1.top()-&gt;right); tmp.push_back(stack1.top()-&gt;val); stack1.pop(); &#125; res.push_back(tmp); &#125; if(!stack2.empty())&#123; vector&lt;int&gt; tmp; while(!stack2.empty())&#123; if(stack2.top()-&gt;right) stack1.push(stack2.top()-&gt;right); if(stack2.top()-&gt;left) stack1.push(stack2.top()-&gt;left); tmp.push_back(stack2.top()-&gt;val); stack2.pop(); &#125; res.push_back(tmp); &#125; &#125; return res; &#125;&#125;; 60、把二叉树打印成多行从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 123456789101112131415161718192021222324252627282930313233/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt; &gt; res; if(!pRoot) return res; queue&lt;TreeNode*&gt; queue; queue.push(pRoot); while(!queue.empty())&#123; int num = queue.size(); vector&lt;int&gt; tmp; while(num!=0)&#123; if(queue.front()-&gt;left) queue.push(queue.front()-&gt;left); if(queue.front()-&gt;right) queue.push(queue.front()-&gt;right); tmp.push_back(queue.front()-&gt;val); queue.pop(); num--; &#125; res.push_back(tmp); &#125; return res; &#125; &#125;; 61、序列化二叉树请实现两个函数，分别用来序列化和反序列化二叉树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: char* Serialize(TreeNode *root) &#123; if(!root) return NULL; string s; queue&lt;TreeNode*&gt; queue; queue.push(root); while(!queue.empty())&#123; if(queue.front())&#123; queue.push(queue.front()-&gt;left); queue.push(queue.front()-&gt;right); s += to_string(queue.front()-&gt;val)+\",\"; &#125; else s += \"#,\"; queue.pop(); &#125; char* res = strdup(s.c_str()); /* 另一种写法，不用strdup() char* res = new char[s.size() + 1]; int i; for(i=0;i&lt;s.size();i++) res[i]=s[i]; res[i] = '\\0'; */ return res; &#125; TreeNode* Deserialize(char *str) &#123; if(!str) return NULL; int i = 0; auto head = getnode(str,i); queue&lt;TreeNode*&gt; queue; queue.push(head); while(!queue.empty())&#123; queue.front()-&gt;left = getnode(str,i); queue.front()-&gt;right = getnode(str,i); if(queue.front()-&gt;left) queue.push(queue.front()-&gt;left); if(queue.front()-&gt;right) queue.push(queue.front()-&gt;right); queue.pop(); &#125; return head; &#125; TreeNode* getnode(char *str,int &amp;i)&#123; if(str[i] == ',') i++; if(str[i] == '#')&#123; i += 2; return NULL; &#125; string s; while(str[i] != ',' &amp;&amp; str[i] != '\\0')&#123; s += str[i]; i++; &#125; if(!s.empty()) return new TreeNode(stoi(s)); return NULL; &#125;&#125;; 62、二叉搜索树的第k个结点给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 1234567891011121314151617181920212223242526272829303132/* 二叉搜索树：左子树上所有结点的值均小于它的根结点的值,右子树上所有结点的值均大于它的根结点的值 二叉搜索树按照中序遍历得到递增的顺序，压入栈，第k个结点就是结果*//*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: stack&lt;TreeNode*&gt; stack; TreeNode* KthNode(TreeNode* pRoot, int k)&#123; if(k &lt;= 0) return NULL; sortmid(pRoot,k); if(stack.size() &lt; k) return NULL; //k大于节点数 return stack.top(); &#125; void sortmid(TreeNode* pRoot, int k) &#123; if(!pRoot) return; if(stack.size()!=k) sortmid(pRoot-&gt;left,k); if(stack.size()!=k) stack.push(pRoot); if(stack.size()!=k) sortmid(pRoot-&gt;right,k); &#125;&#125;; 63、数据流中的中位数如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 12345678910111213141516171819202122232425262728293031/* 使用大小顶堆，中位数是大顶堆的根节点与小顶堆的根节点和的平均数 大顶堆,由大到小，存较小的数 7 6 5 小顶堆,由小到大，存较大的数 8 9 10 步骤： 第一个插入的元素装大顶堆 1、每来一个插入的元素，比大顶堆堆顶元素小的装大顶堆，否则装小顶堆（保证大顶堆的数都比小顶堆的数小） 2、判断是否大顶堆装多了，大顶堆最多比小顶堆多一个，如果是，将大顶堆堆顶元素插入小顶堆 3、判断是否小顶堆装多了，小顶堆小于等于大顶堆，如果是，将小顶堆堆顶元素插入大顶堆*/class Solution &#123;public: priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; big_heap; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; small_heap; void Insert(int num) &#123; if(big_heap.empty() || num &lt; big_heap.top()) big_heap.push(num); else small_heap.push(num); if(big_heap.size() == small_heap.size()+2)&#123; small_heap.push(big_heap.top()); big_heap.pop(); &#125; if(big_heap.size() == small_heap.size()-1)&#123; big_heap.push(small_heap.top()); small_heap.pop(); &#125; &#125; double GetMedian() &#123; return small_heap.size()==big_heap.size()?(small_heap.top()+big_heap.top())/2.0:big_heap.top(); &#125;&#125;; 64、滑动窗口的最大值给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) &#123; vector&lt;int&gt; res; deque&lt;int&gt; q;//队首为当前窗口下最大值下标 for(unsigned int i=0;i&lt;num.size();i++)&#123; while(!q.empty() &amp;&amp; num[i]&gt;num[q.back()])&#123;//q删掉所有比当前元素小的，保证q降序 q.pop_back(); &#125; if(!q.empty() &amp;&amp; q.front()+size == i)&#123; //若队首超过窗口位置,删掉 q.pop_front(); &#125; q.push_back(i); if(size &amp;&amp; i+1&gt;=size) res.push_back(num[q.front()]); //防止size=0 &#125; return res; &#125;&#125;; 65、矩阵中的路径请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 12345678910111213141516171819202122232425262728class Solution &#123;public: bool hasPath(char* matrix, int rows, int cols, char* str) &#123; //if(!matrix || rows&lt;=0 || cols&lt;=0 || !str) return false; for(int i=0;i&lt;rows;i++)&#123; for(int j=0;j&lt;cols;j++)&#123; if(help(matrix,i,j,str,0,rows,cols)) return true; &#125; &#125; return false; &#125; bool help(char* matrix, int i, int j, char* str, int k, int rows, int cols) &#123; int index = i*cols+j; if(i&lt;0||i&gt;=rows||j&lt;0||j&gt;=cols||matrix[index]=='#'||str[k]!=matrix[index]) return false; if(str[k+1]=='\\0') return true; char tmp = matrix[index]; matrix[index] = '#'; if(help(matrix,i+1,j,str,k+1,rows,cols) || help(matrix,i-1,j,str,k+1,rows,cols) || help(matrix,i,j+1,str,k+1,rows,cols) || help(matrix,i,j-1,str,k+1,rows,cols))&#123; return true; &#125; matrix[index] = tmp; return false; &#125;&#125;; 66、机器人的运动范围地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 1234567891011121314151617181920212223242526class Solution &#123;public: int movingCount(int threshold, int rows, int cols) &#123; if(rows&lt;=0 || cols&lt;=0 || threshold&lt;0) return 0; bool* flag = new bool[rows*cols]; memset(flag,false,rows*cols); return helper(threshold,rows,cols,0,0,flag); &#125; int helper(int threshold, int rows, int cols,int i, int j, bool* flag) &#123; int index = i*cols+j; if(i&lt;0||i&gt;=rows||j&lt;0||j&gt;=cols||flag[index]||count(i)+count(j)&gt;threshold) return 0; flag[index] = true; return helper(threshold,rows,cols,i-1,j,flag)+ helper(threshold,rows,cols,i+1,j,flag)+ helper(threshold,rows,cols,i,j-1,flag)+ helper(threshold,rows,cols,i,j+1,flag)+1; &#125; int count(int n) &#123; int res = 0; while(n!=0)&#123; res += n%10; n /= 10; &#125; return res; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"},{"name":"CodeCode","slug":"CodeCode","permalink":"http://yoursite.com/categories/CodeCode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://yoursite.com/tags/剑指Offer/"}]},{"title":"基于RGBD相机的人脸实时三维重建过程解析（ElasticFusion实现）","slug":"18","date":"2019-06-17T03:36:20.000Z","updated":"2019-12-18T04:14:28.239Z","comments":true,"path":"2019/06/17/18/","link":"","permalink":"http://yoursite.com/2019/06/17/18/","excerpt":"","text":"主要是在ElasticFusion基础上做了部分修改，进行人脸实时重建。PPT及相关论文地址：https://pan.baidu.com/s/1Zr1uCFj7YqgEWWof2gp-Lw ，提取码：7fnw相关算法实现链接：BundleFusion在win10+vs2013+cuda8.0上的实现DynamicFusion在ubuntu16.04+显卡GT740+cuda8.0上的实现ElasticFusion在ubuntu16.04+cuda8.0上的实现 参考链接：KinectFusion 解析KinectFusion 论文精析kinect fusion 3D重建基本算法KinectFusion中用到的TSDF FusionBundleFusion 解析ElasticFusion 解析 （这个博主其他文章也非常值得参考）ElasticFusion","categories":[{"name":"深度相机","slug":"深度相机","permalink":"http://yoursite.com/categories/深度相机/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"RGBD","slug":"RGBD","permalink":"http://yoursite.com/tags/RGBD/"},{"name":"ElasticFusion","slug":"ElasticFusion","permalink":"http://yoursite.com/tags/ElasticFusion/"},{"name":"人脸实时三维重建","slug":"人脸实时三维重建","permalink":"http://yoursite.com/tags/人脸实时三维重建/"}]},{"title":"Vue+iview+Echarts+electron 桌面应用","slug":"17","date":"2019-04-29T12:01:15.000Z","updated":"2019-12-18T04:13:58.258Z","comments":true,"path":"2019/04/29/17/","link":"","permalink":"http://yoursite.com/2019/04/29/17/","excerpt":"一、Vue项目创建1、安装node.js#下载安装包：https://nodejs.org/en/cmd输入node -v 和npm -v查看是否安装成功","text":"一、Vue项目创建1、安装node.js#下载安装包：https://nodejs.org/en/cmd输入node -v 和npm -v查看是否安装成功 2、Vue开发环境#命令行下载淘宝镜像命令工具 cnpm 1npm install cnpm -g --registry=http://registry.npm.taobao.org #用 cnpm 命令全局安装vue-cli脚手架 1cnpm install --global vue-cli 输入vue，出来vue的信息说明安装成功 3、搭建Vue项目（1）项目初始化 使用命令创建项目，一步步选择之后开始等等项目创建完成 1vue init webpack app （2）项目预览12cd demonpm run dev 打开浏览器，复制粘贴命令行显示的地址（ http://localhost:8080），跳出页面 二、引入ivew+Echarts1、ivew+Echarts安装1cnpm install ivew -save 1cnpm install echarts -save 2、引入ivew+Echarts项目src/main.js中引入ivew+Echarts 1234import iView from 'iview';import 'iview/dist/styles/iview.css';Vue.use(iView); 12import Echarts from 'echarts'Vue.prototype.echarts = Echarts 3、Echarts组件将src/components/HelloWorld修改为如下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;style scoped&gt;.layout&#123; border: 1px solid #d7dde4; background: #f5f7f9; position: relative; border-radius: 4px; overflow: hidden;&#125;.layout-logo&#123; width: 100px; height: 30px; background: #5b6270; border-radius: 3px; float: left; position: relative; top: 15px; left: 20px;&#125;.layout-nav&#123; width: 420px; margin: 0 auto; margin-right: 20px;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class=\"layout\"&gt; &lt;Layout&gt; &lt;Header&gt; &lt;Menu mode=\"horizontal\" theme=\"dark\" active-name=\"1\"&gt; &lt;div class=\"layout-logo\"&gt;&lt;/div&gt; &lt;div class=\"layout-nav\"&gt; &lt;MenuItem name=\"1\"&gt; &lt;Icon type=\"ios-navigate\"&gt;&lt;/Icon&gt; Item 1 &lt;/MenuItem&gt; &lt;MenuItem name=\"2\"&gt; &lt;Icon type=\"ios-keypad\"&gt;&lt;/Icon&gt; Item 2 &lt;/MenuItem&gt; &lt;MenuItem name=\"3\"&gt; &lt;Icon type=\"ios-analytics\"&gt;&lt;/Icon&gt; Item 3 &lt;/MenuItem&gt; &lt;MenuItem name=\"4\"&gt; &lt;Icon type=\"ios-paper\"&gt;&lt;/Icon&gt; Item 4 &lt;/MenuItem&gt; &lt;/div&gt; &lt;/Menu&gt; &lt;/Header&gt; &lt;Layout&gt; &lt;Sider hide-trigger :style=\"&#123;background: '#fff'&#125;\"&gt; &lt;Menu active-name=\"1-2\" theme=\"light\" width=\"auto\" :open-names=\"['1']\"&gt; &lt;Submenu name=\"1\"&gt; &lt;template slot=\"title\"&gt; &lt;Icon type=\"ios-navigate\"&gt;&lt;/Icon&gt; Item 1 &lt;/template&gt; &lt;MenuItem name=\"1-1\"&gt;Option 1&lt;/MenuItem&gt; &lt;MenuItem name=\"1-2\"&gt;Option 2&lt;/MenuItem&gt; &lt;MenuItem name=\"1-3\"&gt;Option 3&lt;/MenuItem&gt; &lt;/Submenu&gt; &lt;Submenu name=\"2\"&gt; &lt;template slot=\"title\"&gt; &lt;Icon type=\"ios-keypad\"&gt;&lt;/Icon&gt; Item 2 &lt;/template&gt; &lt;MenuItem name=\"2-1\"&gt;Option 1&lt;/MenuItem&gt; &lt;MenuItem name=\"2-2\"&gt;Option 2&lt;/MenuItem&gt; &lt;/Submenu&gt; &lt;Submenu name=\"3\"&gt; &lt;template slot=\"title\"&gt; &lt;Icon type=\"ios-analytics\"&gt;&lt;/Icon&gt; Item 3 &lt;/template&gt; &lt;MenuItem name=\"3-1\"&gt;Option 1&lt;/MenuItem&gt; &lt;MenuItem name=\"3-2\"&gt;Option 2&lt;/MenuItem&gt; &lt;/Submenu&gt; &lt;/Menu&gt; &lt;/Sider&gt; &lt;Layout :style=\"&#123;padding: '0 24px 24px'&#125;\"&gt; &lt;Breadcrumb :style=\"&#123;margin: '24px 0'&#125;\"&gt; &lt;BreadcrumbItem&gt;Home&lt;/BreadcrumbItem&gt; &lt;BreadcrumbItem&gt;Components&lt;/BreadcrumbItem&gt; &lt;BreadcrumbItem&gt;Layout&lt;/BreadcrumbItem&gt; &lt;/Breadcrumb&gt; &lt;Content :style=\"&#123;padding: '24px', minHeight: '280px', background: '#fff'&#125;\"&gt; &lt;div id=\"echart\" style=\"width: 940px;height:500px;\"&gt;&lt;/div&gt; &lt;/Content&gt; &lt;/Layout&gt; &lt;/Layout&gt; &lt;/Layout&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import echarts from 'echarts' export default &#123; data() &#123; return &#123;&#125; &#125;, mounted() &#123; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echart')); // 绘制图表 var option = &#123; title : &#123; text: '保有储量变化图', subtext: '一次能源' &#125;, tooltip : &#123; trigger: 'axis' &#125;, legend: &#123; data:['煤','石油','天然气'] &#125;, toolbox: &#123; show : true, feature : &#123; dataView : &#123;show: true, readOnly: false&#125;, magicType : &#123;show: true, type: ['line', 'bar']&#125;, restore : &#123;show: true&#125;, saveAsImage : &#123;show: true&#125; &#125; &#125;, calculable : true, xAxis : [ &#123; type : 'category', data : ['2009','2010','2011','2012','2013','2014','2015','2016','2017'], splitNumber: 10 &#125; ], yAxis : [ &#123; type : 'value' &#125; ], series : [ &#123; name:'煤', type:'bar', data:[1683.47,1654.23,1640.12,1641.6,1639.68,1642.7,1610.41,1639.45,1722.2], markPoint : &#123; data : [ &#123;type : 'max', name: '最大值'&#125;, &#123;type : 'min', name: '最小值'&#125; ] &#125;, markLine : &#123; data : [ &#123;type : 'average', name: '平均值'&#125; ] &#125; &#125;, &#123; name:'石油', type:'bar', data:[22490.2,24947.67,29844.34,31397.94,33713,36300.8,38445.3,38375.6,38158.7], markPoint : &#123; data : [ &#123;type : 'max', name: '最大值'&#125;, &#123;type : 'min', name: '最小值'&#125; ] &#125;, markLine : &#123; data : [ &#123;type : 'average', name : '平均值'&#125; ] &#125; &#125;, &#123; name:'天然气', type:'bar', data:[5502.54,5628.11,5478,6376.26,6231.14,8047.88,7857.1,7802.5,8695.01], markPoint : &#123; data : [ &#123;type : 'max', name: '最大值'&#125;, &#123;type : 'min', name: '最小值'&#125; ] &#125;, markLine : &#123; data : [ &#123;type : 'average', name : '平均值'&#125; ] &#125; &#125; ] &#125;; myChart.setOption(option); &#125; &#125; &lt;/script&gt; 1npm run dev 打开http://localhost:8080 ，显示页面 4、生成项目执行生成命令 1npm run build 出现如下效果项目下回多出一个dist的文件夹，里面是打包好的东西，双击index.html显示网页内容则证明生成成功 （1）打包页面显示空白修改index.js 中的生成路径，第46行改为assetsPublicPath: &#39;./&#39;,，否则后面程序运行打包页面会显示空白，找不到路径 （2）页面部分空白，router-view内容无法显示// mode: ‘history’,//将这个模式关闭就好 （3）iview 打包之后，图标无法显示在 build/webpack.prod.conf.js 中,将extract改为false接下来一切操作都在dist文件夹目录下。 三、electron打包1、安装 electron用 cnpm 命令安装 electron 1cnpm install electron -g cmd输入electron -v查看是否安装成功 2、 package.json 和 main.js在dist文件夹下，复制粘贴下面的 package.json 和 main.js文件，最终目录如图在package.json中： 12345&#123; \"name\" : \"your-app\", \"version\" : \"0.1.0\", \"main\" : \"main.js\"&#125; 在main.js中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const &#123;app, BrowserWindow&#125; = require('electron')const path = require('path')const url = require('url')// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the JavaScript object is garbage collected.let winfunction createWindow () &#123; // Create the browser window. win = new BrowserWindow(&#123;width: 800, height: 600&#125;) // and load the index.html of the app. win.loadURL(url.format(&#123; pathname: path.join(__dirname, 'index.html'), protocol: 'file:', slashes: true &#125;)) // Open the DevTools. // win.webContents.openDevTools() // Emitted when the window is closed. win.on('closed', () =&gt; &#123; // Dereference the window object, usually you would store windows // in an array if your app supports multi windows, this is the time // when you should delete the corresponding element. win = null &#125;)&#125;// This method will be called when Electron has finished// initialization and is ready to create browser windows.// Some APIs can only be used after this event occurs.app.on('ready', createWindow)// Quit when all windows are closed.app.on('window-all-closed', () =&gt; &#123; // On macOS it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q if (process.platform !== 'darwin') &#123; app.quit() &#125;&#125;)app.on('activate', () =&gt; &#123; // On macOS it's common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (win === null) &#123; createWindow() &#125;&#125;)// In this file you can include the rest of your app's specific main process// code. You can also put them in separate files and require them here. 运行 1electron . 3、electron-packager打包（1）全局安装electron-packager1npm install electron-packager -g （2）运行打包命令1electron-packager . demo --win --out outApp --arch=x64 --app-version 1.0.0 --electron-version 5.0.0 --overwrite --ignore=node_modules 在dist\\outApp\\demo-win32-x64文件夹下生成可执行文件demo.exe,双击运行程序嫌每次输入太长，可以将在package.json中添加 1234\"scripts\": &#123; \"start\": \"electron .\", \"build\": \"electron-packager . myApp --win --out outApp --arch=x64 --app-version 1.0.0 --electron-version 5.0.0 --overwrite --ignore=node_modules\" &#125; 这样输入npm run start相当于执行了electron .,测试打包效果输入npm run build相当于执行了打包命令，在dist\\outApp\\myApp-win32-x64文件夹下生成可执行文件myApp.exe 4、源码加密在outApp\\demo-win32-x64\\resources\\app里有写的源码。写的代码完全暴露在用户电脑上是非常不安全的，可以通过electron 自带的加密功能解决这个问题。 （1）全局安装 asar1npm install asar -g （2）使用asar指令进行加密在resources目录下使用asar指令进行加密 1asar pack ./app app.asar 将原来的app文件夹删除，这样生成的app.asar就加密了之前的源代码双击demo.exe重新运行程序","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"http://yoursite.com/tags/Electron/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"iview","slug":"iview","permalink":"http://yoursite.com/tags/iview/"},{"name":"Echarts","slug":"Echarts","permalink":"http://yoursite.com/tags/Echarts/"},{"name":"桌面应用","slug":"桌面应用","permalink":"http://yoursite.com/tags/桌面应用/"}]},{"title":"一步步配置腾讯云服务器Ubuntu 通过域名访问自己的网页tomcat（详细基础）","slug":"22","date":"2019-04-26T08:32:46.000Z","updated":"2019-12-18T04:17:49.267Z","comments":true,"path":"2019/04/26/22/","link":"","permalink":"http://yoursite.com/2019/04/26/22/","excerpt":"STEP1:云服务器+域名1、购买云服务器、域名购买学生优惠套餐 10元/月：https://cloud.tencent.com/act/campus?fromSource=gwzcw.1088196.1088196.1088196系统选ubuntu，购买3个月加购域名共38元（3个月以下没法添加域名解析），买了域名以后可以直接通过域名访问","text":"STEP1:云服务器+域名1、购买云服务器、域名购买学生优惠套餐 10元/月：https://cloud.tencent.com/act/campus?fromSource=gwzcw.1088196.1088196.1088196系统选ubuntu，购买3个月加购域名共38元（3个月以下没法添加域名解析），买了域名以后可以直接通过域名访问 收到服务器信息，最好把这些复制到一个txt里，以后会经常用。 2、添加解析在控制台进入云解析，添加解析，填域名，点新手快速添加， 网站解析，输入公网ip（无需备案）完成后： 3、设置安全组控制台-云服务器-安全组-新建，选择 放通22，80，443，3389端口和ICMP协议，新建安全组点击关联实例数，新增关联与自己的服务器进行关联，点击修改规则，放通8080端口（tomcat要用） STEP2:连接服务器，配置JDK+tomcat1、连接服务器下载安装PuTTY：https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html下载安装WinSCP：https://winscp.net/eng/download.php （1）PuTTY连接服务器输入公网ip输入默认账户ubuntu，输入初始密码**，登陆成功如上图。 putty的复制粘贴技巧复制密码后，在putty直接右键就是粘贴，密码不显示注意不要多复制。（如果想复制putty中的文字，左键选取就已经复制上了） 创建root账号1、设置root密码sudo passwd root输入密码2、获取root权限输入su输入密码以后再次登录，输入su再输入密码就可以了，成功后： root@VM-0-16-ubuntu:/home/ubuntu# （2）winSCP连接服务器主机名为公网ip，点击登录 尝试新建文件夹test，提示permission denied 使用root登录winSCP：打开winSCP填写登录信息 ，点击高级，设置SFTP如下：sudo /usr/lib/openssh/sftp-server重新登录后，就可以将本地文件拖到服务器中了。 2、配置JDK+tomcat（ubuntu云服务器）下载jdk8：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html下载Tomcat：https://tomcat.apache.org/download-90.cgiroot登录winSCP后，将下载的 jdk-8u191-linux-x64.tar.gz 和 jdk-11.0.1_linux-x64_bin.tar.gz拖到/usr/local/src/目录下 （1）安装JDK1.8root登录putty后，输入cd /usr/local/src/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 进入存放安装包的位置tar zxvf jdk-8u144-linux-x64.tar.gz &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 解压下载的数据包mv jdk1.8.0_144 /usr/local/jdk1.8 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 给解压完成后的数据包更换一个其他目录并且改名vi /etc/profile &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 编辑/etc/profile 环境变量文件在最后面添加 JAVA_HOME=/usr/local/jdk1.8JAVA_BIN=/usr/local/jdk1.8/binJRE_HOME=/usr/local/jdk1.8/jrePATH=$PATH:/usr/local/jdk1.8/bin:/usr/local/jdk1.8/jre/binCLASSPATH=/usr/local/jdk1.8/jre/lib:/usr/local/jdk1.8/lib:/usr/local/jdk1.8/jre/lib/charsets.jar vi使用技巧输入 i ，退出命令模式，进入INSERT模式开始修改内容……按 esc 键，退出INSERT模式，进入命令模式再输入 :wq，保存文件，退出vi编辑器 键 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 功能:wq &nbsp;&nbsp;&nbsp;&nbsp; 保存文件，退出vi编辑器:w &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 保存文件，但不退出vi编辑器:q &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 退出vi编辑器:q! &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不保存文件，退出vi编辑器ZZ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 保存文件，退出vi编辑器或者在winSCP中直接打开/etc/profile文件，修改后保存。 putty中输入source /etc/profile &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // source重启环境变量配置文件java -version &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 检测jdk环境是否配置好注：每次登录，碰到java -version不显示版本号就，先source /etc/profile，再java -version，就好了。 （2）安装Tomcat9root登录putty后，输入cd /usr/local/src/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 进入存放安装包的位置tar zxvf apache-tomcat-9.0.14.tar.gz &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 解压下载的数据包mv apache-tomcat-9.0.14 /usr/local/tomcat &nbsp;&nbsp; // 给解压完成后的数据包更换一个其他目录并且改名/usr/local/tomcat/bin/startup.sh &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 启动Tomcat Tomcat启用成功了显示： Using CATALINA_BASE: /usr/local/tomcatUsing CATALINA_HOME: /usr/local/tomcatUsing CATALINA_TMPDIR: /usr/local/tomcat/tempUsing JRE_HOME: /usr/local/jdk1.8Using CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jarTomcat started. 如果要关闭Tomcat/usr/local/tomcat/bin/shutdown.sh启动Tomcat后，确定服务器8080端口放通，则在浏览器输入 服务器公网ip:8080，一只熟悉的猫出现了~ 注：如果添加了域名解析，可以用域名代替ip STEP3:本地网页布置到tomcat希望ip:8080访问自己的网页首先有自己的网页，如自己写的跳一跳网页，下载地址：https://github.com/zj19941113/You_Jump_I_Jump将项目文件夹zjgame放到tomcat/webapps/文件夹中，从ROOT中将WEB-INF文件夹复制到zjgame，访问ip:8080/zjgame/zjtest.html，就能看到项目了如果添加了域名解析，可以访问 域名:8080/zjgame/zjtest.html （1）去掉项目名a. 将zjgame中的网页和资源文件复制到ROOT中，zjtest.html重命名为index.html浏览器输入 ip:8080 就能访问了或者 b. 修改 /usr/local/tomcat/conf/server.xml 文件在&lt;Host&gt;&lt;/Host&gt;里加上 &lt;Context path=”” docBase=”项目名” reloadable=”true” /&gt; （2）去掉:8080修改 /usr/local/tomcat/conf/server.xml 文件，将默认端口port=”8080”改为”80” Connector port=”80” protocol=”HTTP/1.1” connectionTimeout=”20000” redirectPort=”8443” /&gt; 关闭Tomcat/usr/local/tomcat/bin/shutdown.sh过一会再重启/usr/local/tomcat/bin/startup.sh因为之前已经进行过域名解析，所以直接访问 http://zhoujie1994.cn 就能看到自己的网页了备案后不会再提示不安全：https://zhoujie1994.cn/three/","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"}],"tags":[{"name":"腾讯云服务器","slug":"腾讯云服务器","permalink":"http://yoursite.com/tags/腾讯云服务器/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Kinect v1实时dlib(GPU版)人脸识别与活体检测","slug":"16","date":"2019-04-22T11:39:33.000Z","updated":"2019-12-18T04:13:02.054Z","comments":true,"path":"2019/04/22/16/","link":"","permalink":"http://yoursite.com/2019/04/22/16/","excerpt":"一、配置1、opencv#安装依赖 12sudo apt-get install libvtk5-devsudo apt-get install libgtk2.0-dev","text":"一、配置1、opencv#安装依赖 12sudo apt-get install libvtk5-devsudo apt-get install libgtk2.0-dev #安装OpenCV 2.4.13 1234567git clone https://github.com/opencv/opencvcd opencv/git checkout 2.4.13.3mkdir -p build &amp;&amp; cd buildcmake -DWITH_VTK=ON -DWITH_GTK=ON -DBUILD_opencv_calib3d=ON -DBUILD_opencv_imgproc=ON -DWITH_CUDA=OFF ..make -j4sudo make install 注：opencv的下载过程非常慢 2、dlib（GPU版）需要提前安装驱动、cuda 与 cudnn进入官网：http://dlib.net/ ，点击左下角Download dlib ver.19.17 ，下载后解压。进入dlib根目录下 1234mkdir build &amp;&amp; cd buildcmake .. cmake --build . --config Releasesudo make install 注：会自动检查满足安装gpu版条件，注意命令行提示信息 二、Kinect v1接入1、安装OpenNI2123git clone https://github.com/occipital/OpenNI2.gitcd OpenNI2make -j4 2、安装libFreenect12git clone https://github.com/OpenKinect/libfreenectcd libfreenect 打开libfreenect/CMakeLists.txt，在33行cmake_minimum_required(VERSION 2.8.12)下一行添加 1add_definitions(-std=c++11) 保存后关闭，命令行继续执行 1234mkdir build &amp;&amp; cd build cmake .. -DBUILD_OPENNI2_DRIVER=ON make -j4cp -L lib/OpenNI2-FreenectDriver/libFreenectDriver.so $&#123;OPENNI2_DIR&#125;/Bin/x64-Release/OpenNI2/Drivers #OPENNI2_DIR需要修改 注：${OPENNI2_DIR}是OpenNI2的解压文件夹，比如我的在ElasticFusion文件夹，则打开libfreenect文件夹，运行 1sudo cp platform/linux/udev/51-kinect.rules /etc/udev/rules.d 重启后，插上kinect后，命令行运行clsusb，查看是否包含：Xbox camera，Xbox motor，Xbox audio 二、代码运行1、CMakeList.txt修改#CMakeList.txt 1234567891011121314151617181920212223242526272829303132333435363738cmake_minimum_required(VERSION 2.8.4) project(face_dlib) SET(CMAKE_CXX_FLAGS \"$&#123;CMAKE_CXX_FLAGS&#125; -O2 -DDLIB_JPEG_SUPPORT\")IF(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\") SET(CMAKE_CXX_FLAGS \"$&#123;CMAKE_CXX_FLAGS&#125; -Weverything\")ELSEIF(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\") SET(CMAKE_CXX_FLAGS \"$&#123;CMAKE_CXX_FLAGS&#125; -Wall -Wextra\")ENDIF()# opencvfind_package(OpenCV REQUIRED)include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)# OpenNI2set(OPENNI2_PATH \"/home/zhoujie/fusion/ElasticFusion/OpenNI2\") set(OPENNI2_INCLUDE_DIR $&#123;OPENNI2_PATH&#125;/Include)set(OPENNI2_LIBRARY $&#123;OPENNI2_PATH&#125;/Bin/x64-Release)include_directories ($&#123;OPENNI2_INCLUDE_DIR&#125;)link_directories ($&#123;OPENNI2_LIBRARY&#125;)# dlibinclude(/home/zhoujie/dlib-19.17/dlib/cmake)add_executable(this_is_who_kinect_one src/this_is_who_kinect_one.cpp)target_link_libraries(this_is_who_kinect_one dlib $&#123;OpenCV_LIBS&#125; libOpenNI2.so)macro(add_face_dlib name) add_executable($&#123;name&#125; src/$&#123;name&#125;.cpp) target_link_libraries($&#123;name&#125; dlib )endmacro()add_face_dlib(train_candidate)add_face_dlib(this_is_who) 将OPENNI2_PATH与dlib路径修改为自己的。 2、数据+模型下载下载 shape_predictor_68_face_landmarks.dat 和 dlib_face_recognition_resnet_model_v1.dat 放置到model文件夹中 链接：https://pan.baidu.com/s/1jIoW6BSa5nkGWNipL7sxVQ其中包括： candidate-face.zip（人脸库：包含29个正面人脸红外图） allface.zip（测试人脸集：包括29个人，每人13种脸部姿态下的红外图与深度图） shape_predictor_68_face_landmarks.dat（人脸68关键点检测器） dlib_face_recognition_resnet_model_v1.dat（人脸识别模型） 3、代码运行将train_candidate.cpp 、this_is_who 和 this_is_who_kinect_one.cpp置于src文件夹中。 #build 123mkdir build &amp;&amp; cd buildcmake ..make -j4 cmake时检查是否适用dlib(GPU)版最终在build文件夹中生成多个可执行文件将人脸图片重命名为人的名字，放在data文件夹中。 1、运行train_candidate 获得人脸库特征信息，存储在candidates_descriptors.dat 与 candidates.dat 中，同时生成candidates.txt，便于查看候选人信息。每次修改人脸库，只需运行train_candidate，完成人脸信息的更新。 2、运行this_is_who_kinect_one,实时获取Kinect深度图与彩色图，并进行人脸识别与活体检测。3、 不使用kinect v1实时接入，在离线数据上测试，运行this_is_who,使用data/allface中的深度图与红外图，并进行人脸识别与活体检测。代码部分： #train_candidate 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;dlib/dnn.h&gt;#include &lt;dlib/image_processing/frontal_face_detector.h&gt;#include &lt;dlib/image_processing.h&gt;#include &lt;dlib/gui_widgets.h&gt;#include &lt;dlib/image_io.h&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;time.h&gt;#include &lt;dirent.h&gt;#include &lt;string.h&gt;using namespace dlib;using namespace std;/* 函数声明 *//* 人脸库训练 */int candidates_train(const char *facesFile,std::vector&lt;matrix&lt;float,0,1&gt;&gt;&amp;candidates_descriptors,std::vector&lt;string&gt;&amp;candidates);template &lt;template &lt;int,template&lt;typename&gt;class,int,typename&gt; class block, int N, template&lt;typename&gt;class BN, typename SUBNET&gt;using residual = add_prev1&lt;block&lt;N,BN,1,tag1&lt;SUBNET&gt;&gt;&gt;;template &lt;template &lt;int,template&lt;typename&gt;class,int,typename&gt; class block, int N, template&lt;typename&gt;class BN, typename SUBNET&gt;using residual_down = add_prev2&lt;avg_pool&lt;2,2,2,2,skip1&lt;tag2&lt;block&lt;N,BN,2,tag1&lt;SUBNET&gt;&gt;&gt;&gt;&gt;&gt;;template &lt;int N, template &lt;typename&gt; class BN, int stride, typename SUBNET&gt; using block = BN&lt;con&lt;N,3,3,1,1,relu&lt;BN&lt;con&lt;N,3,3,stride,stride,SUBNET&gt;&gt;&gt;&gt;&gt;;template &lt;int N, typename SUBNET&gt; using ares = relu&lt;residual&lt;block,N,affine,SUBNET&gt;&gt;;template &lt;int N, typename SUBNET&gt; using ares_down = relu&lt;residual_down&lt;block,N,affine,SUBNET&gt;&gt;;template &lt;typename SUBNET&gt; using alevel0 = ares_down&lt;256,SUBNET&gt;;template &lt;typename SUBNET&gt; using alevel1 = ares&lt;256,ares&lt;256,ares_down&lt;256,SUBNET&gt;&gt;&gt;;template &lt;typename SUBNET&gt; using alevel2 = ares&lt;128,ares&lt;128,ares_down&lt;128,SUBNET&gt;&gt;&gt;;template &lt;typename SUBNET&gt; using alevel3 = ares&lt;64,ares&lt;64,ares&lt;64,ares_down&lt;64,SUBNET&gt;&gt;&gt;&gt;;template &lt;typename SUBNET&gt; using alevel4 = ares&lt;32,ares&lt;32,ares&lt;32,SUBNET&gt;&gt;&gt;;using anet_type = loss_metric&lt;fc_no_bias&lt;128,avg_pool_everything&lt; alevel0&lt; alevel1&lt; alevel2&lt; alevel3&lt; alevel4&lt; max_pool&lt;3,3,2,2,relu&lt;affine&lt;con&lt;32,7,7,2,2, input_rgb_image_sized&lt;150&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;int main(int argc, char** argv)&#123; if (argc == 1) &#123; cout &lt;&lt; \"\\nCall this program like this:\" &lt;&lt; endl; cout &lt;&lt; \"./train_candidate ../data/candidate-face/\" &lt;&lt; endl; return 0; &#125; const char *facesFile = argv[1]; std::vector&lt;matrix&lt;float,0,1&gt;&gt; candidates_descriptors; std::vector&lt;string&gt; candidates; /* 人脸库训练 */ candidates_train(facesFile,candidates_descriptors,candidates);&#125;/* 人脸库训练 */int candidates_train(const char *facesFile,std::vector&lt;matrix&lt;float,0,1&gt;&gt;&amp;candidates_descriptors,std::vector&lt;string&gt;&amp;candidates)&#123; DIR *dir; struct dirent *ptr; char base[30]; const char *pick=\".jpg\"; //需要的子串; char IRfile[100]; char *name; int face_num = 0; std::vector&lt;matrix&lt;rgb_pixel&gt;&gt; faces; frontal_face_detector detector = get_frontal_face_detector(); // 人脸正脸检测器 shape_predictor sp; //人脸关键点检测器 anet_type net; // 人脸识别模型 deserialize(\"../model/shape_predictor_68_face_landmarks.dat\") &gt;&gt; sp; deserialize(\"../model/dlib_face_recognition_resnet_model_v1.dat\") &gt;&gt; net; clock_t start,finish; double totaltime; start=clock(); ofstream mycout(\"../candidates.txt\"); cout &lt;&lt; \"TRAINING START！\" &lt;&lt; endl; if ((dir=opendir(facesFile)) == NULL) &#123; perror(\"Open dir error...\"); exit(1); &#125; while ((ptr=readdir(dir)) != NULL) &#123; strcpy(base, ptr-&gt;d_name); if(strstr(base,pick)) &#123; cout &lt;&lt; \"training image:\" &lt;&lt; base &lt;&lt; endl; strcpy(IRfile, facesFile); strcat(IRfile, base); name = strtok(base, \"_\"); string candidate = name; cout &lt;&lt; \"candidate: \" &lt;&lt; candidate &lt;&lt; endl; mycout &lt;&lt; candidate &lt;&lt; endl; candidates.push_back(candidate); matrix&lt;rgb_pixel&gt; img; load_image(img, IRfile); std::vector&lt;rectangle&gt; dets = detector(img); full_object_detection shape = sp(img, dets[0]); matrix&lt;rgb_pixel&gt; face_chip; extract_image_chip(img, get_face_chip_details(shape,150,0.25), face_chip); faces.push_back(move(face_chip)); face_num += 1; &#125; &#125; candidates_descriptors = net(faces); mycout.close(); cout &lt;&lt; \"TRAINING END！\" &lt;&lt; endl; cout &lt;&lt; \"\\nTRAIN RESULT：\" &lt;&lt; endl; cout &lt;&lt; \"Training \" &lt;&lt; face_num &lt;&lt; \" face(s)！\" &lt;&lt; endl; finish=clock(); totaltime=(double)(finish-start)/CLOCKS_PER_SEC; cout&lt;&lt;\"TRAINING TIME： \" &lt;&lt; totaltime &lt;&lt; \" S！\"&lt;&lt;endl; cout &lt;&lt; \"\\nFace database updating……\" &lt;&lt; endl; serialize(\"../candidates_descriptors.dat\") &lt;&lt; candidates_descriptors; serialize(\"../candidates.dat\") &lt;&lt; candidates; cout &lt;&lt; \"Face has been updated！\" &lt;&lt; endl; closedir(dir); return 0;&#125; #this_is_who_kinect_one.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392#include &lt;iostream&gt;#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;OpenNI.h&gt;#include &lt;dlib/dnn.h&gt;#include &lt;dlib/image_processing/frontal_face_detector.h&gt;#include &lt;dlib/image_processing/render_face_detections.h&gt;#include &lt;dlib/image_processing.h&gt;#include &lt;dlib/gui_widgets.h&gt;#include &lt;dlib/image_io.h&gt;#include &lt;dlib/opencv.h&gt;#include &lt;time.h&gt;#include &lt;dirent.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;sstream&gt; using namespace std;using namespace openni;using namespace dlib;using namespace cv;template &lt;template &lt;int,template&lt;typename&gt;class,int,typename&gt; class block, int N, template&lt;typename&gt;class BN, typename SUBNET&gt;using residual = add_prev1&lt;block&lt;N,BN,1,tag1&lt;SUBNET&gt;&gt;&gt;;template &lt;template &lt;int,template&lt;typename&gt;class,int,typename&gt; class block, int N, template&lt;typename&gt;class BN, typename SUBNET&gt;using residual_down = add_prev2&lt;avg_pool&lt;2,2,2,2,skip1&lt;tag2&lt;block&lt;N,BN,2,tag1&lt;SUBNET&gt;&gt;&gt;&gt;&gt;&gt;;template &lt;int N, template &lt;typename&gt; class BN, int stride, typename SUBNET&gt; using block = BN&lt;con&lt;N,3,3,1,1,relu&lt;BN&lt;con&lt;N,3,3,stride,stride,SUBNET&gt;&gt;&gt;&gt;&gt;;template &lt;int N, typename SUBNET&gt; using ares = relu&lt;residual&lt;block,N,affine,SUBNET&gt;&gt;;template &lt;int N, typename SUBNET&gt; using ares_down = relu&lt;residual_down&lt;block,N,affine,SUBNET&gt;&gt;;template &lt;typename SUBNET&gt; using alevel0 = ares_down&lt;256,SUBNET&gt;;template &lt;typename SUBNET&gt; using alevel1 = ares&lt;256,ares&lt;256,ares_down&lt;256,SUBNET&gt;&gt;&gt;;template &lt;typename SUBNET&gt; using alevel2 = ares&lt;128,ares&lt;128,ares_down&lt;128,SUBNET&gt;&gt;&gt;;template &lt;typename SUBNET&gt; using alevel3 = ares&lt;64,ares&lt;64,ares&lt;64,ares_down&lt;64,SUBNET&gt;&gt;&gt;&gt;;template &lt;typename SUBNET&gt; using alevel4 = ares&lt;32,ares&lt;32,ares&lt;32,SUBNET&gt;&gt;&gt;;using anet_type = loss_metric&lt;fc_no_bias&lt;128,avg_pool_everything&lt; alevel0&lt; alevel1&lt; alevel2&lt; alevel3&lt; alevel4&lt; max_pool&lt;3,3,2,2,relu&lt;affine&lt;con&lt;32,7,7,2,2, input_rgb_image_sized&lt;150&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;const int ITER = 5000; // 随机取点次数const float PLANE_OR_NOT = 0.2; // 判断是否为平面的分界线const int SIGMA = 1;int main()&#123; frontal_face_detector detector = get_frontal_face_detector(); // 人脸正脸检测器 shape_predictor sp; //人脸关键点检测器 anet_type net; // 人脸识别模型 deserialize(\"../model/shape_predictor_68_face_landmarks.dat\") &gt;&gt; sp; deserialize(\"../model/dlib_face_recognition_resnet_model_v1.dat\") &gt;&gt; net; std::vector&lt;matrix&lt;float,0,1&gt;&gt; candidates_descriptors; deserialize(\"../candidates_descriptors.dat\") &gt;&gt; candidates_descriptors; std::vector&lt;string&gt; candidates; deserialize(\"../candidates.dat\") &gt;&gt; candidates; // 1. Initial OpenNI if( OpenNI::initialize() != STATUS_OK ) &#123; cerr &lt;&lt; \"OpenNI Initial Error: \" &lt;&lt; OpenNI::getExtendedError() &lt;&lt; endl; return -1; &#125; // 2. Open Device Device mDevice; if( mDevice.open( ANY_DEVICE ) != STATUS_OK ) &#123; cerr &lt;&lt; \"Can't Open Device: \" &lt;&lt; OpenNI::getExtendedError() &lt;&lt; endl; return -1; &#125; // 3. Create depth stream VideoStream mDepthStream; if( mDevice.hasSensor( SENSOR_DEPTH ) ) &#123; if( mDepthStream.create( mDevice, SENSOR_DEPTH ) == STATUS_OK ) &#123; // 3a. set video mode VideoMode mMode; mMode.setResolution( 640, 480 ); mMode.setFps( 30 ); mMode.setPixelFormat( PIXEL_FORMAT_DEPTH_1_MM ); if( mDepthStream.setVideoMode( mMode) != STATUS_OK ) &#123; cout &lt;&lt; \"Can't apply VideoMode: \" &lt;&lt; OpenNI::getExtendedError() &lt;&lt; endl; &#125; &#125; else &#123; cerr &lt;&lt; \"Can't create depth stream on device: \" &lt;&lt; OpenNI::getExtendedError() &lt;&lt; endl; return -1; &#125; &#125; else &#123; cerr &lt;&lt; \"ERROR: This device does not have depth sensor\" &lt;&lt; endl; return -1; &#125; // 4. Create color stream VideoStream mColorStream; if( mDevice.hasSensor( SENSOR_COLOR ) ) &#123; if( mColorStream.create( mDevice, SENSOR_COLOR ) == STATUS_OK ) &#123; // 4a. set video mode VideoMode mMode; mMode.setResolution( 640, 480 ); mMode.setFps( 30 ); mMode.setPixelFormat( PIXEL_FORMAT_RGB888 ); if( mColorStream.setVideoMode( mMode) != STATUS_OK ) &#123; cout &lt;&lt; \"Can't apply VideoMode: \" &lt;&lt; OpenNI::getExtendedError() &lt;&lt; endl; &#125; // 4b. image registration if( mDevice.isImageRegistrationModeSupported( IMAGE_REGISTRATION_DEPTH_TO_COLOR ) ) &#123; mDevice.setImageRegistrationMode( IMAGE_REGISTRATION_DEPTH_TO_COLOR ); &#125; &#125; else &#123; cerr &lt;&lt; \"Can't create color stream on device: \" &lt;&lt; OpenNI::getExtendedError() &lt;&lt; endl; return -1; &#125; &#125; // 5. create OpenCV Window cv::namedWindow( \"Depth Image\", CV_WINDOW_AUTOSIZE); cv::namedWindow( \"Color Image\", CV_WINDOW_AUTOSIZE); // 6. start VideoFrameRef mColorFrame; VideoFrameRef mDepthFrame; mDepthStream.start(); mColorStream.start(); cv::Mat cImageBGR; cv::Mat DepthMat; int iMaxDepth = mDepthStream.getMaxPixelValue(); while( true ) &#123; // 8a. get depth frame if( mDepthStream.readFrame( &amp;mDepthFrame ) == STATUS_OK ) &#123; // 8b. convert data to OpenCV format const cv::Mat mImageDepth( mDepthFrame.getHeight(), mDepthFrame.getWidth(), CV_16UC1, (void*)mDepthFrame.getData() ); DepthMat = mImageDepth.clone(); // 8c. re-map depth data [0,Max] to [0,255] cv::Mat mScaledDepth; mImageDepth.convertTo( mScaledDepth, CV_8U, 255.0 / iMaxDepth ); // 8d. show image cv::imshow( \"Depth Image\", mScaledDepth ); &#125; // 7a. get color frame if( mColorStream.readFrame( &amp;mColorFrame ) == STATUS_OK ) &#123; // 7b. convert data to OpenCV format const cv::Mat mImageRGB( mColorFrame.getHeight(), mColorFrame.getWidth(), CV_8UC3, (void*)mColorFrame.getData() ); // 7c. convert form RGB to BGR cv::cvtColor( mImageRGB, cImageBGR, CV_RGB2BGR ); // 7d. show image //dlib cv_image&lt;bgr_pixel&gt; cimg(cImageBGR); // Detect faces std::vector&lt;dlib::rectangle&gt; dets = detector(cimg); if(dets.size() != 0)&#123; int livedetector; string who,isface; float who_probability; float pretotal_ary; if(dets.size() != 1)&#123; livedetector = -1; for (unsigned long j = 0; j &lt; dets.size(); ++j)&#123; Rect rect(dets[j].left(),dets[j].top(),dets[j].right() -dets[j].left(), dets[j].bottom() -dets[j].top());//左上坐标（x,y）和矩形的长(x)宽(y) cv::rectangle(cImageBGR, rect, Scalar(0, 255, 0),1,8,0); &#125; &#125; else&#123; Rect rect(dets[0].left(),dets[0].top(),dets[0].right() -dets[0].left(), dets[0].bottom() -dets[0].top());//左上坐标（x,y）和矩形的长(x)宽(y) cv::rectangle(cImageBGR, rect, Scalar(0, 255, 0),1,8,0); full_object_detection shape = sp(cimg, dets[0]); std::vector&lt;matrix&lt;rgb_pixel&gt;&gt; faces; matrix&lt;rgb_pixel&gt; face_chip; extract_image_chip(cimg, get_face_chip_details(shape,150,0.25), face_chip); faces.push_back(move(face_chip)); std::vector&lt;matrix&lt;float,0,1&gt;&gt; face_descriptors = net(faces); float distance; float best_distance = length(face_descriptors[0]-candidates_descriptors[0]); size_t candidates_num = candidates_descriptors.size(); int candidates_num_int = static_cast&lt;int&gt;(candidates_num); int best_k = 0; for (int k = 1; k &lt; candidates_num_int; k++) &#123; distance = length(face_descriptors[0]-candidates_descriptors[k]); if (distance &lt; best_distance) &#123; best_distance = distance; best_k = k; &#125; &#125; if (best_distance &lt; 0.6) &#123; who = candidates[best_k]; who_probability = (1.05-0.66*best_distance)*100 &lt; 100?(1.05-0.66*best_distance)*100:99; &#125; else&#123; who = \"Unknow\"; &#125; // liveness_detection(DepthMat,locates,livedetector); int COL ,ROW ,FACE_WIDTH ,FACE_HEIGHT; int faceno0_num; int FaceDATA[3][100000]; int k; int pretotal; int x[3],y[3],z[3]; // 随机取三个点 float a,b,c; // 拟合平面方程 z=ax+by+c int rand_num[3]; float check,distance2; int total; COL = rect.x; ROW = rect.y; FACE_WIDTH = rect.width; FACE_HEIGHT = rect.height; faceno0_num = FACE_HEIGHT*FACE_WIDTH -1; k = 0; for(int m = 1;m&lt; FACE_HEIGHT+1;m++) &#123; for(int n= 1;n&lt; FACE_WIDTH+1;n++) &#123; ushort tmp = DepthMat.at&lt;ushort&gt;(COL+n-1,ROW+m-1); if (tmp == 0) &#123; faceno0_num -= 1; // 非零深度点个数为 faceno0_num+1 continue; &#125; FaceDATA[0][k] = n; FaceDATA[1][k] = m; FaceDATA[2][k] = tmp; k += 1; &#125; &#125; if(faceno0_num &gt; 2000)&#123; pretotal = 0; // 符合拟合模型的数据的个数 srand((unsigned)time(NULL)); total = 0; for(k = 0; k &lt; ITER; k++) &#123; do&#123; rand_num[0] = std::rand()%faceno0_num; rand_num[1] = std::rand()%faceno0_num; rand_num[2] = std::rand()%faceno0_num; &#125;while(rand_num[0] == rand_num[1] || rand_num[0] == rand_num[2] || rand_num[1] == rand_num[2]); for(int n = 0; n &lt; 3; n++ ) &#123; x[n] = FaceDATA[0][rand_num[n]]; y[n] = FaceDATA[1][rand_num[n]]; z[n] = FaceDATA[2][rand_num[n]]; &#125; check = (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]); if ( check == 0) // 防止提示浮点数例外 (核心已转储) &#123; k -= 1; continue; &#125; a = ( (z[0]-z[1])*(y[0]-y[2]) - (z[0]-z[2])*(y[0]-y[1]) )*1.0/( (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]) ); if (y[0] == y[2]) // 防止提示浮点数例外 (核心已转储) &#123; k -= 1; continue; &#125; b = ((z[0] - z[2]) - a * (x[0] - x[2]))*1.0/(y[0]-y[2]); c = z[0]- a * x[0] - b * y[0]; total = 0; for(int n = 0; n &lt; faceno0_num +1 ; n++ ) &#123; distance2 = fabs(a*FaceDATA[0][n] + b*FaceDATA[1][n] - 1*FaceDATA[2][n] + c*1); if (distance2 &lt; SIGMA) &#123; total +=1; &#125; &#125; if (total &gt; pretotal) // 找到符合拟合平面数据最多的拟合平面 &#123; pretotal=total; &#125; &#125; pretotal_ary = pretotal *1.0/ faceno0_num; if (pretotal_ary &lt; PLANE_OR_NOT)&#123; livedetector = 1; &#125; else&#123; livedetector = 0; &#125; &#125; else&#123; livedetector = -2; &#125; &#125; if(livedetector == -1)&#123; who = \"More than one face\"; isface = \"Please detect one face\"; &#125; if(livedetector == 1)&#123; isface = \"Is FACE\"; &#125; if(livedetector == 0)&#123; isface = \"Is not FACE\"; &#125; if(livedetector == -2)&#123; isface = \"Lack of depth information\"; pretotal_ary = 0; &#125; stringstream strStream1; strStream1 &lt;&lt; who &lt;&lt; \" , \" &lt;&lt; who_probability &lt;&lt; \"%\"; string str1 = strStream1.str(); stringstream strStream2; strStream2 &lt;&lt; isface &lt;&lt; \" , \" &lt;&lt; \"pretotal_ary:\" &lt;&lt; pretotal_ary; string str2 = strStream2.str(); cv::putText(cImageBGR, \"RECOGNITION RESULT: \", cv::Point(20,20), cv::FONT_HERSHEY_COMPLEX,0.4,Scalar(255, 255, 255),1,8,0); cv::putText(cImageBGR, str1, cv::Point(20,40), cv::FONT_HERSHEY_COMPLEX,0.5,Scalar(0, 255, 0),1,8,0); cv::putText(cImageBGR, \"LIVENESS DETECTION RESULT: \", cv::Point(20,60), cv::FONT_HERSHEY_COMPLEX,0.4,Scalar(255, 255, 255),1,8,0); cv::putText(cImageBGR, str2, cv::Point(20,80), cv::FONT_HERSHEY_COMPLEX,0.5,Scalar(0, 255, 0),1,8,0); &#125; cv::imshow( \"Color Image\", cImageBGR); &#125; // 6a. check keyboard if( cv::waitKey( 1 ) == 'q' )&#123; break; &#125; &#125; // 9. stop mDepthStream.destroy(); mColorStream.destroy(); mDevice.close(); OpenNI::shutdown(); return 0;&#125; #this_is_who.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#include &lt;dlib/dnn.h&gt;#include &lt;dlib/image_processing/frontal_face_detector.h&gt;#include &lt;dlib/image_processing.h&gt;#include &lt;dlib/gui_widgets.h&gt;#include &lt;dlib/image_io.h&gt;#include &lt;iostream&gt;#include &lt;time.h&gt;#include &lt;dirent.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;using namespace dlib;using namespace std;/* 函数声明 *//* 输出人脸位置 返回识别结果 */string face_location(const char *imgFile,std::vector&lt;int&gt;&amp;locates, std::vector&lt;matrix&lt;float,0,1&gt;&gt;&amp;candidates_descriptors,std::vector&lt;string&gt;&amp;candidates);/* 判断是否为活体 */bool liveness_detection(const char *DeepFile,std::vector&lt;int&gt;&amp;locates); const int IMG_HEIGHT = 720;const int IMG_WIDTH = 1280;template &lt;template &lt;int,template&lt;typename&gt;class,int,typename&gt; class block, int N, template&lt;typename&gt;class BN, typename SUBNET&gt;using residual = add_prev1&lt;block&lt;N,BN,1,tag1&lt;SUBNET&gt;&gt;&gt;;template &lt;template &lt;int,template&lt;typename&gt;class,int,typename&gt; class block, int N, template&lt;typename&gt;class BN, typename SUBNET&gt;using residual_down = add_prev2&lt;avg_pool&lt;2,2,2,2,skip1&lt;tag2&lt;block&lt;N,BN,2,tag1&lt;SUBNET&gt;&gt;&gt;&gt;&gt;&gt;;template &lt;int N, template &lt;typename&gt; class BN, int stride, typename SUBNET&gt; using block = BN&lt;con&lt;N,3,3,1,1,relu&lt;BN&lt;con&lt;N,3,3,stride,stride,SUBNET&gt;&gt;&gt;&gt;&gt;;template &lt;int N, typename SUBNET&gt; using ares = relu&lt;residual&lt;block,N,affine,SUBNET&gt;&gt;;template &lt;int N, typename SUBNET&gt; using ares_down = relu&lt;residual_down&lt;block,N,affine,SUBNET&gt;&gt;;template &lt;typename SUBNET&gt; using alevel0 = ares_down&lt;256,SUBNET&gt;;template &lt;typename SUBNET&gt; using alevel1 = ares&lt;256,ares&lt;256,ares_down&lt;256,SUBNET&gt;&gt;&gt;;template &lt;typename SUBNET&gt; using alevel2 = ares&lt;128,ares&lt;128,ares_down&lt;128,SUBNET&gt;&gt;&gt;;template &lt;typename SUBNET&gt; using alevel3 = ares&lt;64,ares&lt;64,ares&lt;64,ares_down&lt;64,SUBNET&gt;&gt;&gt;&gt;;template &lt;typename SUBNET&gt; using alevel4 = ares&lt;32,ares&lt;32,ares&lt;32,SUBNET&gt;&gt;&gt;;using anet_type = loss_metric&lt;fc_no_bias&lt;128,avg_pool_everything&lt; alevel0&lt; alevel1&lt; alevel2&lt; alevel3&lt; alevel4&lt; max_pool&lt;3,3,2,2,relu&lt;affine&lt;con&lt;32,7,7,2,2, input_rgb_image_sized&lt;150&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;int main(int argc, char** argv)&#123; if (argc == 1) &#123; cout &lt;&lt; \"\\nCall this program like this:\" &lt;&lt; endl; cout &lt;&lt; \"./this_is_who ../data/allface/0004_IR_allleft.jpg ../data/allface/0004_raw_allleft.raw\" &lt;&lt; endl; return 0; &#125; const char *imgFile = argv[1]; const char *DeepFile = argv[2]; std::vector&lt;matrix&lt;float,0,1&gt;&gt; candidates_descriptors; deserialize(\"../candidates_descriptors.dat\") &gt;&gt; candidates_descriptors; std::vector&lt;string&gt; candidates; deserialize(\"../candidates.dat\") &gt;&gt; candidates; std::vector&lt;int&gt; locates; /* 输出人脸位置 返回识别结果 */ string who = face_location(imgFile, locates, candidates_descriptors,candidates); cout &lt;&lt; \"\\nRECOGNITION RESULT：\" &lt;&lt; endl; cout &lt;&lt; \"This is \" &lt;&lt; who &lt;&lt; endl; //深度图与红外图是水平翻转的 locates[0] = IMG_WIDTH - locates[0] -locates[2]; /* 判断是否为活体 */ liveness_detection( DeepFile, locates);&#125;/* 函数 输出人脸位置 返回识别结果 */string face_location(const char* imgFile,std::vector&lt;int&gt;&amp;locates, std::vector&lt;matrix&lt;float,0,1&gt;&gt;&amp;candidates_descriptors,std::vector&lt;string&gt;&amp;candidates)&#123; frontal_face_detector detector = get_frontal_face_detector(); // 人脸正脸检测器 shape_predictor sp; //人脸关键点检测器 anet_type net; // 人脸识别模型 deserialize(\"../model/shape_predictor_68_face_landmarks.dat\") &gt;&gt; sp; deserialize(\"../model/dlib_face_recognition_resnet_model_v1.dat\") &gt;&gt; net; cout &lt;&lt; \"\\nprocessing image \" &lt;&lt; imgFile &lt;&lt; endl; matrix&lt;rgb_pixel&gt; img; load_image(img, imgFile); std::vector&lt;rectangle&gt; dets = detector(img); // cout &lt;&lt; \"Number of faces detected: \" &lt;&lt; dets.size() &lt;&lt; endl; locates.push_back(dets[0].left()); locates.push_back(dets[0].top()); locates.push_back(dets[0].right() - dets[0].left()); locates.push_back(dets[0].bottom() - dets[0].top()); full_object_detection shape = sp(img, dets[0]); std::vector&lt;matrix&lt;rgb_pixel&gt;&gt; faces; matrix&lt;rgb_pixel&gt; face_chip; extract_image_chip(img, get_face_chip_details(shape,150,0.25), face_chip); faces.push_back(move(face_chip)); std::vector&lt;matrix&lt;float,0,1&gt;&gt; face_descriptors = net(faces); float distance; float best_distance = length(face_descriptors[0]-candidates_descriptors[0]); size_t candidates_num = candidates_descriptors.size(); int candidates_num_int = static_cast&lt;int&gt;(candidates_num); int best_k = 0; for (int k = 1; k &lt; candidates_num_int; k++) &#123; distance = length(face_descriptors[0]-candidates_descriptors[k]); if (distance &lt; best_distance) &#123; best_distance = distance; best_k = k; &#125; &#125; string who; if (best_distance &lt; 0.6) &#123; who = candidates[best_k]; &#125; else&#123; who = \"Unknow\"; &#125; return who;&#125;/* 函数判断是否为活体 */bool liveness_detection(const char *DeepFile,std::vector&lt;int&gt;&amp;locates)&#123; const int ITER = 5000; // 随机取点次数 const float PLANE_OR_NOT = 0.2; // 判断是否为平面的分界线 const int SIGMA = 1; typedef unsigned short UNIT16; // 从.raw读取二进制16位数据到MatDATA UNIT16 MatDATA[IMG_HEIGHT*IMG_WIDTH]; FILE *fp = NULL; fp = fopen( DeepFile, \"rb\" ); size_t sizeRead = fread(MatDATA,sizeof(UNIT16),IMG_HEIGHT*IMG_WIDTH,fp); if (sizeRead != IMG_HEIGHT*IMG_WIDTH) &#123; cout &lt;&lt; \"DeepFile open error!\" &lt;&lt; endl; return 0; &#125; fclose(fp); int n = 0; int i,j; int COL = locates[0],ROW = locates[1],FACE_WIDTH = locates[2],FACE_HEIGHT = locates[3]; //位置信息 // txt :157 66 172 198 , 取行66：66+198,列取157：157+172 int faceno0_num = FACE_HEIGHT*FACE_WIDTH -1; int FaceDATA[3][100000]; n = 0; for(i = 1;i&lt; FACE_HEIGHT+1;i++) &#123; for(j= 1;j&lt; FACE_WIDTH+1;j++) &#123; if (MatDATA[IMG_WIDTH*(ROW+i-2)+COL+j-2] == 0) &#123; faceno0_num -= 1; // 非零深度点个数为 faceno0_num+1 continue; &#125; FaceDATA[1][n] = i; FaceDATA[0][n] = j; FaceDATA[2][n] = MatDATA[IMG_WIDTH*(ROW+i-2)+COL+j-2]; n += 1; &#125; &#125; int pretotal = 0; // 符合拟合模型的数据的个数 int x[3],y[3],z[3]; // 随机取三个点 srand((unsigned)time(NULL)); float a,b,c; // 拟合平面方程 z=ax+by+c // float besta,bestb,bestc; // 最佳参数 int rand_num[3]; float check,distance; int total = 0; for(i = 0; i &lt; ITER; i++) &#123; do&#123; rand_num[0] = std::rand()%faceno0_num; rand_num[1] = std::rand()%faceno0_num; rand_num[2] = std::rand()%faceno0_num; &#125;while(rand_num[0] == rand_num[1] || rand_num[0] == rand_num[2] || rand_num[1] == rand_num[2]); for(n = 0; n &lt; 3; n++ ) &#123; x[n] = FaceDATA[0][rand_num[n]]; y[n] = FaceDATA[1][rand_num[n]]; z[n] = FaceDATA[2][rand_num[n]]; &#125; check = (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]); if ( check == 0) // 防止提示浮点数例外 (核心已转储) &#123; i -= 1; continue; &#125; a = ( (z[0]-z[1])*(y[0]-y[2]) - (z[0]-z[2])*(y[0]-y[1]) )*1.0/( (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]) ); if (y[0] == y[2]) // 防止提示浮点数例外 (核心已转储) &#123; i -= 1; continue; &#125; b = ((z[0] - z[2]) - a * (x[0] - x[2]))*1.0/(y[0]-y[2]); c = z[0]- a * x[0] - b * y[0]; total = 0; for(n = 0; n &lt; faceno0_num +1 ; n++ ) &#123; distance = fabs(a*FaceDATA[0][n] + b*FaceDATA[1][n] - 1*FaceDATA[2][n] + c*1); if (distance &lt; SIGMA) &#123; total +=1; &#125; &#125; if (total &gt; pretotal) // 找到符合拟合平面数据最多的拟合平面 &#123; pretotal=total; // besta = a; // bestb = b; // bestc = c; &#125; &#125; float pretotal_ary = pretotal *1.0/ faceno0_num ; cout &lt;&lt; \"\\nLIVENESS DETECTION RESULT：\" &lt;&lt; endl; bool IS_FACE; if (pretotal_ary &lt; PLANE_OR_NOT) &#123; IS_FACE = true; cout &lt;&lt; \"pretotal_ary = \" &lt;&lt; pretotal_ary &lt;&lt; \" , Is FACE!\" &lt;&lt; endl; &#125; else &#123; IS_FACE = false; cout &lt;&lt; \"pretotal_ary = \" &lt;&lt; pretotal_ary &lt;&lt; \" , Is not FACE!\" &lt;&lt; endl; &#125; return IS_FACE;&#125; 代码比较粗糙，应该以后也不会再改了……","categories":[{"name":"深度相机","slug":"深度相机","permalink":"http://yoursite.com/categories/深度相机/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"活体检测","slug":"活体检测","permalink":"http://yoursite.com/tags/活体检测/"},{"name":"Dlib","slug":"Dlib","permalink":"http://yoursite.com/tags/Dlib/"},{"name":"Opencv","slug":"Opencv","permalink":"http://yoursite.com/tags/Opencv/"},{"name":"Kinect","slug":"Kinect","permalink":"http://yoursite.com/tags/Kinect/"},{"name":"实时人脸识别","slug":"实时人脸识别","permalink":"http://yoursite.com/tags/实时人脸识别/"}]},{"title":"ElasticFusion在ubuntu16.04+cuda8.0上的实现","slug":"15","date":"2019-04-12T13:06:41.000Z","updated":"2019-12-18T04:14:43.160Z","comments":true,"path":"2019/04/12/15/","link":"","permalink":"http://yoursite.com/2019/04/12/15/","excerpt":"一、驱动与cuda安装#安装驱动与cuda8.0参考这篇：https://blog.csdn.net/ffcjjhv/article/details/89151382 二、配置1、依赖包","text":"一、驱动与cuda安装#安装驱动与cuda8.0参考这篇：https://blog.csdn.net/ffcjjhv/article/details/89151382 二、配置1、依赖包 123sudo apt-get install cmake cmake-qt-gui git build-essential libusb-1.0-0-dev libudev-dev sudo apt-get install freeglut3-dev libglew-dev libsuitesparse-dev libeigen3-dev sudo apt-get install zlib1g-dev libjpeg-dev doxygen graphviz 2、openjdk-7-jdk123sudo add-apt-repository ppa:openjdk-r/ppasudo apt-get updatesudo apt-get install openjdk-7-jdk 3、OpenGL123sudo apt-get install build-essential libgl1-mesa-devsudo apt-get install freeglut3-devsudo apt-get install libglew-dev libsdl2-dev libsdl2-image-dev libglm-dev libfreetype6-dev 三、代码编译#download ElasticFusionGitHub地址：https://github.com/mp3guy/ElasticFusion ，解压到ElasticFusion/ElasticFusion-master 1cd ElasticFusion 1、安装 Pangolin123456git clone https://github.com/stevenlovegrove/Pangolin.gitcd Pangolinmkdir build &amp;&amp; cd buildcmake ../ -DAVFORMAT_INCLUDE_DIR=\"\" -DCPP11_NO_BOOST=ONmake -j4cd ../.. 2、安装 OpenNI21234git clone https://github.com/occipital/OpenNI2.gitcd OpenNI2make -j4cd .. 3、配置 ElasticFusion（1）build Core12345cd ElasticFusion-master/Coremkdir build &amp;&amp; cd buildcmake ../srcmake -j4cd ../../ （2）build GPUTest12345cd GPUTestmkdir build &amp;&amp; cd buildcmake ../srcmake -j4cd ../../ （3）build GUI12345cd GUImkdir build &amp;&amp; cd buildcmake ../srcmake -j4cd ../../ 四、 运行1、数据集离线运行下载数据集： http://www.doc.ic.ac.uk/~sleutene/datasets/elasticfusion/dyson_lab.klg ，放到ElasticFusion/ElasticFusion-master/GUI/build，并运行 1./ElasticFusion -l dyson_lab.klg #运行结果 2、在Kinect v1上实时运行（1）build libFreenect123cd ElasticFusiongit clone https://github.com/OpenKinect/libfreenectcd libfreenect 打开libfreenect/CMakeLists.txt，在33行cmake_minimum_required(VERSION 2.8.12)下一行添加 1add_definitions(-std=c++11) 保存后关闭，命令行继续执行 1234mkdir build &amp;&amp; cd build cmake .. -DBUILD_OPENNI2_DRIVER=ON make -j4cp -L lib/OpenNI2-FreenectDriver/libFreenectDriver.so $&#123;OPENNI2_DIR&#125;/Bin/x64-Release/OpenNI2/Drivers #OPENNI2_DIR需要修改 注：${OPENNI2_DIR}是OpenNI2的解压文件夹，比如我的在ElasticFusion文件夹，则 （2）Kinect v1接入打开libfreenect文件夹，运行 1sudo cp platform/linux/udev/51-kinect.rules /etc/udev/rules.d 重启后，插上kinect后，命令行运行lsusb，查看是否包含：Xbox camera，Xbox motor，Xbox audio （3）修改GPUConfig.h如果代码运行很慢且出现如下提示，需要修改修改GPUConfig.h在ElasticFusion/ElasticFusion-master/GPUtest/build文件夹运行 1./GPUTest ../ 将最后4行添加到/ElasticFusion/ElasticFusion-master/Core/src/Utils/GPUConfig.h （4）运行打开ElasticFusion/ElasticFusion-master/GUI/build，运行 1./ElasticFusion #运行结果","categories":[{"name":"深度相机","slug":"深度相机","permalink":"http://yoursite.com/categories/深度相机/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"RGBD","slug":"RGBD","permalink":"http://yoursite.com/tags/RGBD/"},{"name":"ElasticFusion","slug":"ElasticFusion","permalink":"http://yoursite.com/tags/ElasticFusion/"},{"name":"三维重建","slug":"三维重建","permalink":"http://yoursite.com/tags/三维重建/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"BundleFusion在win10+vs2013+cuda8.0上的实现","slug":"21","date":"2019-04-12T03:06:00.000Z","updated":"2019-12-18T04:17:16.164Z","comments":true,"path":"2019/04/12/21/","link":"","permalink":"http://yoursite.com/2019/04/12/21/","excerpt":"介绍在深度相机室内实时稠密三维重建领域，BundleFusion是目前效果最好的开源算法框架。论文地址：https://arxiv.org/pdf/1604.01093.pdf演示视频截取片断：","text":"介绍在深度相机室内实时稠密三维重建领域，BundleFusion是目前效果最好的开源算法框架。论文地址：https://arxiv.org/pdf/1604.01093.pdf演示视频截取片断： 视频地址：https://www.youtube.com/watch?v=keIirXrRb1k在演示视频中，structure sensor是卡在iPad上，将采集到的数据通过无线网络传给台式机（带GPU），匹配、优化和重建工作都是在台式机上运行，重建的结果再通过无线网络传到iPad上显示。重建效果图： 一、配置1、cuda8.0安装#建议安装：cuda8.0，vs2013 #卸载cuda10.0在控制面板/卸载程序，卸载掉所有带有NVIDIA的程序，卸载顺序不影响 #下载cuda8.0：https://developer.nvidia.com/cuda-80-ga2-download-archive ，并运行安装。 #验证安装成功，输入nvcc --version 2、DirectX SDK安装下载地址：http://download.microsoft.com/download/A/E/7/AE743F1F-632B-4809-87A9-AA1BB3458E31/DXSDK_Jun10.exe ，运行安装。 #若运行安装出现 错误 ErrorCode:s1023解决办法1：控制面板卸载以上两项，再重新安装DXSDK_Jun10.exe即可。 大部分通过这个方法可以解决，如果以上两项不存在或者卸载后仍不能解决问题（比如我），可能Microsoft Visual C++ 运行库安装有问题，得删除并重新安装 Microsoft Visual C++ 运行库，步骤如下： 1、控制面板卸载名称包含“Microsoft Visual C++”和“Redistributable”的所有程序2、下载并安装以下所有软件： Microsoft Visual C++ 2005 SP1 Redistributable (x86) Microsoft Visual C++ 2005 SP1 Redistributable (x64) Microsoft Visual C++ 2008 SP1 Redistributable (x86) Microsoft Visual C++ 2008 SP1 Redistributable (x64)Microsoft Visual C++ 2010 SP1 Redistributable (x86)Microsoft Visual C++ 2010 SP1 Redistributable (x64)Microsoft Visual C++ 2012 Update 4 Redistributable(x86 和 x64)Microsoft Visual C++ 2013 Update 5 Redistributable Package(x86 和 x64)Microsoft Visual C++ 2015 Update 3 Redistributable(x86 和 x64) 注意： 每个下载的文件名均相同，因此在安装它之前，请确保不覆盖之前的文件。下载一个安装一个，然后再下载下一个并安装，依此类推。 64 位系统上需要 x86 和 x64 版本。32 位系统只需要 x86 版本。 3、重启后，控制面板卸载2010两项，再重新安装DXSDK_Jun10.exe，即可解决。 二、vs2013代码生成BundleFusion GitHub地址：https://github.com/niessner/BundleFusion配置过程主要参考这里 从GitHub上下载该BundleFusion，并解压，得到工程 BundleFusioin-master 1、mLib与 mLib external配置mLib下载地址：https://github.com/niessner/mLib ，解压后，替换掉目录 BundleFusion-master\\external\\mLib mLib external下载地址：https://www.dropbox.com/s/fve3uen5mzonidx/mLibExternal.zip?dl=0 ，解压后，放到 BundleFusioin-master 同级目录,网址访问不了的话可以用我传到网盘的mLibExternal.zip：链接：https://pan.baidu.com/s/1CJysQCHl4t7RPfvqliwfew 提取码：0x4t 最终目录结构： 123456789101112131415bundlefusion BundleFusion-master/ external/ mLib/ # this is the submodule you replaced data/ src/ [...] FriedLiver/ [...] FriedLiver.sln [...] mLibExternal/ # you downloaded this from Dropbox include libsWindows [...] 2、cuda设置修改cuda版本用VS2013打开 BundleFusion-master\\FriedLiver\\FriedLiver.sln 工程，如果cuda版本不是原代码设置的cuda7.0，就会出现如下错误：修改 BundleFusion-master\\FriedLiver\\FriedLiver.vcxproj 文件，用vs code打开该文件，并修改如下两行：再次打开就不会报错了。 显卡计算能力设置选择适合你显卡的compute能力，显卡计算能力在这里查询我的笔记本显卡NVIDIA GeForce MX150，计算能力与GeForce 940M等同，为5.0，在工程的配置选项中设置如下： 3、相机类型设置（以apt0.sens离线数据为例）输入类型输入数据可以为Kinect v1，Kinect v2，PrimeSenseSensor，IntelSensor，RealSense，StructureSensor以及SensorDataReader（离线数据）具体可以查看FriedLiver.cpp中7-103行的内容 没有深度相机的，以离线数据office3.sens为例，下载地址：http://graphics.stanford.edu/projects/bundlefusion/ 修改GlobalAppState.h因为使用的是离线数据，将GlobalAppState.h中深度相机全部注释掉。注：如果用深度相机（如：Kinect v1）实时运行，用哪个将哪个取消注释，并安装对应SDK。 4、生成FriedLiver.exe修改为 Release 版本，然后选择 生成-&gt;生成解决方法编译通过后，如下图：在BundleFusion-master\\FriedLiver\\x64\\Release中生成可执行文件FriedLiver.exe 三、运行与结果1、配置文件修改将BundleFusion-master\\FriedLiver 目录下的 zParametersBundlingDefault.txt 和 zParametersDefault.txt 拷贝到 BundleFusion-master\\FriedLiver\\x64\\Release 修改zParametersDefault.txt用vs code打开 zParametersDefault.txt 配置文件，选择输入类型，这里使用离线数据，修改第2行，设置s_sensorIdx = 8 。如果用深度相机（如：Kinect v1）实时运行，修改为对应的序列号。修改第49行，设置s_hashNumSDFBlocks = 100000修改第58行，设置输入路径s_binaryDumpSensorFile = &quot;../data/office3.sens&quot;将下载的office3.sens放置到BundleFusion-master\\FriedLiver\\x64\\data 修改zParametersBundlingDefault.txt双击运行后，若出现窗口崩溃或者没有响应直接跳出，如下图：用vs code打开 zParametersBundlingDefault.txt 配置文件，修改第30行，设置s_maxNumImages = 400 2、运行结果配置修改后，双击运行FriedLiver.exe按下tab键，如下图所示，按照提示与软件进行交互，按下ctrl+2显示带颜色深度，按下ctrl+3显示彩色视频流，按下ctrl+9导出当前模型到FriedLiver\\x64\\Release\\scans\\scan.ply ，具体实现代码查看FriedLiver\\Source\\DepthSensing\\DepthSensing.cpp 3、模型生成运行结束后，BundleFusion-master\\FriedLiver\\x64\\data\\office3.sens同目录下生成office3.ply，用meshlab打开 4、在Kinect v1上的实时运行安装 Kinect SDK v1.8 Kinect for Windows SDK v1.8 Kinect for Windows Developer Toolkit v1.8 下载后默认安装 设置Kinect v1输入 重新打开 BundleFusion-master\\FriedLiver\\FriedLiver.sln 工程，将GlobalAppState.h中第三行取消注释 选择 生成-&gt;生成解决方法，即可编译通过。 zParametersDefault.txt 配置文件，选择输入类型，这里使用Kinect v1，修改第2行，设置s_sensorIdx = 0 实时运行插上Kinect v1，双击运行FriedLiver.exe","categories":[{"name":"深度相机","slug":"深度相机","permalink":"http://yoursite.com/categories/深度相机/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"BundleFusion","slug":"BundleFusion","permalink":"http://yoursite.com/tags/BundleFusion/"},{"name":"Win10","slug":"Win10","permalink":"http://yoursite.com/tags/Win10/"},{"name":"室内重建","slug":"室内重建","permalink":"http://yoursite.com/tags/室内重建/"}]},{"title":"DynamicFusion在ubuntu16.04+显卡GT740+cuda8.0上的实现","slug":"14","date":"2019-04-09T10:10:06.000Z","updated":"2019-12-18T04:13:14.533Z","comments":true,"path":"2019/04/09/14/","link":"","permalink":"http://yoursite.com/2019/04/09/14/","excerpt":"介绍DynamicFusion构建了一个可以实时重建 非刚性变形 动态场景 的系统，随着新的数据融合进模型当中，模型得到降噪、细节更加精细。","text":"介绍DynamicFusion构建了一个可以实时重建 非刚性变形 动态场景 的系统，随着新的数据融合进模型当中，模型得到降噪、细节更加精细。 论文地址：http://grail.cs.washington.edu/projects/dynamicfusion/papers/DynamicFusion.pdfGitHub地址：https://github.com/mihaibujanca/dynamicfusion注意：这个项目是对论文的复现，但是目前尚未准确复现论文内容，运行速度仍然有待优化，10s/frame不满足实时运行，建议转换成离线数据，再进行运行。 这里记录DynamicFusion在ubuntu16.04+显卡GT740+cuda8.0上的实现。（虽然可以实现，但是GT740真的是太慢慢慢慢了…电脑是刚重装完系统的机子） 1、驱动与cuda安装（1）驱动安装a.驱动下载#查看显卡型号 1lspci | grep -i nvidia nvidia官网 https://www.geforce.cn/drivers 搜索显卡型号对应的驱动，下载（别用最新的）后放到home文件夹 b.禁用nouveau驱动1sudo gedit /etc/modprobe.d/blacklist.conf 在文本最后添加： 12blacklist nouveauoptions nouveau modeset=0 然后执行： 1sudo update-initramfs -u 重启后，屏幕分辨率可能不对不用管，命令行执行：lsmod | grep nouveau ，如果没有屏幕输出，说明禁用nouveau成功。 c.禁用X-Window服务#注意：这会关闭图形界面，提前用手机或者笔记本看下面的步骤 1sudo service lightdm stop 按Ctrl-Alt+F1进入命令行界面，输入用户名和密码登录。 d.命令行安装驱动#给驱动run文件赋予执行权限： 1sudo chmod +x NVIDIA-Linux-x86_64-384.59.run #后面的参数不可省略： 1sudo ./NVIDIA-Linux-x86_64-384.59.run –no-opengl-files 按照提示安装，回车确定，成功安装后在命令行输入：sudo service lightdm start，恢复到图形界面，此时屏幕分辨率恢复正常，重启。 e.驱动测试1sudo nvidia-smi 若列出GPU的信息列表，表示驱动安装成功。 （2）cuda7.5安装cuda7.5可以使用命令行安装，到了cuda8.0以及往上就不行了 12sudo apt-get updatesudo apt-get install nvidia-cuda-dev nvidia-cuda-toolkit nvidia-nsight nvidia-prime 等待安装完成后，输入nvcc -V，检查是否安装成功。 2、环境配置下载DynamicFusion代码：https://github.com/mihaibujanca/dynamicfusion整个配置过程参考dynamicfusion-master/build.sh 文件（不要直接运行build.sh会有各种报错） （1）apt-get install 依赖安装123sudo apt-get install cmake libvtk5-dev libsuitesparse-dev liblapack-dev --fix-missingsudo apt-get install libblas-dev libgtk2.0-dev pkg-config libopenni-dev --fix-missingsudo apt-get install libusb-1.0-0-dev wget zip clang --fix-missing （2）安装gflags、glog、Eigen、Ceres进入dynamicfusion-master文件夹的上一目录 安装gflags、glog、Eigen#安装 gflags 12345git clone https://github.com/gflags/gflags.gitcd gflagsmkdir -p build/ &amp;&amp; cd buildcmake .. &amp;&amp; make cd ../../ #安装 glog 12345git clone https://github.com/google/glog.gitcd glogmkdir -p build/ &amp;&amp; cd build/cmake .. &amp;&amp; makecd ../../ #安装 Eigen 3.3.4 1234567wget http://bitbucket.org/eigen/eigen/get/3.3.4.tar.gztar -xf 3.3.4.tar.gzcd eigen-eigen-5a0156e40febmkdir -p build &amp;&amp; cd buildcmake ..sudo make installcd ../../ 配置ceres-solver#下载ceres-solver：https://github.com/ceres-solver/ceres-solver 并解压到dynamicfusion-master文件夹的上一目录 ，将ceres-solver-master重命名为ceres-solver #配置 Ceres 123456cd ceres-solvermkdir -p build/ &amp;&amp; cd build/cmake ..make -j4sudo make installcd ../../ （3）安装OpenCV 2.4.13注：opencv的下载过程非常非常慢，建议前天晚上下载，第二天再接着配置 12345678git clone https://github.com/opencv/opencvcd opencv/git checkout 2.4.13.3mkdir -p build &amp;&amp; cd buildcmake -DWITH_VTK=ON -DBUILD_opencv_calib3d=ON -DBUILD_opencv_imgproc=ON -DWITH_CUDA=OFF ..make -j4sudo make installcd ../../ （4）安装Boost1234567wget https://dl.bintray.com/boostorg/release/1.64.0/source/boost_1_64_0.tar.gztar -xf boost_1_64_0.tar.gzcd boost_1_64_0sudo ./bootstrap.sh./b2sudo ./b2 installcd .. 删除掉无用的压缩包，最终目录如图 3、代码修改与dataset获取（1）配置deps/terra12345cd dynamicfusion-master/depswget https://github.com/zdevito/terra/releases/download/release-2016-03-25/terra-Linux-x86_64-332a506.zipunzip terra-Linux-x86_64-332a506.ziprm terra-Linux-x86_64-332a506.zipmv terra-Linux-x86_64-332a506 terra （2）配置deps/Opt#下载Opt：https://github.com/niessner/Opt/tree/c6012e7e4c67fa3bea96161ba24fe88a2b79deed ，并解压到deps，重命名为Opt 12cd Opt/API/make -j4 （3）修改kfusion/src/warp_field.cpp为了解决之后运行代码会出现的报错 12.../dynamicfusion/kfusion/src/warp_field.cpp:158:10: error: ‘struct ceres::Solver::Options’ has no member named ‘num_threads_used’options.num_threads_used = 8; 将第157行options.num_linear_solver_threads = 8;注释掉 （4）dataset下载下载地址 https://www.dropbox.com/sh/qgy2n9bmioofqnj/AABUnT7pi2ECpxSi80EmXOXna?dl=0 （给的数据挺多的，如果网站上不去可以下载我传到百度云的数据，只传了作为demo的umbrella_data.zip） umbrella_data.zip下载链接：https://pan.baidu.com/s/1PRf7-xl5vgj2SUQVNiuk-g ，提取码：25s1下载后放置到dynamicfusion-master文件夹中，运行 12345678910mkdir -p data/umbrella/depthmkdir -p data/umbrella/colormv umbrella_data.zip data/umbrellacd data/umbrellaunzip umbrella_data.ziprm *.txtmv *color*.png color/mv *depth*.png depth/rm umbrella_data.zip 4、运行（1）编译进入dynamicfusion-master文件夹，运行 123mkdir -p build &amp;&amp; cd buildcmake -DOpenCV_DIR=~/opencv/build -DBOOST_ROOT=~/boost_1_64_0/ -DOPENNI_INCLUDE_DIR=/usr/include/ni -DOpenCV_FOUND=TRUE ..make -j4 （2）运行与报错进入dynamicfusion-master文件夹，运行 1./build/bin/dynamicfusion data/umbrella 运行后报错 llvm: No such file or directory ,查看这里：https://github.com/mihaibujanca/dynamicfusion/issues/54升级cuda7.5到8.0能够解决 （3）升级cuda7.5到8.0卸载cuda7.51sudo apt-get autoremove nvidia-cuda-toolkit 安装cuda8.0#下载cuda8.0：https://developer.nvidia.com/cuda-80-ga2-download-archive #安装依赖 1sudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev #安装cuda8.0 12sudo chmod 777 cuda_8.0.61_375.26_linux.run sudo ./cuda_8.0.61_375.26_linux.run 执行后会先出现一个声明，需要阅读到100%才会开始安装，直接ctr+c跳过按照提示输入回答就行，位置全部选择默认，注：第二个选择是否安装nvidia驱动时，一定要选择否安装完依赖后，如果仍然提示 12Installing the CUDA Toolkit in /usr/local/cuda-8.0 … Missing recommended library: libXmu.so 不用管 #添加环境变量 1sudo gedit ~/.bashrc 将以下内容写入到~/.bashrc尾部： 12export PATH=/usr/local/cuda-8.0/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125; 重启后，输入nvcc --version 测试是否安装成功 （4）运行与结果1sudo apt-get install nvidia-cuda-dev nvidia-cuda-toolkit nvidia-nsight nvidia-prime #编译进入dynamicfusion-master文件夹，运行 123mkdir -p build &amp;&amp; cd buildcmake -DOpenCV_DIR=~/opencv/build -DBOOST_ROOT=~/boost_1_64_0/ -DOPENNI_INCLUDE_DIR=/usr/include/ni -DOpenCV_FOUND=TRUE ..make -j4 #运行进入dynamicfusion-master文件夹，运行 1./build/bin/dynamicfusion data/umbrella #结果DynamicFusion效果（项目视频）：视频地址：https://www.youtube.com/watch?v=i1eZekcc_lM","categories":[{"name":"深度相机","slug":"深度相机","permalink":"http://yoursite.com/categories/深度相机/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"三维重建","slug":"三维重建","permalink":"http://yoursite.com/tags/三维重建/"},{"name":"DynamicFusion","slug":"DynamicFusion","permalink":"http://yoursite.com/tags/DynamicFusion/"}]},{"title":"刷题汇总（一）leetcode 精选50题 JavaScript答案总结","slug":"13","date":"2019-03-11T12:58:24.000Z","updated":"2019-12-18T04:11:05.244Z","comments":true,"path":"2019/03/11/13/","link":"","permalink":"http://yoursite.com/2019/03/11/13/","excerpt":"题目来源 腾讯精选练习（50 题） GitHub地址：https://github.com/zj19941113/LeetCode-50-JavaScript-Answers 相关：刷题汇总（二）剑指Offer 66题 C++答案总结刷题汇总（三）leetcode 精选50题 C++答案总结刷题汇总（四）技术类编程题汇总 C++刷题汇总（五）leetcode 热题 HOT 100 C++ 答案总结刷题汇总（六）leetcode 多线程 / Shell 2两数相加-33.0%-中等","text":"题目来源 腾讯精选练习（50 题） GitHub地址：https://github.com/zj19941113/LeetCode-50-JavaScript-Answers 相关：刷题汇总（二）剑指Offer 66题 C++答案总结刷题汇总（三）leetcode 精选50题 C++答案总结刷题汇总（四）技术类编程题汇总 C++刷题汇总（五）leetcode 热题 HOT 100 C++ 答案总结刷题汇总（六）leetcode 多线程 / Shell 2两数相加-33.0%-中等 https://leetcode-cn.com/problems/add-two-numbers/ 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; var re = new ListNode(0); //0随便取，不会用到，只为了初始化 var r=re; //浅拷贝 var carry=0; while(l1!=null || l2!=null)&#123; var x = l1==null? 0:l1.val; var y = l2==null? 0:l2.val; r.next=new ListNode((carry+x+y)%10); r=r.next; if(carry+x+y&gt;9)&#123; carry=1; &#125;else&#123; carry=0; &#125; if(l1!=null)&#123; l1=l1.next; &#125; if(l2!=null)&#123; l2=l2.next; &#125; &#125; if(carry&gt;0)&#123; r.next=new ListNode(1); //最高位进1 &#125; return re.next;&#125;; 4寻找两个有序数组的中位数-33.8%-困难https://leetcode-cn.com/problems/median-of-two-sorted-arrays/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */var findMedianSortedArrays = function(a, b) &#123; // 谁小谁移，移动k次，k中间 var n = a.length; var m = b.length; var nm = n + m; var ni = 0,mi = 0,x,y; while(ni + mi &lt; nm )&#123; if(ni &lt; n )&#123; while(mi == m || a[ni] &lt;= b[mi])&#123; ni=ni+1; if(ni+mi == (nm+1)/2)&#123; //总长奇 return a[ni-1]; &#125; if(ni+mi == nm/2)&#123;//总长偶 x = a[ni-1]; break; &#125; if(ni+mi == (nm/2 + 1))&#123; y = a[ni-1]; return (x+y)/2 &#125; &#125; &#125; if(mi &lt; m)&#123; while(ni == n || b[mi] &lt;= a[ni])&#123; mi = mi + 1; if(ni+mi == (nm+1)/2)&#123; return b[mi-1]; &#125; if(ni+mi == nm/2)&#123; x = b[mi-1]; &#125; if(ni+mi == (nm/2 + 1))&#123; y = b[mi-1]; return (x+y)/2 &#125; &#125; &#125; &#125; return -1;&#125;; 5最长回文子串-24.7%-中等https://leetcode-cn.com/problems/longest-palindromic-substring/submissions/ 1234567891011121314151617181920212223242526272829/** * @param &#123;string&#125; s * @return &#123;string&#125; */var longestPalindrome = function(s) &#123; if (s==null&amp;&amp;s.length&lt;1)&#123; return \"\"; &#125; var fir = 0; var las = 0; for(var i=0;i&lt;s.length;i++)&#123; var lenl = getsub(s,i,i); var lenr = getsub(s,i,i+1); var len = Math.max(lenl,lenr); if(len&gt;las-fir)&#123; fir = i - Math.floor((len-1)/2); las = i + Math.floor(len/2); &#125; &#125; return s.slice(fir,las+1);&#125;;function getsub(s,l,r)&#123; while(l&gt;=0&amp;&amp;r&lt;=s.length-1&amp;&amp;s.charAt(l)==s.charAt(r))&#123; l--; r++; &#125; return r-l-1;&#125; 7整数反转-31.8%-简单https://leetcode-cn.com/problems/reverse-integer/ 1234567891011121314151617181920/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function(x) &#123; var result = 0; var strx; var mayAns; if(x&gt;0)&#123; strx = String(x); mayAns = Number(strx.split(\"\").reverse().join(\"\")); return mayAns&lt;=Math.pow(2,31)-1?mayAns:0; &#125; else&#123; strx = String(-x); mayAns = -Number(strx.split(\"\").reverse().join(\"\")); return mayAns&gt;=-Math.pow(2,31) ?mayAns:0; &#125; return result;&#125;; 8字符串转换整数 (atoi)-16.6%-中等https://leetcode-cn.com/problems/median-of-two-sorted-arrays 123456789101112131415161718/** * @param &#123;string&#125; str * @return &#123;number&#125; */var myAtoi = function(str) &#123; str = str.trim(); var word = str.split(\" \")[0]; if(parseInt(word))&#123; if(parseInt(word)&gt;Math.pow(2,31)-1)&#123; return Math.pow(2,31)-1; &#125;; if(parseInt(word)&lt;-Math.pow(2,31))&#123; return -Math.pow(2,31); &#125;; return parseInt(word); &#125; return 0;&#125;; 9回文数-56.0%-简单https://leetcode-cn.com/problems/palindrome-number/ 1234567891011/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */var isPalindrome = function(x) &#123; if(x &gt;= 0)&#123; var strx = String(x); return strx == strx.split(\"\").reverse().join(\"\"); &#125; return false;&#125;; 11盛最多水的容器-53.5%-中等https://leetcode-cn.com/problems/container-with-most-water/ 12345678910111213141516/** * @param &#123;number[]&#125; height * @return &#123;number&#125; */var maxArea = function(height) &#123; var maxs = 0; for (var i=0;i&lt;height.length;i++)&#123; for (var j=i+1;j&lt;height.length;j++)&#123; var tmp = Math.min(height[i],height[j])*(j-i); if(tmp&gt;maxs)&#123; maxs = tmp; &#125; &#125; &#125; return maxs;&#125;; 14最长公共前缀-32.2%-简单https://leetcode-cn.com/problems/longest-common-prefix/ 12345678910111213141516171819202122232425/** * @param &#123;string[]&#125; strs * @return &#123;string&#125; */var longestCommonPrefix = function(strs) &#123; if(strs.length == 0)&#123; return \"\"; &#125; var mini = 0; for(var i=1;i&lt;strs.length;i++)&#123; if (strs[i].length&lt;strs[mini].length)&#123; mini = i; &#125; &#125; var result = \"\"; for(let j=0;j&lt;strs[mini].length;j++)&#123; for( i=0;i&lt;strs.length;i++)&#123; if(strs[mini].slice(0,j+1) != strs[i].slice(0,j+1))&#123; return result; &#125; &#125; result = strs[mini].slice(0,j+1); &#125; return result;&#125;; 15三数之和-21.2%-中等https://leetcode-cn.com/problems/3sum 12345678910111213141516171819202122232425/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var threeSum = function(nums) &#123; nums.sort(function(a,b)&#123;return a-b&#125;); var ls = []; for (var i=0;i&lt;nums.length-2;i++) &#123; if(nums[i]==nums[i-1])&#123; //i和前面一样，跳过 continue; &#125; for (var j=i+1;j&lt;nums.length-1;j++) &#123; if(nums[j]==nums[j-1]&amp;&amp;j!=i+1)&#123; //j和前面一样，且前面不是i，跳过 continue; &#125; for (var k=j+1;k&lt;nums.length;k++) &#123; if(nums[k]+nums[j]+nums[i] == 0)&#123; ls.push([nums[i],nums[j],nums[k]]); //找到k跳出，不再往后 break; &#125; &#125; &#125; &#125; return ls;&#125;; 16最接近的三数之和-39.0%-中等https://leetcode-cn.com/problems/3sum-closest/ 1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var threeSumClosest = function(nums, target) &#123; var len = nums.length; var minl = nums[0]+nums[1]+nums[2]; for(var i=0;i&lt;len-2;i++)&#123; for(var j=i+1;j&lt;len-1;j++)&#123; for(var k=j+1;k&lt;len;k++)&#123; var tmp = nums[i]+nums[j]+nums[k]; if(Math.abs(tmp-target)&lt;Math.abs(minl-target))&#123; minl = tmp; &#125; &#125; &#125; &#125; return minl;&#125;; 20有效的括号-36.7%-简单https://leetcode-cn.com/problems/valid-parentheses/ 1234567891011121314151617181920212223/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; if(s == null||s.length &lt;1)&#123; return true; &#125; var stack = []; for(var i=0;i&lt;s.length;i++)&#123; if(s[i] == \"\")&#123; continue; &#125; if(stack.leng&lt;1)&#123; stack.push(s[i]); &#125;else if(stack[stack.length-1]==\"(\"&amp;&amp;s[i]==\")\" ||stack[stack.length-1]==\"&#123;\"&amp;&amp;s[i]==\"&#125;\" ||stack[stack.length-1]==\"[\"&amp;&amp;s[i]==\"]\")&#123; stack.pop(); &#125;else&#123; stack.push(s[i]); &#125; &#125; return stack.length&lt;1;&#125;; 21合并两个有序链表-52.9%-简单https://leetcode-cn.com/problems/merge-two-sorted-lists/ 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var mergeTwoLists = function(l1, l2) &#123; var l3 = new ListNode(0); var l4 = l3; while(l1!=null &amp;&amp; l2!=null)&#123; if(l1.val&lt;l2.val)&#123; l4.next = l1; l1 = l1.next; &#125;else&#123; l4.next = l2; l2 = l2.next; &#125; l4 = l4.next; &#125; l4.next = l1==null?l2:l1; return l3.next;&#125;; 23合并K个排序链表-43.8%-困难https://leetcode-cn.com/problems/merge-k-sorted-lists/ 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode[]&#125; lists * @return &#123;ListNode&#125; */var mergeKLists = function(lists) &#123; var rl = null; for(var i=0;i&lt;lists.length;i++)&#123; rl = mergeTwoLists(lists[i],rl); &#125; return rl;&#125;;var mergeTwoLists = function(l1, l2) &#123; var l3 = new ListNode(0); var l4 = l3; while(l1!=null &amp;&amp; l2!=null)&#123; if(l1.val&lt;l2.val)&#123; l4.next = l1; l1 = l1.next; &#125;else&#123; l4.next = l2; l2 = l2.next; &#125; l4 = l4.next; &#125; l4.next = l1==null?l2:l1; return l3.next;&#125;; 26删除排序数组中的重复项-42.9%-简单https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; for(var i=0;i&lt;nums.length;i++)&#123; var j=1; while(nums[i] == nums[i+j])&#123; ++j; &#125; if(j!=1)&#123; nums.splice(i,j-1); &#125; &#125; return nums.length;&#125;; 33搜索旋转排序数组-35.8%-中等https://leetcode-cn.com/problems/search-in-rotated-sorted-array/ 1234567891011121314151617181920212223242526272829303132/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var search = function(nums, target) &#123; return searchs(nums, 0, nums.length-1, target);&#125;;function searchs(nums,l,h,target)&#123; //搜不到返回-1，搜到了返回target if (l &gt; h)&#123; return -1; &#125; var mid = Math.floor((l + h)/2);//[0,1,2,4,5,6,7] if(nums[mid] == target)&#123; return mid; &#125; if(nums[mid] &lt; nums[h])&#123; //旋转在左 [6,7,0,1,2,4,5] if(nums[mid]&lt;target&amp;&amp;target&lt;=nums[h])&#123; return searchs(nums,mid+1,h,target);//在右，右顺序 &#125;else&#123; return searchs(nums,l,mid-1,target);//不在右 &#125; &#125;else&#123; //旋转在右 [2,4,5,6,7,0,1] if(nums[l]&lt;=target&amp;&amp;target&lt;nums[mid])&#123; return searchs(nums,l,mid-1,target);//在左，左顺序 &#125;else&#123; return searchs(nums,mid+1,h,target);//不在右 &#125; &#125;&#125; 43字符串相乘-37.9%-中等https://leetcode-cn.com/problems/multiply-strings/ 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @param &#123;string&#125; num1 * @param &#123;string&#125; num2 * @return &#123;string&#125; */var multiply = function(num1, num2) &#123; var res = \"\"; var len1 = num1.length; var len2 = num2.length; for(var i=0;i&lt;len1;i++)&#123; for(var j=0;j&lt;len2;j++)&#123; var base = Array(i+j+1).join(0);//i+j个0 eg:\"00\" //逐位相乘 var tmp = String(Number(num1[len1-1-i])*Number(num2[len2-1-j])) + base; res = addstr(res,tmp); &#125; &#125; while(res[0] == 0 &amp;&amp; res.length &gt; 1)&#123;//\"002\" -&gt; \"2\" res = res.slice(1); &#125; return res;&#125;;function addstr(s1, s2) &#123; //字符串相加 var re = \"\"; if(s1.length&gt;=s2.length)&#123; s2 = Array(s1.length-s2.length+1).join(0) + s2; &#125;else&#123; s1 = Array(s2.length-s1.length+1).join(0) + s1; &#125; var flag = 0; for(let i=0;i&lt;s1.length;i++)&#123; var t = Number(s1[s1.length - 1 - i]) + Number(s2[s1.length - 1 - i]) + flag; if(t &lt; 10)&#123; re = String(t).concat(re); flag = 0; &#125;else&#123; re = String(t-10).concat(re); flag = 1; &#125; &#125; return flag == 0? re:\"1\"+re;&#125;; 46全排列-66.7%-中等https://leetcode-cn.com/problems/permutations/ 12345678910111213141516171819202122232425/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var permute = function(nums) &#123; if(nums.length == 0)&#123; return [[]]; &#125; if(nums.length == 1)&#123; var re = []; re.push(nums); return re; &#125; var nums1 = permute(nums.slice(1)); var num0 = nums[0]; var result = []; for(var i=0;i&lt;nums1.length;i++)&#123; for(var j=0;j&lt;nums1[i].length+1;j++)&#123; var tmp = nums1[i].concat(); tmp.splice(j,0,num0); result.push(tmp); &#125; &#125; return result;&#125;; 53最大子序和-42.9%-简单https://leetcode-cn.com/problems/maximum-subarray/ 123456789101112131415161718/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxSubArray = function(nums) &#123; var sum = 0; var maxsum = nums[0]; for(var i=0;i&lt;nums.length;i++)&#123; sum +=nums[i]; if(sum &gt; maxsum)&#123; maxsum = sum; &#125; if(sum &lt; 0)&#123; sum = 0; &#125; &#125; return maxsum;&#125;; 54螺旋矩阵-34.0%-中等https://leetcode-cn.com/problems/spiral-matrix/ 12345678910111213141516171819202122232425262728293031/** * @param &#123;number[][]&#125; matrix * @return &#123;number[]&#125; */var spiralOrder = function(matrix) &#123; var arr = []; while(!(matrix.length == 0||matrix[0].length == 0))&#123; var tmp = matrix.shift(); //剪第一行 arr = arr.concat(tmp); if(matrix.length == 0||matrix[0].length == 0)&#123; //[] [[],[]] return arr; &#125; for(var i=0;i&lt;matrix.length;i++)&#123;//剪最后一列 var tmp = matrix[i].pop(); arr.push(tmp); &#125; if(matrix.length == 0||matrix[0].length == 0)&#123; return arr; &#125; var tmp = matrix.pop().reverse();//剪最后一行 arr = arr.concat(tmp); if(matrix.length == 0||matrix[0].length == 0)&#123; return arr; &#125; for(var i=0;i&lt;matrix.length;i++)&#123;//剪第一列 var tmp = matrix[matrix.length-1-i].shift(); arr.push(tmp); &#125; &#125; return arr;&#125;; 59螺旋矩阵II-71.1%-中等https://leetcode-cn.com/problems/spiral-matrix-ii/ 12345678910111213141516171819202122232425262728/** * @param &#123;number&#125; n * @return &#123;number[][]&#125; */var generateMatrix = function(n) &#123; var arr = []; for(var i = 0; i &lt; n; i++) &#123; arr.push(new Array(n).fill(0));//创建n*n零矩阵 &#125; var c = 1; var i = 0; while(c &lt;= n*n)&#123; for(var j=i;j&lt;n-i;j++)&#123;//第一行 arr[i][j] = c++; &#125; for(var j=i+1;j&lt;n-i;j++)&#123;//最后一列 arr[j][n-i-1] = c++; &#125; for(var j=i+1;j&lt;n-i;j++)&#123;//最后一行 arr[n-i-1][n-j-1] = c++; &#125; for(var j=i+1;j&lt;n-i-1;j++)&#123;//第一列 arr[n-j-1][i] = c++; &#125; i++; &#125; return arr;&#125;; 61旋转链表-37.5%-中等https://leetcode-cn.com/problems/rotate-list/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; k * @return &#123;ListNode&#125; */var rotateRight = function(head, k) &#123; if(head == null||k==0)&#123; return head; &#125; var h = head; var len = 1;//总长 while(h.next !=null )&#123; ++len; h = h.next; &#125; if(k % len == 0)&#123;//不用旋转 head本身 return head; &#125; if(k &gt; len)&#123;//需旋转 k = k % len; &#125; len = len - k; var ln = new ListNode(0);//0-&gt;1-&gt;2-&gt;3-&gt;NULL var n = ln; while(len != 0)&#123; n.next = head; n = n.next; head = head.next; --len; &#125; n.next = null; var r = head; var lr = r; while(head.next != null)&#123; lr = head; head = head.next; lr = lr.next; &#125; lr.next = ln.next return r;&#125;; 62不同路径-52.6%-中等https://leetcode-cn.com/problems/unique-paths/ 12345678910111213141516171819202122/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var uniquePaths = function(m, n) &#123; var dp = []; for(var i=0;i&lt;m;i++)&#123; //创建m*n零矩阵 dp.push(new Array(n).fill(0)); &#125; for(var i=0;i&lt;m;i++)&#123; for(var j=0;j&lt;n;j++)&#123; if(i==0||j==0)&#123; dp[i][j] = 1; &#125; else&#123; dp[i][j] = dp[i-1][j]+dp[i][j-1] &#125; &#125; &#125; return dp[m-1][n-1];&#125;; 70爬楼梯-44.5%-简单https://leetcode-cn.com/problems/climbing-stairs/ 1234567891011121314151617181920/** * @param &#123;number&#125; n * @return &#123;number&#125; */var climbStairs = function(n) &#123; if(n==1)&#123; return 1; &#125; if(n==2)&#123; return 2; &#125; var i = 1; var j = 2; for(var k=0;k&lt;n-2;k++)&#123; var tmp = i + j; i = j; j = tmp; &#125; return j;&#125;; 78子集-71.6%-中等https://leetcode-cn.com/problems/subsets/ 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var subsets = function(nums) &#123; var arr = []; arr.push([]); for(var i=0;i&lt;nums.length;i++)&#123; var tmp = []; //tmp深拷贝arr for(var k=0;k&lt;arr.length;k++)&#123; tmp[k] = arr[k].slice(0); &#125; for(var j=0;j&lt;tmp.length;j++)&#123; tmp[j].push(nums[i]); arr.push(tmp[j]); &#125; &#125; return arr;&#125;; 88合并两个有序数组-43.0%-简单https://leetcode-cn.com/problems/merge-two-sorted-lists/ 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var mergeTwoLists = function(l1, l2) &#123; var l3 = new ListNode(0); var l4 = l3; while(l1!=null &amp;&amp; l2!=null)&#123; if(l1.val&lt;l2.val)&#123; l4.next = l1; l1 = l1.next; &#125;else&#123; l4.next = l2; l2 = l2.next; &#125; l4 = l4.next; &#125; l4.next = l1==null?l2:l1; return l3.next;&#125;; 89格雷编码-62.7%-中等https://leetcode-cn.com/problems/gray-code/ 123456789101112131415161718/** * @param &#123;number&#125; n * @return &#123;number[]&#125; */// 000 001 011 010 ——// |// 100 101 111 110 &lt;——var grayCode = function(n) &#123; if(n == 0)&#123; return [0]; &#125; var tmp = grayCode(n-1).concat();//深拷贝 for(var i=0;i&lt;tmp.length;i++)&#123; tmp[i] += Math.pow(2,n-1); &#125; tmp.reverse(); return grayCode(n-1).concat(tmp);&#125;; 104二叉树的最大深度-67.4%-简单https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ 1234567891011121314151617181920/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var maxDepth = function(root) &#123; if(root == null)&#123; return 0; &#125; var l_height = maxDepth(root.left); var r_height = maxDepth(root.right); return Math.max(l_height,r_height) + 1;&#125;; 121买卖股票的最佳时机-48.5%-简单https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ 123456789101112131415/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; var maxtmp = 0; for(var i=0;i&lt;prices.length;i++)&#123; for(var j=i+1;j&lt;prices.length;j++)&#123; if(prices[j]-prices[i]&gt;maxtmp)&#123; maxtmp = prices[j]-prices[i]; &#125; &#125; &#125; return maxtmp;&#125;; 122买卖股票的最佳时机II-51.6%-简单https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/ 12345678910111213/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; var maxtmp = 0; for(var i=0;i&lt;prices.length-1;i++)&#123; if (prices[i]&lt;prices[i+1])&#123; maxtmp += prices[i+1]-prices[i]; &#125; &#125; return maxtmp;&#125;; 124二叉树中的最大路径和-33.8%-困难https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/ 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var maxPathSum = function(root) &#123; var len = -Number.MAX_VALUE; submax(root); function submax(t)&#123; if(t == null)&#123; return 0; &#125; var l = Math.max(submax(t.left),0); var r = Math.max(submax(t.right),0); if(t.val + l + r &gt; len)&#123; len = t.val + l + r; &#125; return Math.max(l,r) + t.val; &#125; return len;&#125;; 136只出现一次的数字-59.1%-简单https://leetcode-cn.com/problems/single-number/ 1234567891011121314/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; // 交换律：a ^ b ^ c &lt;=&gt; a ^ c ^ b,俩两相同的移到一起 // 相同的数异或为0: n ^ n =&gt; 0,只剩下单个的了 // 任何数于0异或为任何数 0 ^ n =&gt; n var s = 0; for(var i=0;i&lt;nums.length;i++)&#123; s = s^nums[i]; &#125; return s;&#125;; 141环形链表-35.5%-简单https://leetcode-cn.com/problems/linked-list-cycle 1234567891011121314151617181920212223/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */ /** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; var slow = head, fast = head; while(fast &amp;&amp; fast.next)&#123; slow = slow.next; fast = fast.next.next; if(slow == fast)&#123; return true; &#125; &#125; return false;&#125;; 142环形链表II-34.8%-中等https://leetcode-cn.com/problems/linked-list-cycle-ii/ 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var detectCycle = function(head) &#123; var slow = head,fast = head; var isloop = false; while(fast &amp;&amp; fast.next)&#123; slow = slow.next; fast = fast.next.next; if(slow == fast)&#123;//相遇 isloop = true; break; &#125; &#125; if(isloop)&#123; var l = head; while(l != slow)&#123; l = l.next; slow = slow.next; &#125; return slow; &#125; return null;&#125;; 146LRU缓存机制-39.0%-困难https://leetcode-cn.com/problems/lru-cache/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @param &#123;number&#125; capacity *//**1.新加入的数据 ————&gt; ___ 头 &lt;————— ___ | ___ |2.被访问的数据 ___ ————— ___ ___ &lt;———— ___ 尾3.淘汰的数据*/var LRUCache = function(capacity) &#123; this.size = capacity; this.map = &#123;&#125;; this.list = []; &#125;;/** * @param &#123;number&#125; key * @return &#123;number&#125; */LRUCache.prototype.get = function(key) &#123; if(this.map[key] != null)&#123; this.list.splice(this.list.indexOf(key),1);//更新list this.list.unshift(key); return this.map[key]; &#125; return -1;&#125;;/** * @param &#123;number&#125; key * @param &#123;number&#125; value * @return &#123;void&#125; */LRUCache.prototype.put = function(key, value) &#123; var tmp = this.list.indexOf(key); if(tmp != -1)&#123; //key已存在，更新list this.list.splice(tmp,1); &#125; else&#123; //key不存在 if(this.list.length == this.size)&#123; //栈满 var d = this.list.pop(); this.map[d] = null; &#125; &#125; this.list.unshift(key); this.map[key] = value;&#125;;/** * Your LRUCache object will be instantiated and called as such: * var obj = Object.create(LRUCache).createNew(capacity) * var param_1 = obj.get(key) * obj.put(key,value) */ 148排序链表-58.6%-中等https://leetcode-cn.com/problems/sort-list/ 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var sortList = function(head) &#123; if (!head || !head.next)&#123; return head; &#125; var slow = head,bk = head,fast = head; while(fast &amp;&amp; fast.next )&#123; bk = slow; slow = slow.next; fast = fast.next.next; &#125; bk.next = null; var l1 = sortList(head);//中分，归并 var l2 = sortList(slow); return merge(l1,l2);&#125;;function merge(l1,l2)&#123;//合并有序链表 var l = new ListNode(0); var rl = l; while(l1 &amp;&amp; l2)&#123; if(l1.val &lt; l2.val)&#123; rl.next = l1; l1 = l1.next; &#125;else&#123; rl.next = l2; l2 = l2.next; &#125; rl = rl.next; &#125; rl.next = l1==null?l2:l1; return l.next;&#125; 155最小栈-47.7%-简单https://leetcode-cn.com/problems/min-stack/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * initialize your data structure here. */var MinStack = function() &#123; this.arr = [];&#125;;/** * @param &#123;number&#125; x * @return &#123;void&#125; */MinStack.prototype.push = function(x) &#123; this.arr.push(x);&#125;;/** * @return &#123;void&#125; */MinStack.prototype.pop = function() &#123; this.arr.pop();&#125;;/** * @return &#123;number&#125; */MinStack.prototype.top = function() &#123; return this.arr[this.arr.length-1];&#125;;/** * @return &#123;number&#125; */MinStack.prototype.getMin = function() &#123; return Math.min.apply( &#123;&#125;, this.arr );&#125;;/** * Your MinStack object will be instantiated and called as such: * var obj = Object.create(MinStack).createNew() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */ 160相交链表-37.2%-简单https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; headA * @param &#123;ListNode&#125; headB * @return &#123;ListNode&#125; */var getIntersectionNode = function(headA, headB) &#123; if(headA == null || headB == null)&#123; return null; &#125; var pA = headA; var pB = headB; while(pA != pB) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA;&#125;; 169求众数-58.0%-简单https://leetcode-cn.com/problems/majority-element/ 12345678/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var majorityElement = function(nums) &#123; nums.sort(); return nums[Math.floor(nums.length/2)];&#125;; 206反转链表-58.6%-简单https://leetcode-cn.com/problems/reverse-linked-list/ 12345678910111213141516171819202122/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123; var l = null; while(head != null)&#123; var newl = new ListNode(head.val); var tmp = l; l = newl; l.next = tmp; head = head.next; &#125; return l; &#125;; 215数组中的第K个最大元素-56.6%-中等https://leetcode-cn.com/problems/kth-largest-element-in-an-array/ 123456789101112131415161718192021222324252627282930313233343536373839/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var findKthLargest = function(nums, k) &#123; return fastkmax(nums,0,nums.length-1,k);&#125;;function fastkmax(n,l,r,k)&#123; var mid = partiton(n,l,r);//排序 左边都是比mid小的，右边都是比mid大的 var rk = r - mid + 1; if(rk == k)&#123; return n[mid]; &#125; if(rk &gt; k)&#123; return fastkmax(n,mid + 1,r,k); &#125; return fastkmax(n,l,mid - 1,k -rk );&#125;function partiton(n,l,r)&#123;//一次快排 var base = n[l]; var i = l,j = r,tmp; while(i &lt; j)&#123; while(n[j] &gt;= base &amp;&amp; i &lt; j)&#123; j--; &#125; while(n[i] &lt;= base &amp;&amp; i &lt; j)&#123; i++; &#125; tmp = n[i]; n[i] = n[j]; n[j] = tmp; &#125; n[l] = n[i]; n[i] = base; return i; &#125; 217存在重复元素-47.0%-简单https://leetcode-cn.com/problems/contains-duplicate/ 12345678910111213/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var containsDuplicate = function(nums) &#123; nums.sort(); for(var i=0;i&lt;nums.length-1;i++)&#123; if(nums[i]==nums[i+1])&#123; return true; &#125; &#125; return false;&#125;; 230二叉搜索树中第K小的元素-62.0%-中等https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/ 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; k * @return &#123;number&#125; */var kthSmallest = function(root, k) &#123; var list = []; order(root,list); return list[k-1];&#125;;function order(root,list)&#123;//中序遍历 if(!root)&#123; return; &#125; order(root.left,list); list.push(root.val); order(root.right,list);&#125; 231 2的幂-44.3%-简单https://leetcode-cn.com/problems/power-of-two/ 12345678910111213/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isPowerOfTwo = function(n) &#123; if(n == 0)&#123; return false; &#125; if(n == 1)&#123; return true; &#125; return n%2==0?isPowerOfTwo(n/2):false;&#125;; 235二叉搜索树的最近公共祖先-56.9%-简单https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;TreeNode&#125; */var lowestCommonAncestor = function(root, p, q) &#123; // 二叉搜索树(二叉排序树):若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值; var res = null; lca(root, p , q); function lca(root, p, q)&#123; if((root.val - p.val)*(root.val - q.val) &lt;= 0)&#123; //root为p、q根节点 res = root; &#125;else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123; //都在右子树 lca(root.right, p , q); &#125;else&#123; lca(root.left, p , q); &#125; &#125; return res;&#125;; 236二叉树的最近公共祖先-50.4%-中等https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/ 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;TreeNode&#125; */var lowestCommonAncestor = function(root, p, q) &#123; if(!root)&#123; return null; &#125; if(root == p || root == q)&#123; return root; &#125; var l = lowestCommonAncestor(root.left,p,q)//左支存在一个的位置 var r = lowestCommonAncestor(root.right,p,q) if(l &amp;&amp; r)&#123;//左支有一个，右支有一个 return root; &#125; if(l)&#123;//右没有，都在左，先找到的即为根节点 return l; &#125; if(r)&#123; return r; &#125; return null;&#125;; 237删除链表中的节点-69.4%-简单https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 123456789101112131415/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; node * @return &#123;void&#125; Do not return anything, modify node in-place instead. */var deleteNode = function(node) &#123; node.val = node.next.val; node.next = node.next.next;&#125;; 238除自身以外数组的乘积-58.8%-中等https://leetcode-cn.com/problems/product-of-array-except-self/ 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var productExceptSelf = function(nums) &#123; var arr = []; var l = 1, r = 1; for(var i=0;i&lt;nums.length;i++)&#123;//arr[i] i左边数乘积 arr[i] = l; l *= nums[i]; &#125; for(var j=nums.length-1;j&gt;=0;j--)&#123; arr[j] *= r; r *= nums[j]; &#125; return arr;&#125;; 292Nim游戏-66.4%-简单https://leetcode-cn.com/problems/nim-game/ 1234567/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var canWinNim = function(n) &#123; return n%4 == 0?false:true;&#125;; 344反转字符串-65.1%-简单https://leetcode-cn.com/problems/reverse-string/ 12345678910/** * @param &#123;character[]&#125; s * @return &#123;void&#125; Do not return anything, modify s in-place instead. */var reverseString = function(s) &#123; for(var i=1;i&lt;s.length;i++)&#123; var tmp = s.splice(i,1)[0]; s.unshift(tmp); &#125;&#125;; 557反转字符串中的单词III-63.5%-简单https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/ 1234567891011/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseWords = function(s) &#123; var arr = s.split(\" \"); for(var i=0;i&lt;arr.length;i++)&#123; arr[i] = arr[i].split(\"\").reverse().join(\"\"); &#125; return arr.join(\" \");&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"CodeCode","slug":"CodeCode","permalink":"http://yoursite.com/categories/CodeCode/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"setTimeout、Promise、Async/Await 异步机制 事件循环","slug":"12","date":"2019-02-22T12:48:32.000Z","updated":"2019-12-18T04:09:25.822Z","comments":true,"path":"2019/02/22/12/","link":"","permalink":"http://yoursite.com/2019/02/22/12/","excerpt":"javascript是一门单线程语言 将任务分为两类： 同步任务 异步任务 打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。","text":"javascript是一门单线程语言 将任务分为两类： 同步任务 异步任务 打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。 同步的进入主线程，异步的进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的Event Loop(事件循环)。js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 举些例子： 1、setTimeout12345console.log('script start') //1. 打印 script startsetTimeout(function()&#123; console.log('settimeout') // 3. 打印 settimeout&#125;) console.log('script end') //2. 打印 script start 输出顺序：script start-&gt;script end-&gt;settimeout 2、PromisePromise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。 123456789console.log('script start') //1. 打印 script startlet promise1 = new Promise(function (resolve) &#123; console.log('promise1') //2. 打印 promise1 resolve() console.log('promise1 end') //3. 打印 promise1 end&#125;).then(function () &#123; console.log('promise2') //5. 打印 promise2&#125;)console.log('script end') //4. 打印 script end // 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout 3、async await1234567891011async function async1()&#123; console.log('async1 start'); //2. 打印 async1 start await async2(); console.log('async1 end') //5. 打印 async1 end&#125;async function async2()&#123; console.log('async2') //3. 打印 async2&#125;console.log('script start'); //1. 打印 script startasync1();console.log('script end') //4. 打印 script end // 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end 同时有setTimeout、Promise、Async/Await ，执行顺序又是什么？引入 macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。 123456789setTimeout(function() &#123; console.log('setTimeout'); //4. 打印 setTimeout&#125;)new Promise(function(resolve) &#123; console.log('promise'); //1. 打印 promise&#125;).then(function() &#123; console.log('then'); //3. 打印 then&#125;)console.log('console'); //2. 打印 console // 输出顺序：promise-&gt;console-&gt;then-&gt;setTimeout 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 整体代码script作为第一个宏任务执行结束，发现了then在微任务Event Queue里面，执行。 第一轮事件循环结束了，从宏任务Event Queue开始第二轮循环。发现了宏任务EventQueue中setTimeout对应的回调函数，立即执行。 结束。 再来分析两个案例： 123456789101112131415161718192021222324252627282930313233343536373839console.log('1'); //1. 打印 1 setTimeout(function() &#123; console.log('2'); //5. 打印 2 process.nextTick(function() &#123; console.log('3'); //7. 打印 3 &#125;) new Promise(function(resolve) &#123; console.log('4'); //6. 打印 4 resolve(); &#125;).then(function() &#123; console.log('5') //8. 打印 5 &#125;)&#125;)process.nextTick(function() &#123; console.log('6'); //3. 打印 6&#125;)new Promise(function(resolve) &#123; console.log('7'); //2. 打印 7 resolve();&#125;).then(function() &#123; console.log('8') //4. 打印 8&#125;) setTimeout(function() &#123; console.log('9'); //9. 打印 9 process.nextTick(function() &#123; console.log('10'); //11. 打印 10 &#125;) new Promise(function(resolve) &#123; console.log('11'); //10. 打印 11 resolve(); &#125;).then(function() &#123; console.log('12') //12. 打印 12 &#125;)&#125;) // 输出顺序：1，7，6，8，2，4，3，5，9，11，10，12 123456789101112131415161718192021async function async1() &#123; console.log('async1 start') //2. 打印 async1 start await async2() console.log('async1 end') //7. 打印 async1 end&#125;async function async2() &#123; console.log('async2') //3. 打印 async2&#125;console.log('script start') //1. 打印 script startsetTimeout(function () &#123; console.log('settimeout') //8. 打印 settimeout&#125;)async1()new Promise(function (resolve) &#123; console.log('promise1') //4. 打印 promise1 resolve()&#125;).then(function () &#123; console.log('promise2') //6. 打印 promise2&#125;)console.log('script end') //5. 打印 script end // 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;promise1-&gt;script end-&gt;promise2-&gt;async1 end-&gt;settimeout","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Three.js+tween.js 基础(一)","slug":"20","date":"2019-01-26T03:08:36.000Z","updated":"2019-12-18T04:16:36.189Z","comments":true,"path":"2019/01/26/20/","link":"","permalink":"http://yoursite.com/2019/01/26/20/","excerpt":"Three.js简介Three.js是众多WebGL三维引擎框架其中之一，源自github的一个开源项目,项目地址：https://github.com/mrdoob/three.js 。可以利用three.js进行网页上的三维场景（机械、建筑、游戏等）创建，能写出在浏览器上流畅运行的3D程序。如果没有前端基础，最好预先学习一点HTML/JavaScript方面的知识。","text":"Three.js简介Three.js是众多WebGL三维引擎框架其中之一，源自github的一个开源项目,项目地址：https://github.com/mrdoob/three.js 。可以利用three.js进行网页上的三维场景（机械、建筑、游戏等）创建，能写出在浏览器上流畅运行的3D程序。如果没有前端基础，最好预先学习一点HTML/JavaScript方面的知识。 官方文档：https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene 一、基本概念篇：第一个three.js三维场景在Three.js中，要渲染物体到网页中，需要3个基本对象： 场景（scene） 相机（camera） 渲染器（renderer） 场景对应于整个布景空间，相机是拍摄镜头，渲染器用来把拍摄好的场景转换成胶卷。 123456var scene = new THREE.Scene();var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );var renderer = new THREE.WebGLRenderer();renderer.setSize( window.innerWidth, window.innerHeight );document.body.appendChild( renderer.domElement ); 1、场景（scene）1var scene = new THREE.Scene(); 场景对应于整个布景空间，在Threejs中场景就只有一种，用THREE.Scene来表示。 2、相机（camera）在Threejs中最常用的相机有两种 正投影相机THREE.OrthographicCamera 透视投影相机THREE.PerspectiveCamera (1) 正投影相机THREE.OrthographicCamera 12var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );scene.add( camera ); 函数构造：OrthographicCamera( left : Number, right : Number, top : Number, bottom : Number, near : Number, far : Number )参考：https://threejs.org/docs/index.html#api/zh/cameras/OrthographicCamera 正交投影相机示意图如下：(2) 透视投影相机THREE.PerspectiveCamera 12var camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );scene.add( camera ); 函数构造：PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )参考：https://threejs.org/docs/index.html#api/zh/cameras/PerspectiveCamera 透视投影相机示意图如下： 3、 渲染器（renderer）123var renderer = new THREE.WebGLRenderer();renderer.setSize( window.innerWidth, window.innerHeight );document.body.appendChild( renderer.domElement ); 除了创建renderer实例，还需要设置渲染空间的尺寸，一般使用目标屏幕的宽高（window.innerWidth和window.innerHeight），也可以给定一个尺寸。渲染器renderer的domElement元素，表示渲染器中的画布，所有的渲染都是画在domElement上的，所以这里的appendChild表示将这个domElement挂接在body下面，这样渲染的结果就能够在页面中显示了。 4、 添加对象现在的场景中是空的，我们向场景中加入最简单的立方体。 123456var geometry = new THREE.BoxGeometry( 1, 1, 1 ); var material= new THREE.MeshBasicMaterial( &#123; color: 0x4ca7c1 &#125; ); var cube = new THREE.Mesh( geometry, material ); scene.add( cube );camera.position.z = 5; 创建几何体，创建材质，利用几何体和材质创建对象，将对象加入场景scene中。默认情况下，当我们调用scene.add()的时候，物体将会被添加到坐标为(0,0,0)的位置。但这可能会使得摄像机的位置和立方体相互重叠（摄像机位于立方体中）。为了防止这种情况的发生，需要将摄像机稍微向外移动一些。 5、 渲染场景12345function animate() &#123; requestAnimationFrame( animate ); renderer.render( scene, camera );&#125;animate(); 在这里我们创建了一个循环——这使得渲染器能够在每次屏幕刷新时对场景进行绘制（在大多数屏幕上，刷新率一般是60次/秒）。requestAnimationFrame函数就是让浏览器去执行一次参数中的函数，这样通过上面render中调用requestAnimationFrame()函数，requestAnimationFrame()函数又让rander()再执行一次，就形成了我们通常所说的游戏循环了。 6、使立方体动起来在animate()函数中添加 12cube.rotation.x += 0.01;cube.rotation.y += 0.01; 这一段代码将在每一帧时被渲染时调用（正常情况下是60次/秒），这就让立方体有了一个看起来很不错的旋转动画。除了改变立方体的旋转角度、位置，也可以通过改变相机位置角度达到同样动起来的效果。 完整代码（附详细备注）123456789101112131415161718192021222324252627282930313233343536373839404142&lt;html&gt; &lt;head&gt; &lt;title&gt;My first three.js app&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; &#125; canvas &#123; width: 100%; height: 100% &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"build/three.js\"&gt;&lt;/script&gt; &lt;script&gt; // 场景（scene） var scene = new THREE.Scene(); // 相机（camera） var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 ); // 渲染器（renderer） var renderer = new THREE.WebGLRenderer(); // 创建renderer实例 renderer.setSize( window.innerWidth, window.innerHeight ); // 设置渲染空间的尺寸 document.body.appendChild( renderer.domElement ); // 渲染出的画布加入页面 // 添加对象 var geometry = new THREE.BoxGeometry( 1, 1, 1 ); // 创建几何体 var material = new THREE.MeshBasicMaterial( &#123; color: 0x4ca7c1 &#125; ); //创建材质 var cube = new THREE.Mesh( geometry, material ); // 用几何体和材质创建对象 scene.add( cube ); // 对象加入场景scene中 camera.position.z = 5; // 渲染场景 var animate = function () &#123; requestAnimationFrame( animate ); cube.rotation.x += 0.01; cube.rotation.y += 0.01; renderer.render( scene, camera ); &#125;; animate(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在浏览器中的效果： 二、实际应用篇：跳一跳（You_Jump_I_Jump）有了基本概念后，我们来一步步实现跳一跳的代码复原，GitHub地址：https://github.com/zj19941113/You_Jump_I_Jump最终效果图： 1、创建场景与第一个盒子（1）基本元素场景：设置背景颜色 12scene = new THREE.Scene();scene.background = new THREE.Color( 0x8797a4 ); 渲染器：渲染空间尺寸设置为屏幕的宽高 123renderer = new THREE.WebGLRenderer(&#123; antialias: true &#125; );renderer.setSize( window.innerWidth, window.innerHeight );document.body.appendChild( renderer.domElement ); 相机：选择正交投影相机，设置相机位置与朝向 123camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -1000, 2000 );camera.position.set( 200 , 180 , 200 );camera.lookAt(new THREE.Vector3(0,0,0)); 光源：添加平行光与环境光，平行光让几何体更层次分明，环境光提升整体亮度 123456light = new THREE.AmbientLight( 0xFFFFFF,0.4 );scene.add( light );light2 = new THREE.DirectionalLight(0xFFFFFF,1);light2.position.set(3,4,2);scene.add(light2); 环境光 函数构造：AmbientLight( color : Integer, intensity : Float )color - (参数可选）颜色的rgb数值。缺省值为 0xffffff(白色)。intensity - (参数可选)光照的强度。缺省值为 1。参考：https://threejs.org/docs/index.html#api/zh/lights/AmbientLight 平行光 函数构造：DirectionalLight( color : Integer, intensity : Float )参考：https://threejs.org/docs/index.html#api/zh/lights/DirectionalLight （2）创建地面与盒子12ground = creatGround(0,0,0x8797a4)cube01 = creatcube01(0,0); 函数 creatGround（），创建5000*5000大小，颜色为#8797a4的地面 123456789 function creatGround(x,z,color)&#123; var geometry = new THREE.PlaneGeometry( 5000, 5000, 1, 1 ); var material = new THREE.MeshLambertMaterial(&#123; color:color&#125;); mesh = new THREE.Mesh( geometry,material ); mesh.rotation.x = -Math.PI / 2; mesh.position.set(x,-0.01,z); scene.add(mesh); return mesh;&#125; 函数 creatcube01（），创建一个其中一面有纹理的盒子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function creatcube01(x,z) &#123; // 绘制纹理 var canvas = document.createElement('canvas'); canvas.width=100; canvas.height=50; var ctx = canvas.getContext('2d'); ctx.rect(0,0,100,50); ctx.fillStyle=\"#e86014\"; ctx.fill(); ctx.beginPath(); ctx.arc(40,25,18,0,2*Math.PI); ctx.fillStyle=\"#ffffff\"; ctx.fill(); ctx.beginPath(); ctx.arc(45,20,6,0,2*Math.PI); ctx.fillStyle=\"#e86014\"; ctx.fill(); ctx.beginPath(); ctx.arc(65,10,6,0,2*Math.PI); ctx.fillStyle=\"#ffffff\"; ctx.fill(); var texture = new THREE.Texture(canvas); group = canvasOneFace(x,z,texture,0xe86014); return group;&#125;// 创建一个纯色盒子，将纹理贴在平面上覆盖在盒子一面function canvasOneFace(x,z,texture,color) &#123; // 创建纯色盒子，高50，长宽100 var geometry = new THREE.CubeGeometry( 100, 50, 100); var material = new THREE.MeshLambertMaterial( &#123; color:color&#125; ); mesh = new THREE.Mesh( geometry,material); mesh.position.set(x,25,z); // 默认中心在(0,0,0)向上抬25，使盒子在地面上 // 创建100*50的平面，和盒子侧面一样大，材料使用刚绘制的画布作纹理，而不是颜色 var geometry = new THREE.PlaneGeometry( 100,50 ); var material = new THREE.MeshLambertMaterial(&#123;map:texture&#125;); texture.needsUpdate = true; mesh1 = new THREE.Mesh( geometry,material); // 使平面和盒子侧面基本重合，差了0.01的距离，纹理能遮盖住盒子本身颜色 mesh1.rotation.y = Math.PI / 2; mesh1.position.set(x+50.01,25,z); // 创建阴影 Shadow = makeShadow(); Shadow.position.set( x-30 , 0 , z+8 ); // 组合起来方便使用 group = new THREE.Object3D(); group.add(mesh,mesh1,Shadow); scene.add(group); return group;&#125;// 创建阴影function makeShadow(x,z)&#123; // 创建平面，贴上图片作为纹理 vargeometry = new THREE.PlaneGeometry( 116, 160, 1, 1 ); // 加载图片作为纹理 var texture = new THREE.TextureLoader().load( \"source/shadow.png\" ); var material = new THREE.MeshBasicMaterial(&#123;map:texture&#125;); material.transparent = true; // 材质透明 meshShadow = new THREE.Mesh( geometry,material); // 调整阴影位置 meshShadow.rotation.x = -Math.PI / 2; meshShadow.rotation.z = Math.PI / 2 ; meshShadow.position.set( x-30 , 0 , z+6 ); return meshShadow;&#125; 效果： 因为之后要创建各种盒子，所以这里用了函数，方便之后调用。用画布绘制右侧面的纹理，创建橙色的纯色盒子，将纹理贴在平面上覆盖在盒子侧面，最后再创建阴影，同样是创建平面贴上阴影图片作为纹理。 画布作为纹理： 12345678910var canvas = document.createElement('canvas');canvas.width=100;canvas.height=50;var ctx = canvas.getContext('2d');// 画布的绘制// ……// 画布的绘制var texture = new THREE.Texture(canvas);var material = new THREE.MeshLambertMaterial(&#123;map:texture&#125;);texture.needsUpdate = true; png图片作为纹理： 123 var texture = new THREE.TextureLoader().load( \"source/shadow.png\" ); var material = new THREE.MeshBasicMaterial(&#123;map:texture&#125;);material.transparent = true; // 材质透明 注：尽量重用geometry，material，使性能优化。 （3）窗口自适应1window.addEventListener( 'resize', onWindowResize, false ); 当窗口大小改变时，触发函数 onWindowResize()，实时改变相机参数。 123456789101112function onWindowResize() &#123; width = document.body.clientWidth; height = document.body.clientHeight; camera.left = width / - 2; camera.right = width / 2; camera.top = height / 2; camera.bottom = height / -2; // 更新相机投影矩阵，在相机任何参数被改变以后必须被调用 camera.updateProjectionMatrix(); renderer.setSize( width,height );&#125; 效果：完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"build/three.js\"&gt;&lt;/script&gt;&lt;script&gt; var camera, scene, renderer; init(); animate(); function init() &#123; scene = new THREE.Scene(); scene.background = new THREE.Color( 0x8797a4 ); renderer = new THREE.WebGLRenderer(&#123; antialias: true &#125; ); renderer.setSize( window.innerWidth, window.innerHeight ); document.body.appendChild( renderer.domElement ); camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -1000, 2000 ); camera.position.set( 200 , 180 , 200 ); camera.lookAt(new THREE.Vector3(0,0,0)); light = new THREE.AmbientLight( 0xFFFFFF,0.4 ); scene.add( light ); light2 = new THREE.DirectionalLight(0xFFFFFF,1); light2.position.set(3,4,2); scene.add(light2); ground = creatGround(0,0,0x8797a4) cube01 = creatcube01(0,0); window.addEventListener( 'resize', onWindowResize, false ); &#125; function creatGround(x,z,color)&#123; var geometry = new THREE.PlaneGeometry( 5000, 5000, 1, 1 ); var material = new THREE.MeshLambertMaterial(&#123; color:color&#125;); mesh = new THREE.Mesh( geometry,material ); mesh.rotation.x = -Math.PI / 2; mesh.position.set(x,-0.01,z); scene.add(mesh); return mesh; &#125; function creatcube01(x,z) &#123; // 绘制纹理 var canvas = document.createElement('canvas'); canvas.width=100; canvas.height=50; var ctx = canvas.getContext('2d'); ctx.rect(0,0,100,50); ctx.fillStyle=\"#e86014\"; ctx.fill(); ctx.beginPath(); ctx.arc(40,25,18,0,2*Math.PI); ctx.fillStyle=\"#ffffff\"; ctx.fill(); ctx.beginPath(); ctx.arc(45,20,6,0,2*Math.PI); ctx.fillStyle=\"#e86014\"; ctx.fill(); ctx.beginPath(); ctx.arc(65,10,6,0,2*Math.PI); ctx.fillStyle=\"#ffffff\"; ctx.fill(); var texture = new THREE.Texture(canvas); group = canvasOneFace(x,z,texture,0xe86014); return group; &#125; // 创建一个纯色盒子，将纹理贴在平面上覆盖在盒子一面 function canvasOneFace(x,z,texture,color) &#123; // 创建纯色盒子，高50，长宽100 var geometry = new THREE.CubeGeometry( 100, 50, 100); var material = new THREE.MeshLambertMaterial( &#123; color:color&#125; ); mesh = new THREE.Mesh( geometry,material); mesh.position.set(x,25,z); // 默认中心在(0,0,0)向上抬25，使盒子在地面上 // 创建100*50的平面，和盒子侧面一样大，材料使用刚绘制的画布作纹理，而不是颜色 var geometry = new THREE.PlaneGeometry( 100,50 ); var material = new THREE.MeshLambertMaterial(&#123;map:texture&#125;); texture.needsUpdate = true; mesh1 = new THREE.Mesh( geometry,material); // 使平面和盒子侧面基本重合，差了0.01的距离，纹理能遮盖住盒子本身颜色 mesh1.rotation.y = Math.PI / 2; mesh1.position.set(x+50.01,25,z); // 创建阴影 Shadow = makeShadow(); Shadow.position.set( x-30 , 0 , z+8 ); // 组合起来方便使用 group = new THREE.Object3D(); group.add(mesh,mesh1,Shadow); scene.add(group); return group; &#125; // 创建阴影 function makeShadow(x,z)&#123; // 创建平面，贴上图片作为纹理 var geometry = new THREE.PlaneGeometry( 116, 160, 1, 1 ); // 加载图片作为纹理 var texture = new THREE.TextureLoader().load( \"source/shadow.png\" ); var material = new THREE.MeshBasicMaterial(&#123;map:texture&#125;); material.transparent = true; // 材质透明 meshShadow = new THREE.Mesh( geometry,material); // 调整阴影位置 meshShadow.rotation.x = -Math.PI / 2; meshShadow.rotation.z = Math.PI / 2 ; meshShadow.position.set( x-30 , 0 , z+6 ); return meshShadow; &#125; function onWindowResize() &#123; width = document.body.clientWidth; height = document.body.clientHeight; camera.left = width / - 2; camera.right = width / 2; camera.top = height / 2; camera.bottom = height / -2; // 更新相机投影矩阵，在相机任何参数被改变以后必须被调用 camera.updateProjectionMatrix(); renderer.setSize( width,height ); &#125; function animate() &#123; requestAnimationFrame( animate ); renderer.render( scene, camera ); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、更多盒子的生成所有盒子的生成函数，见 https://github.com/zj19941113/You_Jump_I_Jump/blob/master/zjFirstStep.htmlboxs大合照： 3、性能与调试创建stats对象进行性能监控帧数：图形处理器每秒钟能够刷新几次，通常用fps（Frames Per Second）来表示。帧数越高，画面的感觉就会越好。所以大多数游戏都会有超过30的FPS。我们设置性能监视器来监视FPS。（1）引入Stats.js文件，官方文档：https://github.com/mrdoob/stats.js 1&lt;script src=\"js/Stats.js\"&gt;&lt;/script&gt; （2）将stats对象加入到html网页中 1var stats; 12345stats = new Stats();stats.domElement.style.position = 'absolute';stats.domElement.style.right = '8px';stats.domElement.style.top = '8px';document.body.appendChild( stats.domElement ); （3）在 animate() 中调用stats.update()统计时间和帧数 12345function animate() &#123; requestAnimationFrame( animate ); stats.update(); // 调用stats.update()统计时间和帧数 renderer.render( scene, camera );&#125; 其中FPS表示：上一秒的帧数，这个值越大越好，一般都为60左右。点击后变成另一个视图。MS表示渲染一帧需要的毫秒数，这个数字是越小越好，再次点击又可以回到FPS视图中。效果： OrbitControls控制器辅助调试（1）引入controls/OrbitControls.js文件，官方文档：https://github.com/mrdoob/three.js/blob/017f2a9eb17820772359b1e1dbca2b626c9f32b1/examples/jsm/controls/OrbitControls.js 1&lt;script src=\"js/controls/OrbitControls.js\"&gt;&lt;/script&gt; （2）controls控制器设置 1var controls; 1234567controls = new THREE.OrbitControls( camera, renderer.domElement );controls.enableDamping = true; controls.dampingFactor = 0.25;controls.screenSpacePanning = false;controls.minDistance = 100;controls.maxDistance = 500;controls.maxPolarAngle = Math.PI / 2; （3）在 animate() 中调用controls.update() 123456function animate() &#123; requestAnimationFrame( animate ); stats.update(); // 调用stats.update()统计时间和帧数 controls.update(); // 调用controls.update() renderer.render( scene, camera );&#125; OrbitControls控制器的作用是，鼠标左键进行视角的旋转，右键控制平移，滚轮控制缩放。效果：完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"build/three.js\"&gt;&lt;/script&gt;&lt;script src=\"js/Stats.js\"&gt;&lt;/script&gt;&lt;script src=\"js/controls/OrbitControls.js\"&gt;&lt;/script&gt;&lt;script&gt; var camera, scene, renderer; var stats, controls; init(); animate(); function init() &#123; scene = new THREE.Scene(); scene.background = new THREE.Color( 0x8797a4 ); renderer = new THREE.WebGLRenderer(&#123; antialias: true &#125; ); renderer.setSize( window.innerWidth, window.innerHeight ); document.body.appendChild( renderer.domElement ); stats = new Stats(); stats.domElement.style.position = 'absolute'; stats.domElement.style.right = '8px'; stats.domElement.style.top = '8px'; document.body.appendChild( stats.domElement ); camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -1000, 2000 ); camera.position.set( 200 , 180 , 200 ); camera.lookAt(new THREE.Vector3(0,0,0)); controls = new THREE.OrbitControls( camera, renderer.domElement ); controls.enableDamping = true; controls.dampingFactor = 0.25; controls.screenSpacePanning = false; controls.minDistance = 100; controls.maxDistance = 500; controls.maxPolarAngle = Math.PI / 2; light = new THREE.AmbientLight( 0xFFFFFF,0.4 ); scene.add( light ); light2 = new THREE.DirectionalLight(0xFFFFFF,1); light2.position.set(3,4,2); scene.add(light2); ground = creatGround(0,0,0x8797a4) cube01 = creatcube01(0,0); window.addEventListener( 'resize', onWindowResize, false ); &#125; function creatGround(x,z,color)&#123; // 地面创建函数 // …… // 地面创建函数 &#125; function creatcube01(x,z) &#123; // 盒子创建函数 // …… // 盒子创建函数 &#125; function onWindowResize() &#123; // 窗口自适应函数 // …… // 窗口自适应函数 &#125; function animate() &#123; requestAnimationFrame( animate ); stats.update(); controls.update(); renderer.render( scene, camera ); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 有效利用Controls和Helper能使视图展示更加出色，从而方便代码的编写。这里有官方提供的一些实例（包括模型加载、控制器、动画等相关内容）：https://github.com/mrdoob/three.js/tree/017f2a9eb17820772359b1e1dbca2b626c9f32b1/examples 下一篇：Three.js+tween.js 基础(二) 将介绍tween.js 相关知识，完成player的跳动动画，盒子的随机生成，分数统计等功能。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"THREE","slug":"THREE","permalink":"http://yoursite.com/categories/THREE/"}],"tags":[{"name":"Three.js","slug":"Three-js","permalink":"http://yoursite.com/tags/Three-js/"},{"name":"Tween.js","slug":"Tween-js","permalink":"http://yoursite.com/tags/Tween-js/"}]},{"title":"利用浏览器本地存储localStorage进行换肤，改变页面字体颜色样式","slug":"11","date":"2019-01-24T04:21:02.000Z","updated":"2019-12-18T04:06:14.029Z","comments":true,"path":"2019/01/24/11/","link":"","permalink":"http://yoursite.com/2019/01/24/11/","excerpt":"效果刷新页面，界面效果依然不会改变。","text":"效果刷新页面，界面效果依然不会改变。 相关代码html: 1234567891011121314&lt;div class=\"setting_tool iconfont\"&gt; &lt;a class=\"back2top\" style=\"display:none;\"&gt;&lt;i class=\"czs-arrow-up-l\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;a class=\"socolor\"&gt;&lt;i class=\"czs-clothes-l\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;div class=\"c\"&gt; &lt;ul&gt; &lt;li class=\"color undefined\"&gt;默认&lt;/li&gt; &lt;li class=\"color sepia\"&gt;护眼&lt;/li&gt; &lt;li class=\"color night\"&gt;夜晚&lt;/li&gt; &lt;li class=\"hr\"&gt;&lt;/li&gt; &lt;li class=\"font serif\"&gt;Serif&lt;/li&gt; &lt;li class=\"font sans\"&gt;Sans&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; javascrip: 12345678910111213141516171819202122232425$(\"li.undefined\").click(function()&#123; localStorage.removeItem('color_style'); $('.color-style').remove(); if(localStorage.color_style) $('head').append(\"&lt;style class='color-style'&gt;\" + localStorage.color_style + \"&lt;/style&gt;\"); &#125;); $(\"li.sepia\").click(function()&#123; localStorage.setItem(\"color_style\", \".menu .menu-item a.current-menu-item &#123;color:#704214;&#125;.article-title h2:hover&#123;color:#361e07&#125;【写你需要的改之后的样式】\") $('.color-style').remove(); if(localStorage.color_style) $('head').append(\"&lt;style class='color-style'&gt;\" + localStorage.color_style + \"&lt;/style&gt;\"); &#125;); $(\"li.night\").click(function()&#123; localStorage.setItem(\"color_style\", \".menu .menu-item a.current-menu-item &#123;color:#bdcadb;&#125;.article-title h2:hover&#123;color:white&#125;【写你需要的改之后的样式】\") $('.color-style').remove(); if(localStorage.color_style) $('head').append(\"&lt;style class='color-style'&gt;\" + localStorage.color_style + \"&lt;/style&gt;\"); &#125;); $(\"li.serif\").click(function()&#123; localStorage.setItem(\"font_style\",\"body&#123;font-family:serif;&#125;\") $('.font-style').remove(); if(localStorage.font_style) $('head').append(\"&lt;style class='font-style'&gt;\" + localStorage.font_style + \"&lt;/style&gt;\"); &#125;); $(\"li.sans\").click(function()&#123; localStorage.removeItem('font_style'); $('.font-style').remove(); if(localStorage.font_style) $('head').append(\"&lt;style class='font-style'&gt;\" + localStorage.font_style + \"&lt;/style&gt;\"); &#125;); 在页面头部添加 1234&lt;script&gt; if(localStorage.color_style) $('head').append(\"&lt;style class='color-style'&gt;\" + localStorage.color_style + \"&lt;/style&gt;\"); if(localStorage.font_style) $('head').append(\"&lt;style class='font-style'&gt;\" + localStorage.font_style + \"&lt;/style&gt;\"); &lt;/script&gt; 原理点击选择相应的颜色，字体后，添加本地存储localStorage.color_style和localStorage.font_style，用添加的本地存储样式覆盖掉现有的样式，在页面头部添加的js保证刷新跳转后页面样式不变。 本地存储localStorage 相关知识1、简介localStorage会可以将数据直接存储到本地，相当于一个5M大小的针对于前端页面的数据库。在IE8以上的IE版本才支持localStorage这个属性。localStorage属于永久性存储，如果存储内容多的话会消耗内存空间，会导致页面变卡。注意：存入的数据只能以字符串形式存入。 2、存储与清除// 存储localStorage.setItem(“font_style”,”body{font-family:serif;}”) // 清除键值对localStorage.removeItem(‘color_style’); // 清空localStoragelocalStorage.clear(); 3、处理JSON数据var obj = {“a”: 1,”b”: 2}; // 转化为JSON字符串obj = JSON.stringify(obj); //保存localStorage.setItem(“temp2”, obj); //JSON字符串转JSON对象obj=JSON.parse(localStorage.getItem(“temp2”));","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"LocalStorage","slug":"LocalStorage","permalink":"http://yoursite.com/tags/LocalStorage/"},{"name":"网页换肤","slug":"网页换肤","permalink":"http://yoursite.com/tags/网页换肤/"},{"name":"Web前端","slug":"Web前端","permalink":"http://yoursite.com/tags/Web前端/"}]},{"title":"c++ 实现红外图与深度图结合的人脸识别+活体检测（Ubuntu +dlib）","slug":"19","date":"2019-01-23T04:00:20.000Z","updated":"2019-12-18T04:15:07.817Z","comments":true,"path":"2019/01/23/19/","link":"","permalink":"http://yoursite.com/2019/01/23/19/","excerpt":"准备:1、Ubuntu C++ 编译dlib库https://blog.csdn.net/ffcjjhv/article/details/84660869 2、数据+模型下载https://pan.baidu.com/s/1jIoW6BSa5nkGWNipL7sxVQ","text":"准备:1、Ubuntu C++ 编译dlib库https://blog.csdn.net/ffcjjhv/article/details/84660869 2、数据+模型下载https://pan.baidu.com/s/1jIoW6BSa5nkGWNipL7sxVQ 其中包括： candidate-face.zip（人脸库：包含29个正面人脸红外图） allface.zip（测试人脸集：包括29个人，每人13种脸部姿态下的红外图与深度图） shape_predictor_68_face_landmarks.dat（人脸68关键点检测器） dlib_face_recognition_resnet_model_v1.dat（人脸识别模型） 代码分析:主要包含3个函数： 123/* 函数声明 *//* 人脸库训练 */int candidates_train(const char *facesFile,std::vector&lt;matrix&lt;float,0,1&gt;&gt;&amp;candidates_descriptors,std::vector&lt;string&gt;&amp;candidates); 运行candidates_train，遍历人脸库candidate-face文件夹，将候选人名单存入candidates，将候选人人脸特征存入candidates_descriptors。 12/* 输出人脸位置 返回识别结果 */string face_location(const char *imgFile,std::vector&lt;int&gt;&amp;locates, std::vector&lt;matrix&lt;float,0,1&gt;&gt;&amp;candidates_descriptors,std::vector&lt;string&gt;&amp;candidates); 运行face_location，得到要测试图片的人脸特征，计算与每个候选人人脸特征的欧式距离，得到距离最小值的编号，从而在candidates中得到识别结果。在函数运行过程中，将人脸位置信息传入locates，进行活体检测。 12/* 判断是否为活体 */bool liveness_detection(const char *DeepFile,std::vector&lt;int&gt;&amp;locates); 运行liveness_detection，利用深度图与人脸位置信息进行活体检测，主要利用了RANSAC算法。 运行结果：补充：python版的看这里 https://blog.csdn.net/ffcjjhv/article/details/84637986python版的在allface文件夹共375张图片上的识别精度为99.469%，出错的两张是allleft姿态，侧转角度很大。模型算法和这篇c++版是一样的，只是语言不一样。可以看出识别效果还是很好的。this_is_who.py在test-face文件夹中的批量测试结果： 完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include &lt;dlib/dnn.h&gt;#include &lt;dlib/image_processing/frontal_face_detector.h&gt;#include &lt;dlib/image_processing.h&gt;#include &lt;dlib/gui_widgets.h&gt;#include &lt;dlib/image_io.h&gt;#include &lt;iostream&gt;#include &lt;dirent.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace dlib;using namespace std;/* 函数声明 *//* 人脸库训练 */int candidates_train(const char *facesFile,std::vector&lt;matrix&lt;float,0,1&gt;&gt;&amp;candidates_descriptors,std::vector&lt;string&gt;&amp;candidates);/* 输出人脸位置 返回识别结果 */string face_location(const char *imgFile,std::vector&lt;int&gt;&amp;locates, std::vector&lt;matrix&lt;float,0,1&gt;&gt;&amp;candidates_descriptors,std::vector&lt;string&gt;&amp;candidates);/* 判断是否为活体 */bool liveness_detection(const char *DeepFile,std::vector&lt;int&gt;&amp;locates); const int IMG_HEIGHT = 720;const int IMG_WIDTH = 1280;template &lt;template &lt;int,template&lt;typename&gt;class,int,typename&gt; class block, int N, template&lt;typename&gt;class BN, typename SUBNET&gt;using residual = add_prev1&lt;block&lt;N,BN,1,tag1&lt;SUBNET&gt;&gt;&gt;;template &lt;template &lt;int,template&lt;typename&gt;class,int,typename&gt; class block, int N, template&lt;typename&gt;class BN, typename SUBNET&gt;using residual_down = add_prev2&lt;avg_pool&lt;2,2,2,2,skip1&lt;tag2&lt;block&lt;N,BN,2,tag1&lt;SUBNET&gt;&gt;&gt;&gt;&gt;&gt;;template &lt;int N, template &lt;typename&gt; class BN, int stride, typename SUBNET&gt; using block = BN&lt;con&lt;N,3,3,1,1,relu&lt;BN&lt;con&lt;N,3,3,stride,stride,SUBNET&gt;&gt;&gt;&gt;&gt;;template &lt;int N, typename SUBNET&gt; using ares = relu&lt;residual&lt;block,N,affine,SUBNET&gt;&gt;;template &lt;int N, typename SUBNET&gt; using ares_down = relu&lt;residual_down&lt;block,N,affine,SUBNET&gt;&gt;;template &lt;typename SUBNET&gt; using alevel0 = ares_down&lt;256,SUBNET&gt;;template &lt;typename SUBNET&gt; using alevel1 = ares&lt;256,ares&lt;256,ares_down&lt;256,SUBNET&gt;&gt;&gt;;template &lt;typename SUBNET&gt; using alevel2 = ares&lt;128,ares&lt;128,ares_down&lt;128,SUBNET&gt;&gt;&gt;;template &lt;typename SUBNET&gt; using alevel3 = ares&lt;64,ares&lt;64,ares&lt;64,ares_down&lt;64,SUBNET&gt;&gt;&gt;&gt;;template &lt;typename SUBNET&gt; using alevel4 = ares&lt;32,ares&lt;32,ares&lt;32,SUBNET&gt;&gt;&gt;;using anet_type = loss_metric&lt;fc_no_bias&lt;128,avg_pool_everything&lt; alevel0&lt; alevel1&lt; alevel2&lt; alevel3&lt; alevel4&lt; max_pool&lt;3,3,2,2,relu&lt;affine&lt;con&lt;32,7,7,2,2, input_rgb_image_sized&lt;150&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;frontal_face_detector detector = get_frontal_face_detector(); // 人脸正脸检测器shape_predictor sp; //人脸关键点检测器anet_type net; // 人脸识别模型int main()&#123; const char *imgFile = \"/home/zhoujie/data/allface/0002_IR_allleft.jpg\"; const char *facesFile = \"/home/zhoujie/cProject/dlib_test/candidate-face/\"; deserialize(\"shape_predictor_68_face_landmarks.dat\") &gt;&gt; sp; deserialize(\"dlib_face_recognition_resnet_model_v1.dat\") &gt;&gt; net; std::vector&lt;matrix&lt;float,0,1&gt;&gt; candidates_descriptors; std::vector&lt;string&gt; candidates; /* 人脸库训练 */ candidates_train(facesFile,candidates_descriptors,candidates); std::vector&lt;int&gt; locates; /* 输出人脸位置 返回识别结果 */ string who = face_location(imgFile, locates, candidates_descriptors,candidates); cout &lt;&lt; \"识别结果：\" &lt;&lt; endl; cout &lt;&lt; \"This is \" &lt;&lt; who &lt;&lt; endl; //深度图与红外图是水平翻转的 locates[0] = IMG_WIDTH - locates[0] -locates[2]; // printf(\"%d,%d,%d,%d\\n\", locates[0],locates[1],locates[2],locates[3]); const char *DeepFile = \"/home/zhoujie/data/allface/0002_raw_allleft.raw\"; bool IS_FACE; /* 判断是否为活体 */ IS_FACE = liveness_detection( DeepFile, locates); // printf(\"RESULT : %d\\n\", IS_FACE);&#125;/* 人脸库训练 */int candidates_train(const char *facesFile,std::vector&lt;matrix&lt;float,0,1&gt;&gt;&amp;candidates_descriptors,std::vector&lt;string&gt;&amp;candidates)&#123; DIR *dir; struct dirent *ptr; char base[30]; const char *pick=\".jpg\"; //需要的子串; char IRfile[100]; char *name; int face_num = 0; std::vector&lt;matrix&lt;rgb_pixel&gt;&gt; faces; if ((dir=opendir(facesFile)) == NULL) &#123; perror(\"Open dir error...\"); exit(1); &#125; while ((ptr=readdir(dir)) != NULL) &#123; strcpy(base, ptr-&gt;d_name); if(strstr(base,pick)) &#123; printf(\"training image:%s\\n\",base); strcpy(IRfile, facesFile); strcat(IRfile, base); name = strtok(base, \"_\"); // printf(\"%s\\n\",name); string candidate = name; cout &lt;&lt; \"candidate: \" &lt;&lt; candidate &lt;&lt; endl; candidates.push_back(candidate); matrix&lt;rgb_pixel&gt; img; load_image(img, IRfile); std::vector&lt;rectangle&gt; dets = detector(img); full_object_detection shape = sp(img, dets[0]); matrix&lt;rgb_pixel&gt; face_chip; extract_image_chip(img, get_face_chip_details(shape,150,0.25), face_chip); faces.push_back(move(face_chip)); face_num += 1; &#125; &#125; candidates_descriptors = net(faces); printf(\"训练结果：\\n共训练 %d 张人脸\\n\", face_num); closedir(dir); return 0;&#125;/* 函数 输出人脸位置 返回识别结果 */string face_location(const char* imgFile,std::vector&lt;int&gt;&amp;locates, std::vector&lt;matrix&lt;float,0,1&gt;&gt;&amp;candidates_descriptors,std::vector&lt;string&gt;&amp;candidates)&#123; cout &lt;&lt; \"processing image \" &lt;&lt; imgFile &lt;&lt; endl; matrix&lt;rgb_pixel&gt; img; load_image(img, imgFile); std::vector&lt;rectangle&gt; dets = detector(img); // cout &lt;&lt; \"Number of faces detected: \" &lt;&lt; dets.size() &lt;&lt; endl; locates.push_back(dets[0].left()); locates.push_back(dets[0].top()); locates.push_back(dets[0].right() - dets[0].left()); locates.push_back(dets[0].bottom() - dets[0].top()); full_object_detection shape = sp(img, dets[0]); std::vector&lt;matrix&lt;rgb_pixel&gt;&gt; faces; matrix&lt;rgb_pixel&gt; face_chip; extract_image_chip(img, get_face_chip_details(shape,150,0.25), face_chip); faces.push_back(move(face_chip)); std::vector&lt;matrix&lt;float,0,1&gt;&gt; face_descriptors = net(faces); float distance; float best_distance = length(face_descriptors[0]-candidates_descriptors[0]); // printf(\"k = 0 ,best_distance = %f\\n\",best_distance); size_t candidates_num = candidates_descriptors.size(); int candidates_num_int = static_cast&lt;int&gt;(candidates_num); // printf(\"candidates_num_int : %d\\n\", candidates_num_int); int best_k = 0; for (int k = 1; k &lt; candidates_num_int; k++) &#123; distance = length(face_descriptors[0]-candidates_descriptors[k]); // printf(\"k = %d ,distance = %f\\n\",k,distance); if (distance &lt; best_distance) &#123; best_distance = distance; best_k = k; &#125; &#125; string who; if (best_distance &lt; 0.6) &#123; who = candidates[best_k]; &#125; else&#123; who = \"Unknow\"; &#125; return who;&#125;/* 函数判断是否为活体 */bool liveness_detection(const char *DeepFile,std::vector&lt;int&gt;&amp;locates)&#123; const int ITER = 5000; // 随机取点次数 const float PLANE_OR_NOT = 0.2; // 判断是否为平面的分界线 const int SIGMA = 1; typedef unsigned short UNIT16; // 从.raw读取二进制16位数据到MatDATA UNIT16 MatDATA[IMG_HEIGHT*IMG_WIDTH]; FILE *fp = NULL; fp = fopen( DeepFile, \"rb\" ); size_t sizeRead = fread(MatDATA,sizeof(UNIT16),IMG_HEIGHT*IMG_WIDTH,fp); if (sizeRead != IMG_HEIGHT*IMG_WIDTH) &#123; printf(\"error!\\n\"); &#125; fclose(fp); int n = 0; int i,j; int COL = locates[0],ROW = locates[1],FACE_WIDTH = locates[2],FACE_HEIGHT = locates[3]; //位置信息 // txt :157 66 172 198 , 取行66：66+198,列取157：157+172 int faceno0_num = FACE_HEIGHT*FACE_WIDTH -1; int FaceDATA[3][100000]; n = 0; for(i = 1;i&lt; FACE_HEIGHT+1;i++) &#123; for(j= 1;j&lt; FACE_WIDTH+1;j++) &#123; if (MatDATA[IMG_WIDTH*(ROW+i-2)+COL+j-2] == 0) &#123; faceno0_num -= 1; // 非零深度点个数为 faceno0_num+1 continue; &#125; FaceDATA[1][n] = i; FaceDATA[0][n] = j; FaceDATA[2][n] = MatDATA[IMG_WIDTH*(ROW+i-2)+COL+j-2]; n += 1; &#125; &#125; // int test = 0; // printf(\"%d,%d,%d,%d\\n\",test,FaceDATA[0][test],FaceDATA[1][test],FaceDATA[2][test]); int pretotal = 0; // 符合拟合模型的数据的个数 int x[3],y[3],z[3]; // 随机取三个点 srand((unsigned)time(NULL)); float a,b,c; // 拟合平面方程 z=ax+by+c // float besta,bestb,bestc; // 最佳参数 int rand_num[3]; float check,distance; int total = 0; for(i = 0; i &lt; ITER; i++) &#123; do&#123; rand_num[0] = std::rand()%faceno0_num; rand_num[1] = std::rand()%faceno0_num; rand_num[2] = std::rand()%faceno0_num; &#125;while(rand_num[0] == rand_num[1] || rand_num[0] == rand_num[2] || rand_num[1] == rand_num[2]); for(n = 0; n &lt; 3; n++ ) &#123; x[n] = FaceDATA[0][rand_num[n]]; y[n] = FaceDATA[1][rand_num[n]]; z[n] = FaceDATA[2][rand_num[n]]; // printf(\"%d,%d,%d,%d\\n\", x[n],y[n],z[n],n); &#125; check = (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]); if ( check == 0) // 防止提示浮点数例外 (核心已转储) &#123; i -= 1; continue; &#125; a = ( (z[0]-z[1])*(y[0]-y[2]) - (z[0]-z[2])*(y[0]-y[1]) )*1.0/( (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]) ); if (y[0] == y[2]) // 防止提示浮点数例外 (核心已转储) &#123; i -= 1; continue; &#125; b = ((z[0] - z[2]) - a * (x[0] - x[2]))*1.0/(y[0]-y[2]); c = z[0]- a * x[0] - b * y[0]; // printf(\"%f,%f,%f\\n\",a,b,c); total = 0; for(n = 0; n &lt; faceno0_num +1 ; n++ ) &#123; distance = fabs(a*FaceDATA[0][n] + b*FaceDATA[1][n] - 1*FaceDATA[2][n] + c*1); if (distance &lt; SIGMA) &#123; total +=1; &#125; &#125; // printf(\"%d,%f,%d\\n\",i,distance,total); if (total &gt; pretotal) // 找到符合拟合平面数据最多的拟合平面 &#123; pretotal=total; // besta = a; // bestb = b; // bestc = c; &#125; &#125; float pretotal_ary = pretotal *1.0/ faceno0_num ; printf(\"活体检测结果：\\npretotal_ary=%f,\",pretotal_ary); bool IS_FACE; if (pretotal_ary &lt; PLANE_OR_NOT) &#123; IS_FACE = true; printf(\"是人脸\\n\"); &#125; else &#123; IS_FACE = false; printf(\"不是人脸\\n\"); &#125; // printf(\"%d\\n\", IS_FACE); return IS_FACE;&#125;","categories":[{"name":"深度相机","slug":"深度相机","permalink":"http://yoursite.com/categories/深度相机/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"活体检测","slug":"活体检测","permalink":"http://yoursite.com/tags/活体检测/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"Dlib","slug":"Dlib","permalink":"http://yoursite.com/tags/Dlib/"},{"name":"人脸识别","slug":"人脸识别","permalink":"http://yoursite.com/tags/人脸识别/"}]},{"title":"微信小程序 人脸追踪+人脸识别+视频上传 页面","slug":"10","date":"2019-01-17T04:23:19.000Z","updated":"2019-12-18T04:05:37.616Z","comments":true,"path":"2019/01/17/10/","link":"","permalink":"http://yoursite.com/2019/01/17/10/","excerpt":"效果图：调用的百度人脸识别api，免费账户就可以，虽然有QPS限制但对于自己学习使用是足够的。","text":"效果图：调用的百度人脸识别api，免费账户就可以，虽然有QPS限制但对于自己学习使用是足够的。 代码：wxml： 12345678910111213141516171819202122232425262728&lt;view class=&quot;page-body&quot;&gt; &lt;view class=&quot;page-body-wrapper&quot;&gt; &lt;camera device-position=&quot;front&quot; flash=&quot;off&quot; binderror=&quot;error&quot; style=&quot;width:100%;height:300px;&quot;&gt;&lt;/camera&gt; &lt;canvas wx:if=&quot;&#123;&#123;canvasshow&#125;&#125;&quot; style=&quot;width: 100%;height:300px;position:absolute;&quot; canvas-id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;view class=&quot;btn-area&quot;&gt; &lt;button type=&quot;primary&quot; bindtap=&quot;track&quot; style=&apos;background-color:#31859c;&apos; data-trackshow=&quot;&#123;&#123;trackshow&#125;&#125;&quot;&gt;&#123;&#123;trackshow&#125;&#125;&lt;/button&gt; &lt;/view&gt; &lt;view class=&quot;btn-area&quot;&gt; &lt;button type=&quot;primary&quot; bindtap=&quot;search&quot; style=&apos;background-color:#31859c;&apos;&gt;进行人脸识别&lt;/button&gt; &lt;/view&gt; &lt;view class=&quot;btn-area&quot;&gt; &lt;button type=&quot;primary&quot; bindtap=&quot;startRecord&quot; style=&apos;background-color:#31859c;&apos;&gt;开始录像&lt;/button&gt; &lt;/view&gt; &lt;view class=&quot;btn-area&quot;&gt; &lt;button type=&quot;primary&quot; bindtap=&quot;stopRecord&quot; style=&apos;background-color:#31859c;&apos;&gt;结束录像&lt;/button&gt; &lt;/view&gt; &lt;view class=&quot;preview-tips&quot;&gt;识别结果:&#123;&#123;who&#125;&#125;&lt;/view&gt; &lt;view wx:if=&quot;&#123;&#123;src&#125;&#125;&quot; style=&apos;display:flex;width:100%&apos;&gt; &lt;image mode=&quot;aspectFit&quot; src=&quot;&#123;&#123;src&#125;&#125;&quot; class=&apos;result-img&apos;&gt;&lt;/image&gt; &lt;canvas style=&quot;width: 100%;height:300px;position:absolute;&quot; canvas-id=&quot;canvasresult&quot;&gt;&lt;/canvas&gt; &lt;/view&gt; &lt;view wx:if=&quot;&#123;&#123;videoSrc&#125;&#125;&quot; class=&quot;preview-tips&quot;&gt;视频预览&lt;/view&gt; &lt;video wx:if=&quot;&#123;&#123;videoSrc&#125;&#125;&quot; class=&quot;video&quot; src=&quot;&#123;&#123;videoSrc&#125;&#125;&quot;&gt;&lt;/video&gt; &lt;view wx:if=&quot;&#123;&#123;videoSrc&#125;&#125;&quot; class=&quot;btn-area&quot;&gt; &lt;button type=&quot;primary&quot; bindtap=&quot;uploadRecord&quot; style=&apos;background-color:#31859c;&apos;&gt;上传该录像&lt;/button&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363var app = getApp();Page(&#123; data: &#123; src:&quot;&quot;, fengmian:&quot;&quot;, videoSrc:&quot;&quot;, who:&quot;&quot;, openid: &quot;&quot;, token: &quot;&quot;, windowWidth: 0, trackshow: &quot;进行人脸追踪&quot;, canvasshow:true &#125;, onLoad() &#123; var that = this //屏幕宽度 var sysInfo = wx.getSystemInfoSync() that.setData(&#123; windowWidth: sysInfo.windowWidth, &#125;) that.ctx = wx.createCameraContext() console.log(&quot;onLoad&quot;), that.setData(&#123; openid: app.globalData.openid, token: app.globalData.token &#125;); &#125;, onReady: function () &#123; // this.takePhoto() // this.interval = setInterval(this.takePhoto, 500) &#125;, track (e)&#123; var that =this if (e.target.dataset.trackshow ==&quot;进行人脸追踪&quot;)&#123; that.setData(&#123; trackshow: &quot;停止人脸追踪&quot;, canvasshow: true &#125;) that.takePhoto() that.interval = setInterval(this.takePhoto, 500) &#125;else&#123; clearInterval(that.interval) that.setData(&#123; trackshow: &quot;进行人脸追踪&quot;, canvasshow: false &#125;) &#125; &#125;, takePhoto() &#123; console.log(&quot;takePhoto&quot;) var that = this var takephonewidth var takephoneheight that.ctx.takePhoto(&#123; quality: &apos;low&apos;, success: (res) =&gt; &#123; // console.log(res.tempImagePath), // 获取图片真实宽高 wx.getImageInfo(&#123; src: res.tempImagePath, success: function (res) &#123; takephonewidth= res.width, takephoneheight = res.height &#125; &#125;) wx.getFileSystemManager().readFile(&#123; filePath: res.tempImagePath, //选择图片返回的相对路径 encoding: &apos;base64&apos;, //编码格式 success: res =&gt; &#123; //成功的回调 // console.log(&apos;data:image/png;base64,&apos; + res.data), wx.request(&#123; url: &quot;https://aip.baidubce.com/rest/2.0/face/v3/detect?access_token=【填自己的】&quot;, data: &#123; image:res.data, image_type:&quot;BASE64&quot;, max_face_num:10 &#125;, method: &apos;POST&apos;, dataType: &quot;json&quot;, header: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, success: function (res) &#123; console.log(res.data); if (res.data.error_code === 0) &#123; var ctx = wx.createContext() ctx.setStrokeStyle(&apos;#31859c&apos;) ctx.lineWidth = 3 for (let j = 0; j &lt; res.data.result.face_num; j++)&#123; var cavansl = res.data.result.face_list[j].location.left / takephonewidth * that.data.windowWidth var cavanst = res.data.result.face_list[j].location.top / takephoneheight * 300 var cavansw = res.data.result.face_list[j].location.width / takephonewidth * that.data.windowWidth var cavansh = res.data.result.face_list[j].location.height / takephoneheight * 300 ctx.strokeRect(cavansl, cavanst, cavansw, cavansh) &#125; wx.drawCanvas(&#123; canvasId: &apos;canvas&apos;, actions: ctx.getActions() &#125;) &#125;else&#123; var ctx = wx.createContext() ctx.setStrokeStyle(&apos;#31859c&apos;) ctx.lineWidth = 3 wx.drawCanvas(&#123; canvasId: &apos;canvas&apos;, actions: ctx.getActions() &#125;) &#125; &#125;, &#125;) &#125; &#125;) &#125; &#125;) &#125;, search()&#123; var that = this var takephonewidth var takephoneheight that.ctx.takePhoto(&#123; quality: &apos;heigh&apos;, success: (res) =&gt; &#123; // console.log(res.tempImagePath), // 获取图片真实宽高 wx.getImageInfo(&#123; src: res.tempImagePath, success: function (res) &#123; takephonewidth = res.width, takephoneheight = res.height &#125; &#125;) that.setData(&#123; src: res.tempImagePath &#125;), wx.getFileSystemManager().readFile(&#123; filePath: that.data.src, //选择图片返回的相对路径 encoding: &apos;base64&apos;, //编码格式 success: res =&gt; &#123; wx.request(&#123; url: &quot;https://aip.baidubce.com/rest/2.0/face/v3/multi-search?access_token=【填自己的】&quot;, data: &#123; image: res.data, image_type: &quot;BASE64&quot;, group_id_list: &quot;camera000001&quot;, max_face_num: 10, match_threshold: 60, &#125;, method: &apos;POST&apos;, dataType: &quot;json&quot;, header: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, success: function (res) &#123; console.log(res.data); var ctx = wx.createContext() if (res.data.error_code === 0) &#123; ctx.setStrokeStyle(&apos;#31859c&apos;) ctx.setFillStyle(&apos;#31859c&apos;); ctx.lineWidth = 3 for (let j = 0; j &lt; res.data.result.face_num; j++) &#123; var cavansl = res.data.result.face_list[j].location.left / takephonewidth * that.data.windowWidth var cavanst = res.data.result.face_list[j].location.top / takephoneheight * 300 var cavansw = res.data.result.face_list[j].location.width / takephonewidth * that.data.windowWidth var cavansh = res.data.result.face_list[j].location.height / takephoneheight * 300 var cavanstext = res.data.result.face_list[j].user_list[0].user_id + &quot; &quot; + res.data.result.face_list[j].user_list[0].score.toFixed(0) + &quot;%&quot; ctx.setFontSize(14); ctx.fillText(cavanstext, cavansl, cavanst-2) ctx.strokeRect(cavansl, cavanst, cavansw, cavansh) &#125; wx.drawCanvas(&#123; canvasId: &apos;canvasresult&apos;, actions: ctx.getActions() &#125;) &#125; else &#123; var ctx = wx.createContext() ctx.setStrokeStyle(&apos;#31859c&apos;) ctx.lineWidth = 3 wx.drawCanvas(&#123; canvasId: &apos;canvasresult&apos;, actions: ctx.getActions() &#125;) &#125; &#125;, &#125;) &#125; &#125;) &#125; &#125;) &#125;, startRecord() &#123; this.ctx.startRecord(&#123; success: (res) =&gt; &#123; console.log(&apos;startRecord&apos;) &#125;, &#125;) &#125;, stopRecord() &#123; this.ctx.stopRecord(&#123; success: (res) =&gt; &#123; console.log(res) this.setData(&#123; fengmian: res.tempThumbPath, videoSrc: res.tempVideoPath &#125;) &#125; &#125;) &#125;, uploadRecord() &#123; var that = this; wx.showLoading(&#123; title: &apos;上传中&apos;, &#125;) //获取摄像头信息 wx.request(&#123; url: app.globalData.urlHeader + &apos;/login/cameralist&apos;, data: &#123; openid: app.globalData.openid, token: app.globalData.token &#125;, method: &apos;POST&apos;, header: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, success: function (res) &#123; if (res.data.code === 0) &#123; if (res.data.data.cameras == null) &#123; wx.request(&#123; url: app.globalData.urlHeader + &apos;/login/addcamera&apos;, data: &#123; openid: app.globalData.openid, token: app.globalData.token, camera: &quot;phone&quot; &#125;, method: &apos;POST&apos;, header: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, success: function (res) &#123; if (res.data.code === 0) &#123; console.log(&apos;添加成功&apos;) &#125; else &#123; console.log(res.data.error) &#125; &#125; &#125;) &#125; else &#123; var cameras = res.data.data.cameras if (cameras.includes(&quot;phone&quot;)) &#123; return false &#125; else &#123; wx.request(&#123; url: app.globalData.urlHeader + &apos;/login/addcamera&apos;, data: &#123; openid: app.globalData.openid, token: app.globalData.token, camera: &quot;phone&quot; &#125;, method: &apos;POST&apos;, header: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, success: function (res) &#123; if (res.data.code === 0) &#123; console.log(&apos;添加成功&apos;) &#125; else &#123; console.log(res.data.error) &#125; &#125; &#125;) &#125; &#125; &#125; else &#123; wx.hideLoading() console.log(&apos;获取摄像头列表失败！&apos; + res.data.error) wx.showToast(&#123; title: &apos;获取摄像头列表失败！&apos;, image: &apos;../../img/about.png&apos;, duration: 1000 &#125;) &#125; &#125; &#125;) wx.uploadFile(&#123; url: app.globalData.urlHeader + &apos;/upload&apos;, filePath: that.data.videoSrc, name: &apos;file&apos;, formData: &#123; &apos;cameraid&apos;:&apos;phone&apos;, &apos;openid&apos;: that.data.openid, &apos;token&apos;: that.data.token, &#125;, success: function (res) &#123; console.log(res.data); var result = JSON.parse(res.data).data.filename console.log(result); wx.uploadFile(&#123; url: app.globalData.urlHeader + &apos;/upload/fengmian&apos;, filePath: that.data.fengmian, name: &apos;file&apos;, formData: &#123; &apos;openid&apos;: that.data.openid, &apos;token&apos;: that.data.token, &apos;name&apos;: result &#125;, success(res) &#123; console.log( res.data); that.setData(&#123; fengmian: &quot;&quot;, videoSrc:&quot;&quot; &#125;), wx.hideLoading() wx.showToast(&#123; title: &apos;上传成功&apos;, icon: &apos;success&apos;, duration: 2000 &#125;) &#125;, fail(res) &#123; wx.hideLoading() wx.showToast(&#123; title: &apos;上传失败&apos;, image: &apos;../../img/about.png&apos;, duration: 2000 &#125;) &#125; &#125;) &#125;, fail(res) &#123; wx.hideLoading() wx.showToast(&#123; title: &apos;上传失败&apos;, image: &apos;../../img/about.png&apos;, duration: 2000 &#125;) &#125; &#125;) &#125;, onUnload: function () &#123; var that=this clearInterval(that.interval) &#125;, error(e) &#123; console.log(e.detail) &#125;&#125;) wxss： 123456789101112131415161718192021222324252627282930313233343536373839.preview-tips &#123; margin: 50rpx 0 30rpx; &#125;.video &#123; margin: 20rpx auto; width: 100%; height: 300px;&#125;page &#123; background-color: #F8F8F8; height: 100%; font-size: 32rpx; line-height: 1.6;&#125;.page-body &#123; padding: 20rpx 0;&#125;.page-body-wrapper &#123; display: flex; flex-direction: column; align-items: center; width: 100%;&#125;.btn-area &#123; margin-top: 40rpx; box-sizing: border-box; width: 100%; padding: 0 30rpx;&#125;.result-img&#123;width:100%;height:300px;&#125; 自己的access_token获取看这里：http://ai.baidu.com/docs#/Face-Detect-V3/top在手机端的主页效果，第二个即为演示图上传的视频更新：改了识别结果显示方式，增加了多人识别。效果：类似的骨架提取：","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/categories/后台开发/"}],"tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"http://yoursite.com/tags/人脸识别/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"},{"name":"人脸追踪","slug":"人脸追踪","permalink":"http://yoursite.com/tags/人脸追踪/"},{"name":"视频上传","slug":"视频上传","permalink":"http://yoursite.com/tags/视频上传/"},{"name":"百度AI SDK","slug":"百度AI-SDK","permalink":"http://yoursite.com/tags/百度AI-SDK/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"matterport mask_rcnn配置运行 Ubuntu Jupyter&pycharm","slug":"8","date":"2018-12-17T09:00:42.000Z","updated":"2019-12-18T04:03:20.840Z","comments":true,"path":"2018/12/17/8/","link":"","permalink":"http://yoursite.com/2018/12/17/8/","excerpt":"mask_rcnn github地址：https://github.com/matterport/Mask_RCNN 一、配置1、安装 AnacondaAnaconda下载地址：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/","text":"mask_rcnn github地址：https://github.com/matterport/Mask_RCNN 一、配置1、安装 AnacondaAnaconda下载地址：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 2、python 3.6#创建名为tensorflow的python36环境 12conda create -n tensorflow python=3.6 //创建环境source activate tensorflow //激活环境 3、配置环境（1）安装Tensorflow(CPU) 1pip install tensorflow （2）安装keras 1pip install keras （3）安装opencv 1pip install opencv-python （4）安装其他依赖包 1234pip install cythonpip install scikit-imagepip install theanopip install jupyter （5）安装pycocotools#下载地址：https://github.com/waleedka/coco 解压后，cd到PythonAPI里面，输入 1make -j4 二、运行1、下载Mask-RCNNgithub地址：https://github.com/matterport/Mask_RCNN 2、下载coco权重文件 文件mask_rcnn_coco.h5 （246MB）下载地址：https://github.com/matterport/Mask_RCNN/releases若下载过慢，百度网盘： https://pan.baidu.com/s/18OYXRM3Fpqmk1cs9vH5WNA下载完成以后放在Mask_RCNN目录下 3、运行Mask_RCNN的demo（1）Jupyter运行Mask_RCNN根目录下输入： 1jupyter notebook 稍等片刻，会在浏览器打开页面，点击进入 samples目录，点击demo.ipynp进入代码运行页面 把pycocotools路径加到系统路径 1sys.path.append('/home/zhoujie/下载/coco-master/PythonAPI') 修改后点击保存按钮，再点击重启服务然后运行整个代码出现结果： （2）pycharm运行Mask_RCNN根目录下输入： 1jupyter notebook 稍等片刻，会在浏览器打开页面，点击进入 samples目录，点击demo.ipynp进入代码运行页面点击文件-下载-Python（.py），将demo.py保存到samples文件夹 把pycocotools路径加到系统路径 1sys.path.append('/home/zhoujie/下载/coco-master/PythonAPI') 再注释掉get_ipython().run_line_magic(&#39;matplotlib&#39;, &#39;inline&#39;)就可以运行demo.py了运行结果：","categories":[{"name":"python/机器学习","slug":"python-机器学习","permalink":"http://yoursite.com/categories/python-机器学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Mask_rcnn","slug":"Mask-rcnn","permalink":"http://yoursite.com/tags/Mask-rcnn/"},{"name":"Jupyter","slug":"Jupyter","permalink":"http://yoursite.com/tags/Jupyter/"}]},{"title":"微信小程序跳一跳html版复原（three.js+tween.js）","slug":"7","date":"2018-12-13T10:34:54.000Z","updated":"2019-12-18T04:02:19.394Z","comments":true,"path":"2018/12/13/7/","link":"","permalink":"http://yoursite.com/2018/12/13/7/","excerpt":"一、浏览器运行需要安装Tomcat后以类似 http://localhost:8080/zjgame/zjgame.html的方式访问，否则本地图片无法加载。注：本项目基于Three.js，是对微信小游戏跳一跳的html版改写，只供研究学习使用。","text":"一、浏览器运行需要安装Tomcat后以类似 http://localhost:8080/zjgame/zjgame.html的方式访问，否则本地图片无法加载。注：本项目基于Three.js，是对微信小游戏跳一跳的html版改写，只供研究学习使用。 效果图GitHub：https://github.com/zj19941113/You_Jump_I_Jump ,只供个人研究学习使用。Three.js+tween.js 基础(一)：https://blog.csdn.net/ffcjjhv/article/details/86632320配置腾讯云服务器 通过域名访问自己的网页tomcat：https://blog.csdn.net/ffcjjhv/article/details/85140212 二、在桌面运行 electron打包1、安装 node.js#下载：https://nodejs.org/en/cmd输入node -v 和npm -v查看是否安装成功 2、安装 electron命令行下载淘宝镜像命令工具 cnpm 1npm install cnpm -g --registry=http://registry.npm.taobao.org 用 cnpm 命令安装 electron 1cnpm install electron -g cmd输入electron -v查看是否安装成功 3、运行下载：https://github.com/zj19941113/You_Jump_I_Jump ，并解压，将zjgame.html重命名为index.html。 复制粘贴下面的 package.json 和 main.js文件，最终目录如图在package.json中： 12345&#123; \"name\" : \"your-app\", \"version\" : \"0.1.0\", \"main\" : \"main.js\"&#125; 在main.js中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const &#123;app, BrowserWindow&#125; = require('electron')const path = require('path')const url = require('url')// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the JavaScript object is garbage collected.let winfunction createWindow () &#123; // Create the browser window. win = new BrowserWindow(&#123;width: 800, height: 600&#125;) // and load the index.html of the app. win.loadURL(url.format(&#123; pathname: path.join(__dirname, 'index.html'), protocol: 'file:', slashes: true &#125;)) // Open the DevTools. win.webContents.openDevTools() // Emitted when the window is closed. win.on('closed', () =&gt; &#123; // Dereference the window object, usually you would store windows // in an array if your app supports multi windows, this is the time // when you should delete the corresponding element. win = null &#125;)&#125;// This method will be called when Electron has finished// initialization and is ready to create browser windows.// Some APIs can only be used after this event occurs.app.on('ready', createWindow)// Quit when all windows are closed.app.on('window-all-closed', () =&gt; &#123; // On macOS it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q if (process.platform !== 'darwin') &#123; app.quit() &#125;&#125;)app.on('activate', () =&gt; &#123; // On macOS it's common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (win === null) &#123; createWindow() &#125;&#125;)// In this file you can include the rest of your app's specific main process// code. You can also put them in separate files and require them here. 在项目目录下运行 1electron . 4、electron-packager打包为.exe（1）全局安装electron-packager1npm install electron-packager -g （2）运行打包命令1electron-packager . YOU_JUMP_I_JUMP --win --out outApp --arch=x64 --app-version 1.0.0 --electron-version 5.0.0 --overwrite --ignore=node_modules 在outApp\\YOU_JUMP_I_JUMP-win32-x64\\文件夹下生成可执行文件YOU_JUMP_I_JUMP.exe 5、源码加密在YOU_JUMP_I_JUMP-win32-x64\\resources\\app里有写的源码。写的代码完全暴露在用户电脑上是非常不安全的，可以通过electron 自带的加密功能解决这个问题。 （1）全局安装 asar1npm install asar -g （2）使用asar指令进行加密在resources目录下使用asar指令进行加密 1asar pack ./app app.asar 将原来的app文件夹删除，这样生成的app.asar就加密了之前的源代码双击YOU_JUMP_I_JUMP.exe运行","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"THREE","slug":"THREE","permalink":"http://yoursite.com/categories/THREE/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"},{"name":"跳一跳","slug":"跳一跳","permalink":"http://yoursite.com/tags/跳一跳/"},{"name":"Three.js","slug":"Three-js","permalink":"http://yoursite.com/tags/Three-js/"},{"name":"Tween.js","slug":"Tween-js","permalink":"http://yoursite.com/tags/Tween-js/"},{"name":"Electron","slug":"Electron","permalink":"http://yoursite.com/tags/Electron/"}]},{"title":"Ubuntu下编译C++与python版Dlib库，附新建样例程序（dlib+opencv）","slug":"6","date":"2018-11-30T08:55:00.000Z","updated":"2019-12-18T04:02:22.058Z","comments":true,"path":"2018/11/30/6/","link":"","permalink":"http://yoursite.com/2018/11/30/6/","excerpt":"Win10+python36+opencv编译配置Dlib（anoconda）实时人脸识别看这里：https://blog.csdn.net/ffcjjhv/article/details/84992881 下载Dlib进入官网：http://dlib.net/ ，点击左下角Download dlib ver.19.16 ，下载后解压。","text":"Win10+python36+opencv编译配置Dlib（anoconda）实时人脸识别看这里：https://blog.csdn.net/ffcjjhv/article/details/84992881 下载Dlib进入官网：http://dlib.net/ ，点击左下角Download dlib ver.19.16 ，下载后解压。 安装cmake运行 sudo apt-get install cmake 安装cmake ，如果提醒需要apt-get update，那就先sudo apt-get update，然后再执行 sudo apt-get install cmake 1. Python 编译dlib +opencv（只编译C++版，可跳过此步）编译dlibdlib根目录下运行python setup.py install 安装opencv运行 pip install opencv-python 测试自己的程序下载： https://github.com/zj19941113/Face_Recognition_dlib运行python facerec_68point.py 得到识别结果all-face-result.jpg 在anoconda下编译dlib +opencv在dlib根目录下运行：conda create -n py36 python=3.6source activate py36python setup.py installpip install opencv-python 下载： https://github.com/zj19941113/Face_Recognition_dlib 解压后，在当前项目根目录运行： source activate py36python facerec_68point.py 2. C++ 编译dlib +opencv（在dlib根目录下已编译过python版也不影响）仍然先进入dlib根目录下mkdir build //如果已经编译过python版，此步略过cd buildcmake .. -DDLIB_USE_CUDA=0cmake --build . --config Releasesudo make install 到此dlib已经编译好了 opencv的编译参考 https://blog.csdn.net/cocoaqin/article/details/78163171 测试自己的程序新建文件夹dlib_test dlib_test.cpp文件：打开 http://dlib.net/face_landmark_detection_ex.cpp.html ,拷贝全文粘贴到dlib_test.cpp shape_predictor_68_face_landmarks.dat文件：点击：http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2 下载面部特征点检测模型shape_predictor_68_face_landmarks.dat.bz2 ，运行bunzip2 shape_predictor_68_face_landmarks.dat.bz2 进行解压 CMakeLists.txt文件：12345678910111213141516cmake_minimum_required(VERSION 2.8.4) PROJECT(dlib_test) SET(CMAKE_CXX_FLAGS \"$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11 -O2\")IF(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\") SET(CMAKE_CXX_FLAGS \"$&#123;CMAKE_CXX_FLAGS&#125; -Weverything\") ELSEIF(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\") SET(CMAKE_CXX_FLAGS \"$&#123;CMAKE_CXX_FLAGS&#125; -Wall -Wextra\") ENDIF() INCLUDE(/home/zhoujie/dlib-19.16/dlib/cmake) //需修改为自己的路径ADD_EXECUTABLE(dlib_test dlib_test.cpp) TARGET_LINK_LIBRARIES(dlib_test dlib) 注：INCLUDE(/home/zhoujie/dlib-19.16/dlib/cmake) 需修改为自己的路径 运行：在 dlib_test 文件夹根目录运行cmake .make./dlib_test shape_predictor_68_face_landmarks.dat all-face.jpg 运行结果：","categories":[{"name":"深度相机","slug":"深度相机","permalink":"http://yoursite.com/categories/深度相机/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"python/机器学习","slug":"python-机器学习","permalink":"http://yoursite.com/categories/python-机器学习/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Dlib","slug":"Dlib","permalink":"http://yoursite.com/tags/Dlib/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"人脸识别","slug":"人脸识别","permalink":"http://yoursite.com/tags/人脸识别/"},{"name":"Cmake","slug":"Cmake","permalink":"http://yoursite.com/tags/Cmake/"}]},{"title":"Ubuntu+dlib+opencv摄像头实时人脸识别（含训练人脸库）","slug":"5","date":"2018-11-29T10:50:47.000Z","updated":"2019-12-18T04:02:24.044Z","comments":true,"path":"2018/11/29/5/","link":"","permalink":"http://yoursite.com/2018/11/29/5/","excerpt":"环境 Ubuntu 16.04 opencv 3.0 for python3.6 pip install opencv-python dlib 19.16","text":"环境 Ubuntu 16.04 opencv 3.0 for python3.6 pip install opencv-python dlib 19.16 模型下载人脸关键点检测器 predictor_path=&quot;shape_predictor_68_face_landmarks.dat人脸识别模型 face_rec_model_path = &quot;dlib_face_recognition_resnet_model_v1.dat含人脸库candidate-face中人脸不同表情的测试数据集 test-face.zip 解压后与上述文件均置于根目录下下载地址 ： 百度云盘 https://pan.baidu.com/s/1h01sfvf5KWU6_7c2-i5HTQ 运行运行python candidate_train.py 获得人脸库特征信息，存储在candidates.npy 与 candidates.txt 中 。 candidate_train.py文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# -*- coding: UTF-8 -*-import os,dlib,numpyimport cv2# 1.人脸关键点检测器predictor_path = \"shape_predictor_68_face_landmarks.dat\"# 2.人脸识别模型face_rec_model_path = \"dlib_face_recognition_resnet_model_v1.dat\"# 3.候选人脸文件夹faces_folder_path = \"candidate-face\"# 4.需识别的人脸img_path = \"test-face/0001_IR_allleft.jpg\"# 5.识别结果存放文件夹faceRect_path = \"faceRec\"# 1.加载正脸检测器detector = dlib.get_frontal_face_detector()# 2.加载人脸关键点检测器sp = dlib.shape_predictor(predictor_path)# 3. 加载人脸识别模型facerec = dlib.face_recognition_model_v1(face_rec_model_path)# 候选人脸描述子listcandidates = []filelist = os.listdir(faces_folder_path)count = 0for fn in filelist: count = count+1descriptors = numpy.zeros(shape=(count,128))n = 0for file in filelist: f = os.path.join(faces_folder_path,file) #if os.path.splitext(file)[1] == \".jpg\" #文件扩展名 print(\"Processing file: &#123;&#125;\".format(f)) img = cv2.imread(f) # 1.人脸检测 dets = detector(img, 1) for k, d in enumerate(dets): # 2.关键点检测 shape = sp(img, d) # 3.描述子提取，128D向量 face_descriptor = facerec.compute_face_descriptor(img, shape) # 转换为numpy array v = numpy.array(face_descriptor) descriptors[n] = v # descriptors.append(v) candidates.append(os.path.splitext(file)[0]) n += 1 for d in dets: # print(\"faceRec locate:\",d) # print(type(d)) # 使用opencv在原图上画出人脸位置 left_top = (dlib.rectangle.left(d), dlib.rectangle.top(d)) right_bottom = (dlib.rectangle.right(d), dlib.rectangle.bottom(d)) cv2.rectangle(img, left_top, right_bottom, (0, 255, 0), 2, cv2.LINE_AA) # cv2.imwrite(os.path.join(faceRect_path,file), img)numpy.save('candidates.npy',descriptors)file= open('candidates.txt', 'w')for candidate in candidates: file.write(candidate) file.write('\\n')file.close() 运行 python facerec_68point.py 得到识别结果all-face-result.jpg。 facerec_68point.py文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# -*- coding: UTF-8 -*-import dlibimport cv2import numpy# 待检测图片img_path = \"all-face.jpg\"# 人脸关键点检测器predictor_path=\"shape_predictor_68_face_landmarks.dat\"# 人脸识别模型face_rec_model_path = \"dlib_face_recognition_resnet_model_v1.dat\"# 候选人文件candidate_npydata_path = \"candidates.npy\"candidate_path = \"candidates.txt\"# 加载正脸检测器detector = dlib.get_frontal_face_detector()# 加载人脸关键点检测器sp = dlib.shape_predictor(predictor_path)# 加载人脸识别模型facerec = dlib.face_recognition_model_v1(face_rec_model_path)# 候选人脸描述子list# 读取候选人数据npy_data=numpy.load(candidate_npydata_path)descriptors=npy_data.tolist()# 候选人名单candidate = []file=open(candidate_path, 'r')list_read = file.readlines()for name in list_read: name = name.strip('\\n') candidate.append(name)print(\"Processing file: &#123;&#125;\".format(img_path))img = cv2.imread(img_path)# 1.人脸检测dets = detector(img, 1)print(\"Number of faces detected: &#123;&#125;\".format(len(dets)))for k, d in enumerate(dets): # 2.关键点检测 shape = sp(img, d) face_descriptor = facerec.compute_face_descriptor(img, shape) d_test2 = numpy.array(face_descriptor) # 计算欧式距离 dist = [] for i in descriptors: dist_ = numpy.linalg.norm(i - d_test2) dist.append(dist_) num = dist.index(min(dist)) # 返回最小值 left_top = (dlib.rectangle.left(d), dlib.rectangle.top(d)) right_bottom = (dlib.rectangle.right(d), dlib.rectangle.bottom(d)) cv2.rectangle(img, left_top, right_bottom, (0, 255, 0), 2, cv2.LINE_AA) text_point = (dlib.rectangle.left(d), dlib.rectangle.top(d) - 5) cv2.putText(img, candidate[num], text_point, cv2.FONT_HERSHEY_PLAIN, 2.0, (255, 255, 255), 2, 1) # 标出facecv2.imwrite('all-face-result.jpg', img)# cv2.imshow(\"img\",img) # 转成ＢＧＲ显示## cv2.waitKey(0)# cv2.destroyAllWindows() 运行 this_is_who_camera.py 打开摄像头进行实时的人脸识别 this_is_who_camera.py文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# -*- coding: UTF-8 -*-import dlib,numpy import cv2 import time# 1.人脸关键点检测器predictor_path = \"shape_predictor_68_face_landmarks.dat\"# 2.人脸识别模型face_rec_model_path = \"dlib_face_recognition_resnet_model_v1.dat\"# 3.候选人文件candidate_npydata_path = \"candidates.npy\"candidate_path = \"candidates.txt\"# 4.储存截图目录path_screenshots = \"screenShots/\"# 加载正脸检测器detector = dlib.get_frontal_face_detector()# 加载人脸关键点检测器sp = dlib.shape_predictor(predictor_path)# 加载人脸识别模型facerec = dlib.face_recognition_model_v1(face_rec_model_path)# 候选人脸描述子list# 读取候选人数据npy_data=numpy.load(candidate_npydata_path)descriptors=npy_data.tolist()# 候选人名单candidate = []file=open(candidate_path, 'r')list_read = file.readlines()for name in list_read: name = name.strip('\\n') candidate.append(name)# 创建 cv2 摄像头对象cv2.namedWindow(\"camera\", 1)cap = cv2.VideoCapture(0)cap.set(3, 480)# 截图 screenshots 的计数器cnt = 0while (cap.isOpened()): #isOpened() 检测摄像头是否处于打开状态 ret, img = cap.read() #把摄像头获取的图像信息保存之img变量 if ret == True: #如果摄像头读取图像成功 # 添加提示 cv2.putText(img, \"press 'S': screenshot\", (20, 400), cv2.FONT_HERSHEY_PLAIN, 1, (255, 255, 255), 1, cv2.LINE_AA) cv2.putText(img, \"press 'Q': quit\", (20, 450), cv2.FONT_HERSHEY_PLAIN, 1, (255, 255, 255), 1, cv2.LINE_AA) # img_gray = cv2.cvtColor(im_rd, cv2.COLOR_RGB2GRAY) dets = detector(img, 1) if len(dets) != 0: # 检测到人脸 for k, d in enumerate(dets): # 关键点检测 shape = sp(img, d) # 遍历所有点圈出来 for pt in shape.parts(): pt_pos = (pt.x, pt.y) cv2.circle(img, pt_pos, 2, (0, 255, 0), 1) face_descriptor = facerec.compute_face_descriptor(img, shape) d_test2 = numpy.array(face_descriptor) # 计算欧式距离 dist = [] for i in descriptors: dist_ = numpy.linalg.norm(i - d_test2) dist.append(dist_) num = dist.index(min(dist)) # 返回最小值 left_top = (dlib.rectangle.left(d), dlib.rectangle.top(d)) right_bottom = (dlib.rectangle.right(d), dlib.rectangle.bottom(d)) cv2.rectangle(img, left_top, right_bottom, (0, 255, 0), 2, cv2.LINE_AA) text_point = (dlib.rectangle.left(d), dlib.rectangle.top(d) - 5) cv2.putText(img, candidate[num][0:4], text_point, cv2.FONT_HERSHEY_PLAIN, 2.0, (255, 255, 255), 1, 1) # 标出face cv2.putText(img, \"facesNum: \" + str(len(dets)), (20, 50), cv2.FONT_HERSHEY_PLAIN, 1.5, (0, 0, 0), 2, cv2.LINE_AA) else: # 没有检测到人脸 cv2.putText(img, \"facesNum:0\", (20, 50), cv2.FONT_HERSHEY_PLAIN, 1.5, (0, 0, 0), 2, cv2.LINE_AA) k = cv2.waitKey(1) # 按下 's' 键保存 if k == ord('s'): cnt += 1 print(path_screenshots + \"screenshot\" + \"_\" + str(cnt) + \"_\" + time.strftime(\"%Y-%m-%d-%H-%M-%S\", time.localtime()) + \".jpg\") cv2.imwrite(path_screenshots + \"screenshot\" + \"_\" + str(cnt) + \"_\" + time.strftime(\"%Y-%m-%d-%H-%M-%S\", time.localtime()) + \".jpg\", img) # 按下 'q' 键退出 if k == ord('q'): break cv2.imshow(\"camera\", img)# 释放摄像头cap.release()cv2.destroyAllWindows() 补充 每次人脸库candidate-face中加入新的人脸数据，均需运行python candidate_train.py python facerec_68point.py检测的是与人脸库中最相似的 提供 this_is_who.py 进行在test-face文件夹中的批量测试，测试结果存于faceRec文件夹，识别错误结果存于faceRec_ERROR 最近的项目是在红外人脸图像上进行的，人脸不太清晰，如果是正常摄像头效果应该会更好运行结果python facerec_68point.py在单张上的测试结果：this_is_who.py在test-face文件夹中的批量测试结果：this_is_who_camera.py实时检测效果.py摄像头截图：项目地址 ：https://github.com/zj19941113/Face_Recognition_dlib","categories":[{"name":"深度相机","slug":"深度相机","permalink":"http://yoursite.com/categories/深度相机/"},{"name":"python/机器学习","slug":"python-机器学习","permalink":"http://yoursite.com/categories/python-机器学习/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"Dlib","slug":"Dlib","permalink":"http://yoursite.com/tags/Dlib/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"人脸识别","slug":"人脸识别","permalink":"http://yoursite.com/tags/人脸识别/"},{"name":"Opencv","slug":"Opencv","permalink":"http://yoursite.com/tags/Opencv/"}]},{"title":"人脸深度图活体检测_SVM（Ubuntu+opencv3）","slug":"4","date":"2018-11-19T12:57:19.000Z","updated":"2019-12-18T03:57:50.325Z","comments":true,"path":"2018/11/19/4/","link":"","permalink":"http://yoursite.com/2018/11/19/4/","excerpt":"环境Ubuntu ，opencv3 数据准备原始深度图（已标定过人脸位置） 百度云盘：https://pan.baidu.com/s/1Hi85o521oIGaAfDoavOXeA使用MATLAB进行数据采集与处理：","text":"环境Ubuntu ，opencv3 数据准备原始深度图（已标定过人脸位置） 百度云盘：https://pan.baidu.com/s/1Hi85o521oIGaAfDoavOXeA使用MATLAB进行数据采集与处理： 1、运行dataGet_MATLAB/position_process.m，进行深度图片的人脸位置的快速批量标定，鼠标框出人脸位置，自动生成同名包含位置信息的txt文件。（百度云盘中已包含人脸位置信息，可跳过此步） 12345678910111213141516171819clcclearRAW_PATH = '/home/zhoujie/liveness detection/zjraw/face/';file =dir([RAW_PATH ,'*.raw']);for num=1:length(file)f1 = fopen([RAW_PATH,file(num).name], 'r');data0 = fread(f1, 'uint16');fclose(f1);img1 = reshape(data0, 400, 345);dep_img = img1';imshow(dep_img,[350,800]); mouse=imrect; pos=getPosition(mouse)% x1 y1 w h pos=round(pos);txtname = strrep(file(num).name,'.raw','.txt');fp=fopen([RAW_PATH,txtname],'a');fprintf(fp,'%i %i %i %i\\n',pos); fclose(fp);end 2、运行dataGet_MATLAB/faceGet_process.m，进行人脸深度图的批量处理 ，需提前新建/data/face与/data/non-face空文件夹用来存放生成的正负训练样本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657clcclearRAW_PATH = '/home/zhoujie/liveness detection/zjraw/face/';jpg_path = '/home/zhoujie/liveness detection/svm/data/face/';file =dir([RAW_PATH ,'*.raw']);for j=1:length(file) try f1 = fopen([RAW_PATH,file(j).name], 'r'); txtname = strrep(file(j).name,'.raw','.txt'); [par1,par2,par3,par4] = textread([RAW_PATH,txtname],'%d%d%d%d',1); data0 = fread(f1, 'uint16'); fclose(f1); img1 = reshape(data0, 400, 345); dep_img = img1'; try face = dep_img(par2 :par2 +par4-2,par1 :par1 + par3-2); catch if par2 +par4-2 &gt;345 face_height = 345; else face_height = par2 +par4-2; end if par1 +par3-2 &gt;400 face_weight = 400; else face_weight = par1 +par3-2; end face = dep_img(par2 :face_height,par1 :face_weight); end [m,n]=size(face); faceData = reshape(face, 1, m*n); faceData(find(faceData==0))=[]; able = 0;total = 0; for i =1:1000 num = randperm(length(faceData),1); facePlane = faceData(num); distance = abs([-1,faceData(num)]*[faceData;ones(1,length(faceData))]); total=sum(distance&lt;30); if total&gt;able able=total; bestfacePlane=facePlane; end end xmax = bestfacePlane+50; xmin = bestfacePlane-50; face(find(face &gt; xmax ))=xmax; face(find(face &lt; xmin ))=xmin; ymax=255;ymin=0; OutImg = round((ymax-ymin)*(face-xmin)/(xmax-xmin) + ymin); %归一化并取整 Outface=uint8(OutImg); Outface = imresize(Outface, [40 40]); jpgname = [jpg_path,num2str(j+538),'.jpg']; imwrite(Outface,jpgname); catch disp(file(j).name) endend 新建文件夹data/train_image/1、data/train_image/0、data/test_image/1、data/test_image/0data/face文件夹中的五分之四复制到data/train_image/1，剩下的复制到data/test_image/1data/non-face文件夹中的五分之四复制到data/train_image/0，剩下的复制到data/test_image/0 模型训练123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt; #include &lt;string.h&gt;#include&lt;time.h&gt;#include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/ml/ml.hpp&gt; #include &lt;dirent.h&gt;using namespace std; using namespace cv;using namespace cv::ml;void getFiles( string path, vector&lt;string&gt;&amp; files); void get_num(int num, Mat&amp; trainingImages, vector&lt;int&gt;&amp; trainingLabels); int main() &#123; //获取训练数据 Mat classes; Mat trainingData; Mat trainingImages; vector&lt;int&gt; trainingLabels; get_num(0, trainingImages, trainingLabels); get_num(1, trainingImages, trainingLabels); Mat(trainingImages).copyTo(trainingData); trainingData.convertTo(trainingData, CV_32FC1); Mat(trainingLabels).copyTo(classes); //配置SVM训练器参数 Ptr&lt;SVM&gt; svm = SVM::create(); svm-&gt;setType(SVM::C_SVC); svm-&gt;setKernel(SVM::LINEAR); Ptr&lt;TrainData&gt; tData =TrainData::create(trainingData, ROW_SAMPLE, classes); cout &lt;&lt; \"SVM: start train ...\" &lt;&lt; endl; clock_t start,finish; double totaltime; start=clock(); svm-&gt;trainAuto(tData); svm-&gt;save(\"svm.xml\"); cout&lt;&lt;\"SVM: TRAIN SUCCESS !\"&lt;&lt;endl; finish=clock(); totaltime=(double)(finish-start)/CLOCKS_PER_SEC; cout&lt;&lt;\"TRAIN TIME : \"&lt;&lt;totaltime&lt;&lt;\" S ！\"&lt;&lt;endl; // getchar(); return 0; &#125; void getFiles( string path, vector&lt;string&gt;&amp; files ) &#123; DIR *dir; struct dirent *ptr; if ((dir=opendir(path.c_str())) == NULL) &#123; perror(\"Open path error...\"); exit(1); &#125; while ((ptr=readdir(dir)) != NULL) &#123; if(strcmp(ptr-&gt;d_name,\".\")==0 || strcmp(ptr-&gt;d_name,\"..\")==0) ///current dir OR parrent dir continue; else if(ptr-&gt;d_type == 8) ///file &#123; files.push_back(ptr-&gt;d_name); &#125; else if(ptr-&gt;d_type == 10) ///link file &#123;continue; &#125; else if(ptr-&gt;d_type == 4) ///dir &#123; files.push_back(ptr-&gt;d_name); &#125; &#125; closedir(dir); sort(files.begin(), files.end());&#125;void get_num(int num, Mat&amp; trainingImages, vector&lt;int&gt;&amp; trainingLabels) &#123; string numpath = \"/home/zhoujie/liveness detection/svm/data/train_image/\"; char char_num[2]; sprintf(char_num,\"%d\",num); string str_num = char_num; string str = numpath + str_num; const char* filePath = str.data(); string base; vector&lt;string&gt; files; getFiles(filePath, files); int number = files.size(); for (int i = 0;i &lt; number;i++) &#123; // cout &lt;&lt; \"*************************** n = \" &lt;&lt; i &lt;&lt; \" ************************************ \"&lt;&lt; endl; base = str + \"/\" + files[i]; Mat SrcImage=imread(base.c_str()); SrcImage= SrcImage.reshape(1, 1); // cout &lt;&lt; SrcImage &lt;&lt; endl; trainingImages.push_back(SrcImage); trainingLabels.push_back(num); &#125; &#125; 运行 svm_train.cpp g++ svm_train.cpp `pkg-config –cflags –libs opencv` -o svm_train./ svm_train 生成的SVM模型存储在根目录的svm.xml中 模型测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/ml/ml.hpp&gt; #include &lt;string.h&gt;#include &lt;dirent.h&gt;using namespace std; using namespace cv; void getFiles( string path, vector&lt;string&gt;&amp; files ); int main() &#123; for (int num = 0; num &lt; 2; num ++) &#123; int response; int result = 0; float accuracy; string numpath = \"/home/zhoujie/liveness detection/svm/data/test_image/\"; char char_num[2]; sprintf(char_num,\"%d\",num); string str_num = char_num; string str = numpath + str_num; const char* filePath = str.data(); string base; vector&lt;string&gt; files; getFiles(filePath, files ); int number = files.size(); cout &lt;&lt;\"文件夹\"&lt;&lt; num &lt;&lt;\" 共有测试图片 \" &lt;&lt;number &lt;&lt;\" 张\"&lt;&lt; endl; Ptr&lt;ml::SVM&gt;svm = ml::SVM::load(\"svm.xml\"); for (int i = 0;i &lt; number;i++) &#123; base = str + \"/\" + files[i]; Mat inMat = imread(base.c_str()); Mat p = inMat.reshape(1, 1); p.convertTo(p, CV_32FC1); response = (int)svm-&gt;predict(p); // 核心代码，将检测的图片的标签返回回来，结果保存在response中 // cout &lt;&lt; \"识别的数字为：\" &lt;&lt; response &lt;&lt; endl; if (response == num) &#123; result++; &#125; // else // &#123; // cout &lt;&lt; base.c_str() &lt;&lt; \" ERROR ! \" &lt;&lt; endl; // &#125; &#125; accuracy = result*1.0/number; cout &lt;&lt; \"识别正确 \" &lt;&lt; result &lt;&lt;\" 张，准确率： \"&lt;&lt; accuracy &lt;&lt; endl; &#125; return 0; &#125; void getFiles( string path, vector&lt;string&gt;&amp; files ) &#123; DIR *dir; struct dirent *ptr; if ((dir=opendir(path.c_str())) == NULL) &#123; perror(\"Open path error...\"); exit(1); &#125; while ((ptr=readdir(dir)) != NULL) &#123; if(strcmp(ptr-&gt;d_name,\".\")==0 || strcmp(ptr-&gt;d_name,\"..\")==0) ///current dir OR parrent dir continue; else if(ptr-&gt;d_type == 8) ///file &#123; files.push_back(ptr-&gt;d_name); &#125; else if(ptr-&gt;d_type == 10) ///link file &#123; continue; &#125; else if(ptr-&gt;d_type == 4) ///dir &#123; files.push_back(ptr-&gt;d_name); &#125; &#125; closedir(dir); sort(files.begin(), files.end());&#125; 运行 svm_test.cpp g++ svm_test.cpp `pkg-config –cflags –libs opencv` -o svm_test./ svm_test 运行结果项目地址 ：https://github.com/zj19941113/FaceLivenessDetection_SVM","categories":[{"name":"深度相机","slug":"深度相机","permalink":"http://yoursite.com/categories/深度相机/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"python/机器学习","slug":"python-机器学习","permalink":"http://yoursite.com/categories/python-机器学习/"}],"tags":[{"name":"活体检测","slug":"活体检测","permalink":"http://yoursite.com/tags/活体检测/"},{"name":"近红外人脸定位","slug":"近红外人脸定位","permalink":"http://yoursite.com/tags/近红外人脸定位/"},{"name":"SVM","slug":"SVM","permalink":"http://yoursite.com/tags/SVM/"}]},{"title":"C++ 时间类型及相互转换详解 time_t与tm","slug":"3","date":"2018-10-25T03:18:28.000Z","updated":"2019-12-18T03:56:46.186Z","comments":true,"path":"2018/10/25/3/","link":"","permalink":"http://yoursite.com/2018/10/25/3/","excerpt":"时间常见的有两种存储方式:time_t :整数类型 用来存储从1970年到现在经过了多少秒tm :结构类型 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：","text":"时间常见的有两种存储方式:time_t :整数类型 用来存储从1970年到现在经过了多少秒tm :结构类型 把日期和时间以 C 结构的形式保存，tm 结构的定义如下： struct tm { int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时} 12345678#include &lt;time.h&gt;#include &lt;stdio.h&gt; int main() &#123; time_t timep; time(&amp;timep); /*获取time_t类型的当前时间*/ printf(\"%s\", asctime(gmtime(&amp;timep))); return 0; &#125; 输出为UTC时间： Thu Oct 25 01:49:20 2018 用gmtime将time_t类型的时间转换为struct tm类型的时间，按没有经过时区转换的UTC时间，然后再用asctime转换为我们常见的格式 Thu Oct 25 01:49:20 2018 修改时间输出格式： 123456789101112131415#include &lt;stdio.h&gt; #include &lt;time.h&gt;int main()&#123; char *wday[] = &#123;\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"&#125;; time_t timep; struct tm *p; time(&amp;timep); /*获得time_t结构的时间，UTC时间*/ p = localtime(&amp;timep); /*转换为struct tm结构的本地时间*/ printf(\"%d/%d/%d \", 1900 + p-&gt;tm_year, 1 + p-&gt;tm_mon, p-&gt;tm_mday); printf(\"%s %d:%d:%d\\n\", wday[p-&gt;tm_wday], p-&gt;tm_hour, p-&gt;tm_min, p-&gt;tm_sec); return 0;&#125; 输出为本地时间： 2018/10/25 Thu 09:49:20 常用时间函数：time_t time(time_t* t);//取得从1970年1月1日至今的秒数 char *asctime(const struct tm* timeptr);//将结构中的信息转换为真实世界的时间，以字符串的形式显示 char *ctime(const time_t* timep);//将timep转换为真是世界的时间，以字符串显示 struct tm* gmtime(const time_t* timep);//将time_t表示的时间转换为没有经过时区转换的UTC时间，是一个struct tm结构指针 struct tm* localtime(const time_t* timep);//和gmtime类似，但是它是经过时区转换的时间 time_t mktime(struct tm* timeptr);//将struct tm 结构的时间转换为从1970年至今的秒数 C语言中，#include &lt; time.h &gt; time_t timep;time(&amp;timep); /* 获取 time_t 类型的当前时间 */ C++中，#include &lt; ctime &gt; time_t now = time(0); // 基于当前系统的当前日期/时间 转换关系如下图：","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"C++ 近红外人脸定位与深度图人脸活体检测（.raw深度图像）","slug":"2","date":"2018-10-22T03:35:07.000Z","updated":"2019-12-18T03:56:22.534Z","comments":true,"path":"2018/10/22/2/","link":"","permalink":"http://yoursite.com/2018/10/22/2/","excerpt":"通过深度相机的红外图进行人脸位置定位，传给深度图进行活体检测注：利用rgb传来的位置对应到深度图上偏差过大，直接利用深度相机产生的红外图像进行人脸位置的确定更加精准。","text":"通过深度相机的红外图进行人脸位置定位，传给深度图进行活体检测注：利用rgb传来的位置对应到深度图上偏差过大，直接利用深度相机产生的红外图像进行人脸位置的确定更加精准。 运行dlib_test.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;dlib/image_processing/frontal_face_detector.h&gt;#include &lt;dlib/gui_widgets.h&gt;#include &lt;dlib/image_io.h&gt;#include &lt;iostream&gt;#include &lt;time.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdlib.h&gt;using namespace dlib;using namespace std;/* 函数声明 */int *face_location(char *imgFile);bool liveness_detection(char *DeepFile, int rec_face[4]); const int IMG_HEIGHT = 720;const int IMG_WIDTH = 1280;int main()&#123; char *imgFile = \"/home/zhoujie/cProject/dlib_test/0001_IR_frontface.jpg\"; int *rec_face; /* 调用函数得到人脸位置 */ // Eg:rec_face = &#123;157 ,66 ,172 ,198 &#125;, 行取66：66+198,列取157：157+172 rec_face = face_location(imgFile); //深度图与红外图是水平翻转的 rec_face[0] = IMG_WIDTH - rec_face[0] -rec_face[2]; cout &lt;&lt; rec_face[0] &lt;&lt; endl; cout &lt;&lt; rec_face[1] &lt;&lt; endl; cout &lt;&lt; rec_face[2] &lt;&lt; endl; cout &lt;&lt; rec_face[3] &lt;&lt; endl; char *DeepFile = \"/home/zhoujie/cProject/dlib_test/raw_0001_frontface.raw\"; bool IS_FACE; /* 调用函数判断是否为活体 */ IS_FACE = liveness_detection( DeepFile, rec_face); printf(\"RESULT : %d\\n\", IS_FACE); delete rec_face;&#125;/* 函数 输出人脸位置 */int *face_location(char* imgFile)&#123; int *rec_face = new int[4]; frontal_face_detector detector = get_frontal_face_detector(); cout &lt;&lt; \"processing image \" &lt;&lt; imgFile &lt;&lt; endl; clock_t start,finish; double totaltime; start=clock(); array2d&lt;unsigned char&gt; img; load_image(img, imgFile); std::vector&lt;rectangle&gt; dets = detector(img); cout &lt;&lt; \"Number of faces detected: \" &lt;&lt; dets.size() &lt;&lt; endl; rec_face[0] = dets[0].left(); rec_face[1] = dets[0].top(); rec_face[2] = dets[0].right() - dets[0].left() + 1; rec_face[3] = dets[0].bottom() - dets[0].top() + 1; finish=clock(); totaltime=(double)(finish-start)/CLOCKS_PER_SEC; cout&lt;&lt;\"\\n此程序的运行时间为\"&lt;&lt;totaltime&lt;&lt;\"秒！\"&lt;&lt;endl; // delete rec_face; return rec_face;&#125;/* 函数判断是否为活体 */bool liveness_detection(char *DeepFile, int rec_face[4])&#123; const int ITER = 10000; // 随机取点次数 const float PLANE_OR_NOT = 0.1; // 判断是否为平面的分界线 const int SIGMA = 1; typedef unsigned short UNIT16; // 从.raw读取二进制16位数据到MatDATA UNIT16 MatDATA[IMG_HEIGHT*IMG_WIDTH]; FILE *fp = NULL; fp = fopen( DeepFile, \"rb\" ); fread(MatDATA,sizeof(UNIT16),IMG_HEIGHT*IMG_WIDTH,fp); fclose(fp); int n = 0; int i,j; int COL = rec_face[0],ROW = rec_face[1],FACE_WIDTH = rec_face[2],FACE_HEIGHT = rec_face[3]; //位置信息 // txt :157 66 172 198 , 取行66：66+198,列取157：157+172 int faceno0_num = FACE_HEIGHT*FACE_WIDTH -1; int FaceDATA[3][160000]; n = 0; for(i = 1;i&lt; FACE_HEIGHT+1;i++) &#123; for(j= 1;j&lt; FACE_WIDTH+1;j++) &#123; if (MatDATA[IMG_WIDTH*(ROW+i-2)+COL+j-2] == 0) &#123; faceno0_num -= 1; // 非零深度点个数为 faceno0_num+1 continue; &#125; FaceDATA[1][n] = i; FaceDATA[0][n] = j; FaceDATA[2][n] = MatDATA[IMG_WIDTH*(ROW+i-2)+COL+j-2]; n += 1; &#125; &#125; int pretotal = 0; // 符合拟合模型的数据的个数 int x[3],y[3],z[3]; // 随机取三个点 srand((unsigned)time(NULL)); float a,b,c; // 拟合平面方程 z=ax+by+c // float besta,bestb,bestc; // 最佳参数 int rand_num[3]; float check,distance; int total = 0; for(i = 0; i &lt; ITER; i++) &#123; do&#123; rand_num[0] = std::rand()%faceno0_num; rand_num[1] = std::rand()%faceno0_num; rand_num[2] = std::rand()%faceno0_num; &#125;while(rand_num[0] == rand_num[1] || rand_num[0] == rand_num[2] || rand_num[1] == rand_num[2]); for(n = 0; n &lt; 3; n++ ) &#123; x[n] = FaceDATA[0][rand_num[n]]; y[n] = FaceDATA[1][rand_num[n]]; z[n] = FaceDATA[2][rand_num[n]]; // printf(\"%d,%d,%d,%d\\n\", x[n],y[n],z[n],n); &#125; check = (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]); if ( check == 0) // 防止提示浮点数例外 (核心已转储) &#123; i -= 1; continue; &#125; a = ( (z[0]-z[1])*(y[0]-y[2]) - (z[0]-z[2])*(y[0]-y[1]) )/( (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]) ); if (y[0] == y[2]) // 防止提示浮点数例外 (核心已转储) &#123; i -= 1; continue; &#125; b = ((z[0] - z[2]) - a * (x[0] - x[2]))/(y[0]-y[2]); c = z[0]- a * x[0] - b * y[0]; // printf(\"%f,%f,%f\\n\",a,b,c); total = 0; for(n = 0; n &lt; faceno0_num +1 ; n++ ) &#123; distance = fabs(a*FaceDATA[0][n] + b*FaceDATA[1][n] - 1*FaceDATA[2][n] + c*1); if (distance &lt; SIGMA) &#123; total +=1; &#125; &#125; // printf(\"%d,%f,%d\\n\",i,distance,total); if (total &gt; pretotal) // 找到符合拟合平面数据最多的拟合平面 &#123; pretotal=total; &#125; &#125; float pretotal_ary = pretotal *1.0/ faceno0_num ; printf(\"%d,%f\\n\", pretotal,pretotal_ary); bool IS_FACE; if (pretotal_ary &lt; PLANE_OR_NOT) &#123; IS_FACE = true; &#125; else &#123; IS_FACE = false; &#125; return IS_FACE;&#125; Ubuntu下编译Dlib库参考这里 https://blog.csdn.net/ffcjjhv/article/details/84660869修改CMakeLists.txt相应路径cmake .make./dlib_test 运行结果项目地址：https://github.com/zj19941113/Face-Liveness_detection 活检部分原理Func_liveness_detection.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dirent.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;#include &lt;stdbool.h&gt;const int IMG_HEIGHT = 345;const int IMG_WIDTH = 400;const int ITER = 10000; // 随机取点次数const float PLANE_OR_NOT = 0.1; // 判断是否为平面的分界线typedef unsigned short UNIT16;int readFileList(char *basePath)&#123; DIR *dir; struct dirent *ptr; char base[8]; char title[4]; char *p=\".raw\"; //需要的子串; char *p2=\".txt\"; char *padd=\"/\"; int len; char Deepfile_raw[100]; char Deepfile_txt[100]; UNIT16 MatDATA[IMG_HEIGHT*IMG_WIDTH]; FILE *fp = NULL; int DeepDATA[3][IMG_HEIGHT*IMG_WIDTH]; int length; int n; int i,j; FILE *fp2 = NULL; char buf[20]; char *ptr2; int rec_face[4]; int COL ,ROW ,FACE_WIDTH ,FACE_HEIGHT ; int FaceDATA[3][40000]; int faceno0_num ; int sigma = 1; int pretotal; // 符合拟合模型的数据的个数 int x[3],y[3],z[3]; // 随机取三个点 float a,b,c; // 拟合平面方程 z=ax+by+c // float besta,bestb,bestc; // 最佳参数 int rand_num[3]; float check,distance; int total; if ((dir=opendir(basePath)) == NULL) &#123; perror(\"Open dir error...\"); exit(1); &#125; while ((ptr=readdir(dir)) != NULL) &#123; strcpy(base, ptr-&gt;d_name); if(strstr(base,p)) &#123; len = strlen(base); memset(title, '\\0', sizeof(title)); strncpy(title, base, len -4); strcpy(Deepfile_raw, basePath); strcat(Deepfile_raw, padd); strcat(Deepfile_raw, title); strcpy(Deepfile_txt, Deepfile_raw); strcat(Deepfile_raw, p); strcat(Deepfile_txt, p2); // printf(\"%s\\n\",Deepfile_raw); // printf(\"%s\\n\",Deepfile_txt); // 从.raw读取二进制16位数据到MatDATA fp = fopen( Deepfile_raw, \"rb\" ); fread(MatDATA,sizeof(UNIT16),IMG_HEIGHT*IMG_WIDTH,fp); fclose(fp); // length = sizeof(MatDATA) / sizeof(UNIT16); // printf(\"数组的长度为: %d\\n\",length); //length 应为IMG_HEIGHT*IMG_WIDTH n = 0; // DeepDATA三行分别为深度图行数，列数，深度信息 for(i=1;i&lt; IMG_HEIGHT+1 ;i++) &#123; for(j=1;j&lt; IMG_WIDTH+1 ;j++) &#123; DeepDATA[0][n] = i; DeepDATA[1][n] = j; DeepDATA[2][n] = MatDATA[n]; n += 1; &#125; &#125; // int test1 = 110194 ; // printf(\"%d,%d,%d\\n\",DeepDATA[0][test1],DeepDATA[1][test1],DeepDATA[2][test1]); // FaceDATA为深度图DeepDATA裁剪后且去除零深度信息后的人脸部分 n = 0; fp2 = fopen(Deepfile_txt, \"r\"); fgets(buf, 20, fp2); // printf(\"%s\\n\", buf ); ptr2 = strtok(buf, \" \"); for(n = 0; n &lt; 4; n++) &#123; rec_face[n] = atoi(ptr2); ptr2 = strtok(NULL, \" \"); &#125; fclose(fp2); COL = rec_face[0],ROW = rec_face[1],FACE_WIDTH = rec_face[2],FACE_HEIGHT = rec_face[3]; //位置信息 // txt :157 66 172 198 , 取行66：66+198,列取157：157+172 faceno0_num = FACE_HEIGHT*FACE_WIDTH -1; n = 0; for(i = 1;i&lt; FACE_HEIGHT+1;i++) &#123; for(j= 1;j&lt; FACE_WIDTH+1;j++) &#123; if (MatDATA[IMG_WIDTH*(ROW+i-2)+COL+j-2] == 0) &#123; faceno0_num -= 1; // 非零深度点个数为 faceno0_num+1 continue; &#125; FaceDATA[1][n] = i; FaceDATA[0][n] = j; FaceDATA[2][n] = MatDATA[IMG_WIDTH*(ROW+i-2)+COL+j-2]; n += 1; &#125; &#125; // int test = 6804; // printf(\"%d,%d,%d,%d\\n\",test,FaceDATA[0][test],FaceDATA[1][test],FaceDATA[2][test]); srand((unsigned)time(NULL)); pretotal = 0; total = 0; for(i = 0; i &lt; ITER; i++) &#123; do&#123; rand_num[0] = rand()%faceno0_num; rand_num[1] = rand()%faceno0_num; rand_num[2] = rand()%faceno0_num; &#125;while(rand_num[0] == rand_num[1] || rand_num[0] == rand_num[2] || rand_num[1] == rand_num[2]); for(n = 0; n &lt; 3; n++ ) &#123; x[n] = FaceDATA[0][rand_num[n]]; y[n] = FaceDATA[1][rand_num[n]]; z[n] = FaceDATA[2][rand_num[n]]; // printf(\"%d,%d,%d,%d\\n\", x[n],y[n],z[n],n); &#125; check = (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]); if ( check == 0) // 防止提示浮点数例外 (核心已转储) &#123; i -= 1; continue; &#125; a = ( (z[0]-z[1])*(y[0]-y[2]) - (z[0]-z[2])*(y[0]-y[1]) )*1.0/( (x[0]-x[1])*(y[0]-y[2]) - (x[0]-x[2])*(y[0]-y[1]) ); if (y[0] == y[2]) // 防止提示浮点数例外 (核心已转储) &#123; i -= 1; continue; &#125; b = ((z[0] - z[2]) - a * (x[0] - x[2]))*1.0/(y[0]-y[2]); c = z[0]- a * x[0] - b * y[0]; // printf(\"%f,%f,%f\\n\",a,b,c); total = 0; for(n = 0; n &lt; faceno0_num +1 ; n++ ) &#123; distance = fabs(a*FaceDATA[0][n] + b*FaceDATA[1][n] - 1*FaceDATA[2][n] + c*1); if (distance &lt; sigma) &#123; total +=1; &#125; &#125; // printf(\"%d,%f,%d\\n\",i,distance,total); if (total &gt; pretotal) // 找到符合拟合平面数据最多的拟合平面 &#123; pretotal=total; // besta = a; // bestb = b; // bestc = c; &#125; &#125; float pretotal_ary = pretotal *1.0/ faceno0_num ; printf(\"pretotal = %d,_ary = %f,\",pretotal,pretotal_ary); printf(\"%s\",base); bool IS_FACE; if (pretotal_ary&gt;PLANE_OR_NOT) &#123; IS_FACE = false; printf(\"不是人脸\\n\"); &#125; else &#123; IS_FACE = true; printf(\"是人脸\\n\"); &#125; &#125; &#125; closedir(dir);&#125;int main(void)&#123; DIR *dir; char *basePath = \"/home/zhoujie/liveness detection/raw文件/non-face\"; readFileList(basePath); return 0;&#125; github地址：https://github.com/zj19941113/Face-Liveness_detection上面这个项目使用的数据集标定的不太准，PLANE_OR_NOT参数选为 0.1 这个数据集是自己标定的，数量较少但是比较准确： https://pan.baidu.com/s/161xSbayGW7tKg0tKfTW1mw ，PLANE_OR_NOT参数选为 0.2 快速鼠标标定深度图人脸位置： https://blog.csdn.net/ffcjjhv/article/details/83270002","categories":[{"name":"深度相机","slug":"深度相机","permalink":"http://yoursite.com/categories/深度相机/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"活体检测","slug":"活体检测","permalink":"http://yoursite.com/tags/活体检测/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"近红外人脸定位","slug":"近红外人脸定位","permalink":"http://yoursite.com/tags/近红外人脸定位/"}]},{"title":"C++ warning!warning!warning!","slug":"9","date":"2018-10-22T03:28:26.000Z","updated":"2019-12-18T04:04:17.612Z","comments":true,"path":"2018/10/22/9/","link":"","permalink":"http://yoursite.com/2018/10/22/9/","excerpt":"1、warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings] char *imgFile = “data/IR_62_78_150_151.jpg”; 分析 ：char *背后的含义是：这个字符串，我要修改它。而传给函数的字面常量是没法被修改的。修正：把参数类型修改为const char *","text":"1、warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings] char *imgFile = “data/IR_62_78_150_151.jpg”; 分析 ：char *背后的含义是：这个字符串，我要修改它。而传给函数的字面常量是没法被修改的。修正：把参数类型修改为const char * const char \\*imgFile = &quot;data/IR_62_78_150_151.jpg&quot;; 2、warning: comparison between signed and unsigned integer expressions [-Wsign-compare]for (int j = 0; j &lt; shape.num_parts(); ++j) 分析：signed 和unsigned两种不同类型的比较，防止一个负的符号型的数据转化为无符号型时会产生一个很大的数据，signed 和unsigned数据的范围也不同。修正：使用size_t 类型。 for (std::size_t j = 0; j &lt; shape.num_parts(); ++j) 3、warning: unused variable ‘j’ [-Wunused-variable] int i,j;分析：代码写太长了，定义的j后面没用到。修正：删掉j。 int i; 4、warning: ignoring return value of ‘size_t fread(void, size_t, size_t, FILE)’, declared with attribute warn_unused_result [-Wunused-result] fread(MatDATA,sizeof(UNIT16),IMG_HEIGHT*IMG_WIDTH,fp);分析：使用fread(void*, size_t, size_t, FILE*)会返回一个size_t类型的值，假如命名为sizeRead，通过判断if (sizeRead != IMG_HEIGHT*IMG_WIDTH){printf(“error!\\n”);}可以知道是否读取成功。修正：取返回值。 1234size_t sizeRead = fread(MatDATA,sizeof(UNIT16),IMG_HEIGHT*IMG_WIDTH,fp);if (sizeRead != IMG_HEIGHT*IMG_WIDTH) &#123; printf(\"error!\\n\");&#125; 5、warning: control reaches end of non-void function [-Wreturn-type]} 分析：控制到达非void函数的结尾。本应带有返回值的函数到达结尾后可能并没有返回任何值。修正：根据定义的类型加上返回值。return 0; } 6、error: stray ‘\\240’ in program &amp;&amp; error: stray ‘\\302’ in program分析：源代码中含有一些隐藏的非ascii字符。修正：将程序中出错行前面的空格删除，重新插入空格或tab键，重新编译，错误消失","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Warning","slug":"Warning","permalink":"http://yoursite.com/tags/Warning/"}]},{"title":"matlab 深度图人脸活体检测（.raw深度图像）","slug":"1","date":"2018-10-22T03:28:26.000Z","updated":"2019-12-18T03:59:15.069Z","comments":true,"path":"2018/10/22/1/","link":"","permalink":"http://yoursite.com/2018/10/22/1/","excerpt":"github地址：https://github.com/zj19941113/Deep-Img-Liveness-Detection上面这个项目使用的数据集标定的不太准，PLANE_OR_NOT参数选为 0.1","text":"github地址：https://github.com/zj19941113/Deep-Img-Liveness-Detection上面这个项目使用的数据集标定的不太准，PLANE_OR_NOT参数选为 0.1 这个数据集是自己标定的，数量较少但是比较准确： https://pan.baidu.com/s/161xSbayGW7tKg0tKfTW1mw ，PLANE_OR_NOT参数选为 0.2 快速鼠标标定深度图人脸位置： https://blog.csdn.net/ffcjjhv/article/details/83270002 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556RAW_PATH = '/home/zhoujie/liveness detection/zjraw/non-face/';PLANE_OR_NOT = 0.2; %根据标定位置的准确程度修改阈值ITER = 10000; %10000次结果基本已经稳定，不用修改file =dir([RAW_PATH ,'*.raw']);for num=1:length(file)f1 = fopen([RAW_PATH,file(num).name], 'r');txtname = strrep(file(num).name,'.raw','.txt');[par1,par2,par3,par4] = textread([RAW_PATH,txtname],'%d%d%d%d',1);data0 = fread(f1, 'uint16');fclose(f1);img1 = reshape(data0, 400, 345);dep_img = img1';% dep_img(find(dep_img &gt; 600))= 0;% figure(1),imshow(dep_img,[400,580]); face = dep_img(par2 :par2 +par4,par1 :par1 + par3); % figure(2),imshow(face,[400,580]); %%%三维平面拟合[X Y]=meshgrid(1:size(face,2),1:size(face,1));zz=face(:);xx=X(:);yy=Y(:);data=[xx';yy';zz'];id = data(3,:) == 0;data(:,id) = [];number = size(data,2); % 总点数sigma = 1;pretotal=0; %符合拟合模型的数据的个数for i=1:ITER %%% 随机选择三个点 idx = randperm(number,3); sample = data(:,idx); %%%拟合直线方程 z=ax+by+c plane = zeros(1,3); x = sample(1,:); y = sample(2,:); z = sample(3,:); a = ((z(1)-z(2))*(y(1)-y(3)) - (z(1)-z(3))*(y(1)-y(2)))/((x(1)-x(2))*(y(1)-y(3)) - (x(1)-x(3))*(y(1)-y(2))); b = ((z(1) - z(3)) - a * (x(1) - x(3)))/(y(1)-y(3)); c = z(1) - a * x(1) - b * y(1); plane = [a b -1 c]; mask=abs(plane*[data; ones(1,size(data,2))]); %求每个数据到拟合平面的距离 total=sum(mask&lt;sigma); %计算数据距离平面小于一定阈值的数据的个数 if total&gt;pretotal %找到符合拟合平面数据最多的拟合平面 pretotal=total;% bestplane=plane; %找到最好的拟合平面 end endpretotal_ary = pretotal/number;% potable(num) = pretotal_ary;if(pretotal_ary&gt;PLANE_OR_NOT) descrip = '不是人脸';elsedescrip = '是人脸'; enddisp(['pretotal=',num2str(pretotal),',','_ary=',num2str(pretotal_ary),',',file(num).name,descrip]);end","categories":[{"name":"MATLAB","slug":"MATLAB","permalink":"http://yoursite.com/categories/MATLAB/"},{"name":"深度相机","slug":"深度相机","permalink":"http://yoursite.com/categories/深度相机/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"},{"name":"活体检测","slug":"活体检测","permalink":"http://yoursite.com/tags/活体检测/"}]}]}