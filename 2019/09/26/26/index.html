<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/title.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/title.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/title.jpg?v=5.1.4">






  <meta name="keywords" content="C++,后台开发,">





  <link rel="alternate" href="/atom.xml" title="ZhouJie's Blog" type="application/atom+xml">






<meta name="description" content="相关：C++后台开发知识总结（一）C++基础C++后台开发知识总结（二）数据库C++后台开发知识总结（三）计算机网络C++后台开发知识总结（四）操作系统/Linux 内核 extern “C”的作用extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。">
<meta name="keywords" content="C++,后台开发">
<meta property="og:type" content="article">
<meta property="og:title" content="C++后台开发知识总结（一）C++基础">
<meta property="og:url" content="http://yoursite.com/2019/09/26/26/index.html">
<meta property="og:site_name" content="ZhouJie&#39;s Blog">
<meta property="og:description" content="相关：C++后台开发知识总结（一）C++基础C++后台开发知识总结（二）数据库C++后台开发知识总结（三）计算机网络C++后台开发知识总结（四）操作系统/Linux 内核 extern “C”的作用extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190926135120411.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190926144910944.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190926144917548.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019092614511520.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190926154738160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZmY2pqaHY=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190926162534580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZmY2pqaHY=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190926124913807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZmY2pqaHY=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190926124926125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZmY2pqaHY=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190926124936714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZmY2pqaHY=,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2019-12-18T04:20:53.805Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++后台开发知识总结（一）C++基础">
<meta name="twitter:description" content="相关：C++后台开发知识总结（一）C++基础C++后台开发知识总结（二）数据库C++后台开发知识总结（三）计算机网络C++后台开发知识总结（四）操作系统/Linux 内核 extern “C”的作用extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190926135120411.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/26/26/">





  <title>C++后台开发知识总结（一）C++基础 | ZhouJie's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8adfb1a1130406391d41d87803ca8802";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/zj19941113/zj19941113.github.io" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhouJie's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">向阳而生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhouJie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zj.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhouJie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++后台开发知识总结（一）C++基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-26T19:13:52+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后台开发/" itemprop="url" rel="index">
                    <span itemprop="name">后台开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/09/26/26/" class="leancloud_visitors" data-flag-title="C++后台开发知识总结（一）C++基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>相关：<br><a href="https://blog.csdn.net/ffcjjhv/article/details/101433113" target="_blank" rel="noopener">C++后台开发知识总结（一）C++基础</a><br><a href="https://blog.csdn.net/ffcjjhv/article/details/101481241" target="_blank" rel="noopener">C++后台开发知识总结（二）数据库</a><br><a href="https://blog.csdn.net/ffcjjhv/article/details/101486572" target="_blank" rel="noopener">C++后台开发知识总结（三）计算机网络</a><br><a href="https://blog.csdn.net/ffcjjhv/article/details/101546677" target="_blank" rel="noopener">C++后台开发知识总结（四）操作系统/Linux 内核</a></p>
<h1 id="extern-“C”的作用"><a href="#extern-“C”的作用" class="headerlink" title="extern “C”的作用"></a>extern “C”的作用</h1><p>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码<strong>按C语言（而不是C++）的方式进行编译</strong>。</p>
<a id="more"></a>

<p>原因是：C++支持函数重载，因此编译器编译函数的过程中会将<strong>函数的参数类型</strong>也加到编译后的代码中，而不仅仅是函数名；<br>而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __INCvxWorksh <span class="comment">/*防止该头文件被重复引用*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INCvxWorksh</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus  <span class="comment">//告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> <span class="comment">/*…*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*end of __INCvxWorksh*/</span></span></span><br></pre></td></tr></table></figure>

<h1 id="C-和C的区别"><a href="#C-和C的区别" class="headerlink" title="C++和C的区别"></a>C++和C的区别</h1><p>设计思想上：<br>C++是<strong>面向对象</strong>的语言，而C是<strong>面向过程</strong>的结构化编程语言<br>语法上：<br>C++具有<strong>封装、继承和多态</strong>三种特性<br>C++相比C，增加多许多类型安全的功能，比如<strong>强制类型转换</strong><br>C++支持范式编程，比如<strong>模板类</strong>、函数模板等</p>
<h1 id="C-C-const关键字"><a href="#C-C-const关键字" class="headerlink" title="C/C++ const关键字"></a>C/C++ const关键字</h1><p>（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行<strong>初始化</strong>，因为以后就没有机会再去改变它了；<br>（2）对<strong>指针</strong>来说，可以指定指针本身为const，也可以指定<strong>指针所指的数据</strong>为const，或二者同时指定为const；<br>（3）在一个函数声明中，const可以<strong>修饰形参</strong>，表明它是一个输入参数，在函数内部不能改变其值；可以阻止用户修改<strong>返回值</strong>。返回值也要相应的付给一个常量或常指针。<br>（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量。</p>
<h1 id="C-C-static关键字"><a href="#C-C-static关键字" class="headerlink" title="C/C++ static关键字"></a>C/C++ static关键字</h1><p>1.全局静态变量<br>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.<br>静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为0<br>作用域：全局静态变量在声明他的<strong>文件之外是不可见</strong>的，准确地说是从定义之处开始，到文件结尾。<br>2.局部静态变量<br>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。<br>内存中的位置：静态存储区<br>初始化：未经初始化的全局静态变量会被自动初始化为0<br>作用域：作用域<strong>仍为局部作用域</strong>，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并<strong>没有销毁</strong>，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>; <span class="comment">//在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1</span></span><br><span class="line">    <span class="keyword">return</span> count--; <span class="comment">//以后每次进入该函数，a就不会被再次初始化了，仅进行自减1的操作   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.静态函数<br>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，<strong>不能被其他文件</strong>所用。<br>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的<strong>同名函数引起冲突</strong>；
warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；<br>4.类的静态成员及静态成员函数<br>对象与对象之间的成员变量是相互独立的。要想共用数据，则需要使用静态成员和静态方法。<br>只要在类中声明静态成员变量，即使不定义对象，也可以为静态成员变量分配空间，进而可以使用静态成员变量。<br>静态成员变量是在程序<strong>编译时</strong>分配空间，而在程序结束时释放空间。<br>初始化静态成员变量要在<strong>类的外面</strong>进行。不能用参数初始化表，对静态成员变量进行初始化。</p>
<p>在静态成员函数的实现中<strong>不能直接引用</strong>类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。<br>可以通过类名/对象名直接访问类的公有静态成员函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_value;   <span class="comment">//定义私有类的静态成员变量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span>   <span class="comment">//定义类的静态成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> test::m_value = <span class="number">0</span>;    <span class="comment">//类的静态成员变量需要在类外分配内存空间</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test t1;</span><br><span class="line">    test t2;</span><br><span class="line">    test t3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过类名直接调用公有静态成员函数，获取对象个数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test::m_value2 = "</span> &lt;&lt; test::getValue() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="comment">//通过对象名调用静态成员函数获取对象个数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t3.getValue() = "</span> &lt;&lt; t3.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-C-volatile关键字"><a href="#C-C-volatile关键字" class="headerlink" title="C/C++ volatile关键字"></a>C/C++ volatile关键字</h1><p>volatile是“易变的”、“不稳定”的意思。volatile是C的一个较为少用的关键字，它用来解决变量在“共享”环境下容易出现读取错误的问题<br>变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确的处理，凡是申明为volatile的变量，每次都是从内存中读取变量的值，而不是在某些情况下直接从寄存器中取值。（有可能被其他的程序（如中断程序、另外的线程等）所修改）</p>
<p>应用场景：<br>（1）并行设备的硬件寄存器（如状态寄存器）反复读操作，编译器在优化后，也许读操作只做了一次<br>（2）一个中断服务子程序中访问到的变量<br>（3）多线程应用中被多个任务共享的变量<br>当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入CPU寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。</p>
<p>（1）一个参数既可以是const还可以是volatile吗？为什么？<br>是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。<br>（2）一个指针可以是volatile吗？为什么？<br>是的。尽管这并不很常见。一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时<br>（3）下面的函数有什么错误？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> *ptr * *ptr; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确的代码如下：</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    a = *ptr; </span><br><span class="line">    <span class="keyword">return</span> a * a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>volatile能够避免编译器优化带来的错误，但使用volatile的同时，也需要注意频繁地使用volatile很可能会增加代码尺寸和降低性能，因此要合理的使用volatile。</p>
<h1 id="C-C-restrict关键字"><a href="#C-C-restrict关键字" class="headerlink" title="C/C++ restrict关键字"></a>C/C++ restrict关键字</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> * b=&amp;a; <span class="comment">//警告：初始化丢弃了指针目标类型的限定</span></span><br></pre></td></tr></table></figure>

<p>b失去了对目标对象的const的限定，并且可以通过指针b更改它们共同指向的空间。<br>const是无法保证某个对象不被更改的，restrict关键字是修饰指针的，对该指针指向的空间的访问，<strong>只能从这个指针</strong>进入。</p>
<h1 id="什么是右值引用，跟左值又有什么区别？"><a href="#什么是右值引用，跟左值又有什么区别？" class="headerlink" title="什么是右值引用，跟左值又有什么区别？"></a>什么是右值引用，跟左值又有什么区别？</h1><p>主要目的有两个方面：<br>1.消除两个对象交互时<strong>不必要的对象拷贝</strong>，节省运算存储资源，提高效率。<br>2.能够更简洁明确地定义泛型函数。<br>左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。<br>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的<strong>临时对象</strong>。
右值引用和左值引用的区别：<br>（1）左值可以寻址，而右值不可以。<br>（2）左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。<br>（3）左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = getVar();</span><br></pre></td></tr></table></figure>

<p>从getVar()函数获取一个整形值，然而，这行代码会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>i 是左值，0 是字面量，就是右值。在上面的代码中，i 可以被引用，0 就不可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; k = getVar();</span><br></pre></td></tr></table></figure>

<p>对右值的引用就是右值引用，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。</p>
<h1 id="C-11有哪些新特性"><a href="#C-11有哪些新特性" class="headerlink" title="C++11有哪些新特性"></a>C++11有哪些新特性</h1><p><strong>1.auto关键字</strong><br>编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导<br><strong>2.nullptr关键字</strong><br>nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。<br><strong>3.智能指针</strong><br>C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。<br><strong>4.初始化列表</strong><br>使用初始化列表来对类进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      Line(<span class="keyword">double</span> len);  </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, length = "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Line::Line( <span class="keyword">double</span> len): length(len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, length = "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.右值引用</strong><br>基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率<br><strong>6.lambda</strong><br>Lambda表达式定义一个匿名函数，并且可以捕获一定范围内的变量<br><strong>[捕获列表] (参数列表) mutable或exception声明 -&gt;返回值类型 {函数体}</strong><br>[捕获列表]，捕获上下文变量以供lambda使用。标识一个Lambda的开始，这部分必须存在，不能省略。<br>(参数列表)，与普通函数的参数列表一致，如果不需要传递参数，则可以连通括号一起省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。<br>mutable是修饰符，默认情况下lambda函数总是一个const函数，Mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略。<br>-&gt;返回值类型, 当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。<br>{函数体}，内容与普通函数一样，除了可以使用参数之外，还可以使用所捕获的变量。<br>Lambda表达式与普通函数最大的区别就是其可以通过捕获列表访问一些上下文中的数据。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vctTemp;</span><br><span class="line">vctTemp.push_back(<span class="number">1</span>);</span><br><span class="line">vctTemp.push_back(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// 无函数对象参数，输出：1 2</span></span><br><span class="line">  for_each(vctTemp.begin(), vctTemp.end(), [](<span class="keyword">int</span> v)&#123; <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// 以值方式传递作用域内所有可见的局部变量（包括this），输出：11 12</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  for_each(vctTemp.begin(), vctTemp.end(), [=](<span class="keyword">int</span> v)&#123; <span class="built_in">cout</span> &lt;&lt; v+a &lt;&lt; <span class="built_in">endl</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// 以引用方式传递作用域内所有可见的局部变量（包括this），输出：11 13 12</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  for_each(vctTemp.begin(), vctTemp.end(), [&amp;](<span class="keyword">int</span> v)<span class="keyword">mutable</span>&#123; <span class="built_in">cout</span> &lt;&lt; v+a &lt;&lt; <span class="built_in">endl</span>; a++; &#125;);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// 以值方式传递局部变量a，输出：11 13 10</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  for_each(vctTemp.begin(), vctTemp.end(), [a](<span class="keyword">int</span> v)<span class="keyword">mutable</span>&#123; <span class="built_in">cout</span> &lt;&lt; v+a &lt;&lt; <span class="built_in">endl</span>; a++; &#125;);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// 以引用方式传递局部变量a，输出：11 13 12</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  for_each(vctTemp.begin(), vctTemp.end(), [&amp;a](<span class="keyword">int</span> v)&#123; <span class="built_in">cout</span> &lt;&lt; v+a &lt;&lt; <span class="built_in">endl</span>; a++; &#125;);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// 传递this，输出：21 22</span></span><br><span class="line">  for_each(vctTemp.begin(), vctTemp.end(), [<span class="keyword">this</span>](<span class="keyword">int</span> v)&#123; <span class="built_in">cout</span> &lt;&lt; v+m_nData &lt;&lt; <span class="built_in">endl</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// 除b按引用传递外，其他均按值传递，输出：11 12 17</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">15</span>;</span><br><span class="line">  for_each(vctTemp.begin(), vctTemp.end(), [=, &amp;b](<span class="keyword">int</span> v)&#123; <span class="built_in">cout</span> &lt;&lt; v+a &lt;&lt; <span class="built_in">endl</span>; b++; &#125;);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// 操作符重载函数参数按引用传递，输出：2 3</span></span><br><span class="line">  for_each(vctTemp.begin(), vctTemp.end(), [](<span class="keyword">int</span> &amp;v)&#123; v++; &#125;);</span><br><span class="line">  for_each(vctTemp.begin(), vctTemp.end(), [](<span class="keyword">int</span> v)&#123; <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// 空的Lambda表达式</span></span><br><span class="line">  []()&#123;&#125;();</span><br><span class="line">  []&#123;&#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>7.可变参数模板</strong><br>C++11的可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为：在class或typename后面带上省略号。<br>通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归终止函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(T end)</span><span class="comment">//递归到最后一次，调用单参数函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"parameter "</span> &lt;&lt; end &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//展开函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> ...<span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">myprint</span>(<span class="title">T</span> <span class="title">head</span>, <span class="title">Args</span>... <span class="title">rest</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"parameter "</span> &lt;&lt; head &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  myprint(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  myprint(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.atomic原子操作用于多线程资源互斥操作<br>9.新增STL容器array以及tuple</p>
<h1 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h1><p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而<strong>防止内存泄漏</strong>。
C++ 11中最常用的智能指针类型为shared_ptr,它采用<strong>引用计数</strong>的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。<br>对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。<br>C++里面的四个智能指针: <strong>auto_ptr</strong>, <strong>shared_ptr</strong>, <strong>weak_ptr</strong>, <strong>unique_ptr</strong> 其中后三个是c++11支持，并且第一个已经被11弃用。#include&lt;memory&gt;<br>1.<strong>unique_ptr</strong>（替换auto_ptr）<br>保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"auto"</span>));   <span class="comment">//#4</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4；                       <span class="comment">//#5</span></span><br><span class="line">p4 = p3;<span class="comment">//此时会报错！！</span></span><br></pre></td></tr></table></figure>

<p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。<br>当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu1(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>

<p>其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。<br>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，能够将一个unique_ptr赋给另一个。</p>
<ol start="2">
<li><strong>shared_ptr</strong><br>多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。<br>shared_ptr 是为了解决 auto_ptr 在对象所有权上的<strong>局限性</strong>(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。<br>成员函数：</li>
</ol>
<p><strong>use_count 返回引用计数的个数</strong><br>unique 返回是否是独占所有权( use_count 为 1)<br>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)<br>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少<br>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></p>
<ol start="3">
<li><strong>weak_ptr</strong><br>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr.<br>weak_ptr只是提供了对管理对象的一个<strong>访问手段</strong>。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构<strong>不会引起引用记数的增加或减少</strong>。weak_ptr是用来解决shared_ptr相互引用时的<strong>死锁</strong>问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">  ~A()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">  ~B()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line">  <span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">  pb-&gt;pa_ = pa;</span><br><span class="line">  pa-&gt;pb_ = pb;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//2</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  fun();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下<img src="https://img-blog.csdnimg.cn/20190926135120411.png" alt="在这里插入图片描述"> ，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。<br>注意的是我们<strong>不能通过weak_ptr直接访问对象的方法</strong>，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); 因为pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span> p = pa-&gt;pb_.lock();</span><br><span class="line">p-&gt;print();</span><br></pre></td></tr></table></figure>

<h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><p>隐式转换指的是<strong>不需要用户干预</strong>，编译器私下进行的类型转换行为。<br>首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换。如： int 到 double</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//混合类型的算术运算表达式中</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">4.5</span>;</span><br><span class="line"><span class="keyword">double</span> c = a + b;     <span class="comment">// a 将被自动转换为 double 类型，再加法。</span></span><br><span class="line"><span class="comment">//不同类型的赋值操作中//</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="literal">true</span>;         <span class="comment">// bool 类型转换为 int 类型</span></span><br><span class="line"><span class="keyword">int</span> *ptr = null;      <span class="comment">// null 被转换为 int * 类型</span></span><br><span class="line"><span class="comment">//函数参数传值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;&#125;;</span><br><span class="line">func(<span class="number">1</span>);               <span class="comment">// 1 被隐式的转换为 double 类型1.0</span></span><br><span class="line"><span class="comment">//函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;      <span class="comment">// 运算的结果会被隐式的转换为 double 类型再返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，对于只存在<strong>单个参数的构造函数</strong>的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOK <span class="title">A</span><span class="params">(<span class="string">"A-A-A"</span>)</span></span>;</span><br><span class="line"><span class="function">BOOK <span class="title">B</span><span class="params">(<span class="string">"B-B-B"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;A.isSameISBN(B)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//正经地进行比较，无需发生转换</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;A.isSameISBN(<span class="built_in">string</span>(<span class="string">"A-A-A"</span>))&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//此处即发生一个隐式转换：string类型--&gt;BOOK类型，借助BOOK的构造函数进行转换，以满足isSameISBN函数的参数期待。</span></span><br></pre></td></tr></table></figure>

<p>禁止隐式转换：explicit，该关键字只能用来修饰类内部的构造函数；</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explicit BOOK(string ISBN,float price=0.0f):_bookISBN(ISBN),_price(price)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-四种类型转换"><a href="#C-四种类型转换" class="headerlink" title="C++四种类型转换"></a>C++四种类型转换</h1><p>C风格的强制类型转换很简单，均用 Type b = (Type)a 形式转换。<br>C++风格的类型转换提供了4种类型转换操作符来应对不同场合的应用<br>1、<strong>const_cast</strong> 去掉类型的const或volatile属性<br>去掉类型的const或volatile属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> T a;</span><br><span class="line"><span class="comment">//a.i = 10;  //直接修改const类型，编译错误</span></span><br><span class="line">T &amp;b = <span class="keyword">const_cast</span>&lt;T&amp;&gt;(a);</span><br><span class="line">b.i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>2、<strong>static_cast</strong> 无条件转换，静态类型转换<br>基类和子类之间的转换：其中子类指针转换为父类指针是安全的，但父类指针转换为子类指针是不安全的（基类和子类之间的动态类型转换建议用dynamic_cast）。<br><strong>基本数据类型</strong>转换，enum，struct，int，char，float等。static_cast<strong>不能进行无关类型</strong>（如非基类和子类）指针之间的转换。<br>把任何类型的表达式<strong>转换成void</strong>类型。<br>3、<strong>dynamic_cast</strong> 有条件转换，动态类型转换，运行时检查类型安全<br>更多使用static_cast，dynamic本身只能用于<strong>存在虚函数的父子关系</strong>的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常<br>4、<strong>reinterpret_cast</strong> 仅重新解释类型，但没有进行二进制的转换<br>可以用于<strong>任意类型</strong>的指针之间的转换，对转换的结果<strong>不做任何保证</strong><br>为什么不使用C的强制转换？<br>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
<h1 id="C-源文件从文本到可执行文件经历的过程"><a href="#C-源文件从文本到可执行文件经历的过程" class="headerlink" title="C++源文件从文本到可执行文件经历的过程"></a>C++源文件从文本到可执行文件经历的过程</h1><p>对于C++源文件，从文本到可执行文件一般需要四个过程：<br><strong>预处理阶段</strong>：主要处理源代码文件中的以“#”开头的预编译指令。对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。<br><strong>编译阶段</strong>：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件<br><strong>汇编阶段</strong>：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件<br><strong>链接阶段</strong>：将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
<h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><p>1、静态链接：<br>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。<br>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；<br>更新困难：每当库函数的代码修改了，这个时候就需要<strong>重新进行编译链接</strong>形成可执行程序。<br>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候<strong>运行速度快</strong>。
2、动态链接：<br>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序<strong>运行时才将它们链接在一起形成一个完整的程序</strong>，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。<br>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；<br>更新方便：更新时只需要<strong>替换原来的目标文件</strong>，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。<br>性能损耗：因为把链接推迟到了程序运行时，所以<strong>每次执行程序都需要进行链接</strong>，所以性能会有一定损失。</p>
<h1 id="include头文件的顺序以及双引号””和尖括号-lt-gt-的区别"><a href="#include头文件的顺序以及双引号””和尖括号-lt-gt-的区别" class="headerlink" title="include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别"></a>include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h1><p>Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。<br>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。<br>对于使用双引号包含的头文件，查找头文件路径的顺序为：<br><strong>当前头文件目录 -&gt; 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径 -&gt; 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</strong><br>对于使用尖括号包含的头文件，查找头文件的路径顺序为：<br><strong>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）-&gt; 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</strong></p>
<h1 id="什么时候会发生段错误"><a href="#什么时候会发生段错误" class="headerlink" title="什么时候会发生段错误"></a>什么时候会发生段错误</h1><p>段错误通常发生在<strong>访问非法内存地址</strong>的时候，具体来说分为以下几种情况：<br>使用野指针(指向一个不存在的对象或者未申请访问受限内存区域的指针)<br>试图修改字符串常量的内容</p>
<h1 id="C-模板"><a href="#C-模板" class="headerlink" title="C++ 模板"></a>C++ 模板</h1><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。<br>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector &lt;int&gt; 或 vector &lt;string&gt;<br>函数模板</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">Max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b:a; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">39</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max(i, j): "</span> &lt;&lt; Max(i, j) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//Max(i, j): 39</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> f1 = <span class="number">13.5</span>; </span><br><span class="line">    <span class="keyword">double</span> f2 = <span class="number">20.7</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max(f1, f2): "</span> &lt;&lt; Max(f1, f2) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//Max(f1, f2): 20.7</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"Hello"</span>; </span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"World"</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max(s1, s2): "</span> &lt;&lt; Max(s1, s2) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//Max(s1, s2): World</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; elems;   <span class="comment">// 元素 </span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;  <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;   <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;   <span class="comment">// 如果为空则返回真</span></span><br><span class="line">        <span class="keyword">return</span> elems.empty(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Stack</span>&lt;T&gt;:</span>:push (T <span class="keyword">const</span>&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 追加传入元素的副本</span></span><br><span class="line">    elems.push_back(elem);    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Stack</span>&lt;T&gt;:</span>:pop () </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.empty()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> out_of_range(<span class="string">"Stack&lt;&gt;::pop(): empty stack"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    elems.pop_back();         </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Stack</span>&lt;T&gt;:</span>:top () <span class="keyword">const</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.empty()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> out_of_range(<span class="string">"Stack&lt;&gt;::top(): empty stack"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最后一个元素的副本 </span></span><br><span class="line">    <span class="keyword">return</span> elems.back();      </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        Stack&lt;<span class="keyword">int</span>&gt; intStack;   <span class="comment">// int 类型的栈 </span></span><br><span class="line">        Stack&lt;<span class="built_in">string</span>&gt; stringStack;   <span class="comment">// string 类型的栈 </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 int 类型的栈 </span></span><br><span class="line">        intStack.push(<span class="number">7</span>); </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; intStack.top() &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//7</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 string 类型的栈 </span></span><br><span class="line">        stringStack.push(<span class="string">"hello"</span>); </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; stringStack.top() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//hello</span></span><br><span class="line">        stringStack.pop(); </span><br><span class="line">        stringStack.pop(); Exception: Stack&lt;&gt;::pop(): empty <span class="built_in">stack</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (exception <span class="keyword">const</span>&amp; ex) &#123; </span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Exception: "</span> &lt;&lt; ex.what() &lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-string实现原理"><a href="#C-string实现原理" class="headerlink" title="C++ string实现原理"></a>C++ string实现原理</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">  String(<span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="literal">NULL</span>); <span class="comment">// 普通构造函数 </span></span><br><span class="line">  String(<span class="keyword">const</span> String &amp;other); <span class="comment">// 拷贝构造函数 </span></span><br><span class="line">  ~ String(<span class="keyword">void</span>); <span class="comment">// 析构函数 </span></span><br><span class="line">  String &amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> String &amp;other); <span class="comment">// 赋值函数 </span></span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">  <span class="keyword">char</span> *m_data; <span class="comment">// 用于保存字符串 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//普通构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span> *str) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(str==<span class="literal">NULL</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>]; <span class="comment">// 得分点：对空字符串自动申请存放结束标志'\0'的空</span></span><br><span class="line">    <span class="comment">//加分点：对m_data加NULL 判断</span></span><br><span class="line">    *m_data = <span class="string">'\0'</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(str); </span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length+<span class="number">1</span>]; </span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String的析构函数</span></span><br><span class="line">String::~String(<span class="keyword">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">delete</span> [] m_data; <span class="comment">// 或delete m_data;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> String &amp;other) 　　　<span class="comment">// 得分点：输入参数为const型</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">int</span> length = <span class="built_in">strlen</span>(other.m_data); </span><br><span class="line">  m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length+<span class="number">1</span>]; 　　　　</span><br><span class="line">  <span class="built_in">strcpy</span>(m_data, other.m_data); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值函数</span></span><br><span class="line">String &amp; String::<span class="keyword">operator</span> =(<span class="keyword">const</span> String &amp;other) <span class="comment">// 得分点：输入参数为const型</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;other) 　　<span class="comment">//得分点：检查自赋值</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">  <span class="keyword">delete</span> [] m_data; 　　　　<span class="comment">//得分点：释放原有的内存资源</span></span><br><span class="line">  <span class="keyword">int</span> length = <span class="built_in">strlen</span>( other.m_data ); </span><br><span class="line">  m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length+<span class="number">1</span>]; 　</span><br><span class="line">  <span class="built_in">strcpy</span>( m_data, other.m_data ); </span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>; 　　　　　　　　<span class="comment">//得分点：返回本对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> argc, <span class="keyword">char</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  String s1;</span><br><span class="line">  <span class="function">String <span class="title">s2</span><span class="params">(<span class="string">"222"</span>)</span></span>;</span><br><span class="line">  s1 = s2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-map、set实现原理-红黑树"><a href="#C-map、set实现原理-红黑树" class="headerlink" title="C++ map、set实现原理:红黑树"></a>C++ map、set实现原理:红黑树</h1><p><strong>1、红黑树：</strong><br>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树保证<strong>最长路径不超过最短路径的二倍</strong>，因而近似平衡。红黑树是一种<strong>弱平衡二叉树</strong>，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。性质：<br>(1)每个节点非红即黑<br>(2)<strong>根节点是黑</strong>的;<br>(3)每个<strong>叶节点</strong>（叶节点即树尾端NULL指针或NULL节点）都是<strong>黑</strong>的;<br>(4)如果一个节点是<strong>红色的，则它的子节点必须是黑色</strong>的。<br>(5)对于任意节点而言，其<strong>到叶子点树NULL指针的每条路径都包含相同数目的黑节点</strong>;
<strong>2、平衡二叉树（AVL树）：</strong><br>红黑树是在AVL树的基础上提出来的。平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且<strong>左右子树高度之差不超过1</strong>。
<strong>3、红黑树较AVL树的优点：</strong><br>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，<strong>插入最多两次旋转，删除最多三次旋转</strong>。
所以红黑树在查找，插入删除的性能都是<strong>O(logn)</strong>，且性能稳定，所以STL里面很多结构包括set、map底层实现都是使用的红黑树。<br><strong>4、红黑树旋转：</strong><br>旋转：红黑树的旋转是一种能保持二叉搜索树性质的搜索树局部操作。有左旋和右旋两种旋转，通过改变树中某些结点的颜色以及指针结构来保持对红黑树进行插入和删除操作后的红黑性质。<br>左旋：对某个结点x做左旋操作时，假设其右孩子为y：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的左孩子，y的左孩子成为x的右孩子。<br> <img src="https://img-blog.csdnimg.cn/20190926144910944.png" alt="在这里插入图片描述"><br>右旋：对某个结点x做右旋操作时，假设其左孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的右孩子，y的右孩子成为x的左孩子。<br> <img src="https://img-blog.csdnimg.cn/20190926144917548.png" alt="在这里插入图片描述"></p>
<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>JPEG中就应用了哈夫曼编码。哈夫曼编码是哈夫曼树的一种应用，广泛用于数据文件压缩。<br>哈夫曼树又称最优二叉树，是一种<strong>带权路径长度最短</strong>的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的带权路径长度记为WPL= (W1<em>L1 + W2</em>L2 + W3<em>L3 + … + Wn</em>Ln)，N个权值Wi(i=1,2,…n)构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li(i=1,2,…n)。可以证明哈夫曼树的WPL是最小的。<br>哈夫曼编码步骤：<br>一、对给定的n个权值{W1,W2,W3,…,Wi,…,Wn}构成n棵二叉树的初始集合F= {T1,T2,T3,…,Ti,…,Tn}，其中每棵二叉树Ti中只有一个权值为Wi的根结点，它的左右子树均为空。（为方便在计算机上实现算 法，一般还要求以Ti的权值Wi的升序排列。）<br>二、在F中选取两棵根结点权值最小的树作为新构造的二叉树的左右子树，新二叉树的根结点的权值为其左右子树的根结点的权值之和。<br>三、从F中删除这两棵树，并把这棵新的二叉树同样以升序排列加入到集合F中。<br>四、重复二和三两步，直到集合F中只有一棵二叉树为止。<br>哈夫曼编码是一种无前缀编码。解码时不会混淆。其主要应用在数据压缩，加密解密等场合。<br>a b c d e :5 4 3 2 1<br> <img src="https://img-blog.csdnimg.cn/2019092614511520.png" alt="在这里插入图片描述"></p>
<h1 id="vector、list、deque、set、map的应用场景"><a href="#vector、list、deque、set、map的应用场景" class="headerlink" title="vector、list、deque、set、map的应用场景"></a>vector、list、deque、set、map的应用场景</h1><p><strong>1、set和map</strong><br>共同点：都是C++的关联容器,只是通过它提供的接口对里面的元素进行访问，底层都是采用<strong>红黑树</strong>实现<br>不同点：<br>set：用来判断某一个元素是不是在一个组里面，使用的比较少；<br>map：映射，相当于字典，把一个值映射成另一个值，可以创建字典<br>优点：查找某一个数的时间为<strong>O(logn)</strong>；遍历时采用iterator，效果不错<br>缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响<br><strong>2、vector</strong><br>是<strong>动态数组</strong>，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放；如果新值大于当前大小时才会重新分配内存。<br>特点：拥有一段连续的内存空间，并且起始地址不变，因此能够非常好的支持随机存取，即[]操作符；<br>对头部和中间进行添加删除元素操作需要移动内存，如果元素是结构或类，那么移动的同时还会进行构造和析构操作，所以性能不高；<br>对任何元素的访问时间都是<strong>O(1)</strong>，所以常用来保存需要经常进行<strong>随机访问</strong>的内容，并且不需要经常对中间元素进行添加删除操作<br><strong>3、list</strong><br><strong>双向链表</strong>，元素也存放在堆中，每个元素都是放在一块内存中，他的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供[]操作符的重载。但是由于链表的特点，它可以很有效率的支持任意地方的删除和插入操作。<br>特点<br>在哪里添加删除元素性能都很高，不需要移动内存，当然也不需要对每个元素都进行构造与析构了，所以常用来做<strong>随机插入和删除</strong>操作容器；<br>访问开始和最后两个元素最快，其他元素的访问时间都是<strong>O(n)</strong><br><strong>4、deque</strong><br><strong>分段连续线性空间</strong>，支持[]操作符，也就是支持随机存取，有比较高的随机存取速度，由于deque需要处理内部跳转，因此速度上没有vector快</p>
<table>
<thead>
<tr>
<th></th>
<th>deque</th>
<th>vector</th>
</tr>
</thead>
<tbody><tr>
<td>组织方式</td>
<td>按页或块来分配存储器的，每页包含固定数目的元素</td>
<td>分配一段连续的内存来存储内容</td>
</tr>
<tr>
<td>效率</td>
<td>即使在容器的前端也可以提供常数时间的insert和erase操作，而且在体积增长方面也比vector更具有效率</td>
<td>只是在序列的尾端插入元素时才有效率，但是随机访问速度要比deque快</td>
</tr>
</tbody></table>
<p>总结vector    list    deque<br>| |vector|list|deque|<br>|–|–|–|–|<br>|特点|快速的随机存取，快速的在最后插入删除元素|可以快速的在任意位置添加删除元素，只能快速的访问最开始和最后面的元素|在开始和最后添加删除元素一样快，并且提供了随机访问的方法|<br>|适用|需要高效的<strong>随机存取</strong>，不在于插入删除的效率|需要大量的<strong>插入和删除</strong>操作，不关心随机存取|需要随机存取，也需要高效的在两端进行插入删除操作</p>
<h1 id="vector和list的区别"><a href="#vector和list的区别" class="headerlink" title="vector和list的区别"></a>vector和list的区别</h1><p>1）vector底层实现是数组；list是双向链表。<br>2）vector是顺序内存,支持随机访问，list不行。<br>4）vector在中间节点进行插入删除会导致内存拷贝，list不会。<br>5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。<br>6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</p>
<h1 id="vector、list、map、set迭代器失效"><a href="#vector、list、map、set迭代器失效" class="headerlink" title="vector、list、map、set迭代器失效"></a>vector、list、map、set迭代器失效</h1><p>1.对于<strong>序列容器vector,deque</strong>来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会<strong>返回下一个有效的迭代器</strong>；
iter =cont.erase(iter)<br>2.对于<strong>关联容器map set</strong>来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，<strong>不会影响到下一个</strong>元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可；<br>erase(iter++)<br>3.对于<strong>list</strong>来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。<br>| |vector|deque|list|set、map|<br>|–|–|–|–|–|<br>|内部数据结构|数组(一段连续内存空间)|数组(多段连续内存空间)|双向环状链表|红黑树|<br>|插入操作|插入后元素总数不大于capacity，插入位置之后的迭代器会失效；大于capacity,所有迭代器都会失效|两端插入, 不会引起迭代器失效；中间插入, 所有迭代器失效|不会出现迭代器失效|不会出现迭代器失效|<br>|删除操作|删除位置之后的迭代器都会失效,但是erase会返回下一个有效的迭代器|两端删除, 被删除元素的迭代器失效中间删除, 所有迭代器失效|被删除节点的迭代器失效|被删除节点的迭代器失效<br>|解决方法| iter =cont.erase(iter)| |iter =cont.erase(iter)或者m.erase(iter++)|m.erase(iter++)</p>
<p>解决方式1： iter =cont.erase(iter)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求只是删除值为偶数的节点 , vector&lt;int&gt; vec&#123; 1, 2, 3, 4, 5 &#125;;</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ::iterator it1 = vec.begin();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//错误实现：链表删除节点导致的迭代器失效，容易造成访问野指针的问题，导致程序崩溃</span></span><br><span class="line"> <span class="keyword">while</span> (it1 != vec.end()) &#123;</span><br><span class="line">   <span class="keyword">if</span> (*it1 % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">     vec.erase(it1); </span><br><span class="line">   &#125;</span><br><span class="line">   it1++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//正确实现：利用erase()函数的返回值为iterator，返回的是删除节点的下一个位置的迭代器</span></span><br><span class="line"> <span class="keyword">while</span> (it1 != vec.end()) &#123;</span><br><span class="line">   <span class="keyword">if</span> (*it1 % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">     it1 = vec.erase(it1); <span class="comment">//重点！！！</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">     it1++;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>解决方式2：erase(iter++)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求删除键值为偶数的键值对</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误实现：</span></span><br><span class="line"><span class="keyword">while</span> (it != m.end())&#123;</span><br><span class="line">  <span class="keyword">if</span>(it-&gt;second % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    m.erase(it);</span><br><span class="line">  &#125;</span><br><span class="line">  it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确实现：</span></span><br><span class="line"><span class="keyword">while</span> (it != m.end())&#123;</span><br><span class="line">  <span class="keyword">if</span>(it-&gt;second % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    m.erase(it++); <span class="comment">//重点！！！</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    it++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-内存分配管理"><a href="#C-内存分配管理" class="headerlink" title="C++内存分配管理"></a>C++内存分配管理</h1><p> <img src="https://img-blog.csdnimg.cn/20190926154738160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZmY2pqaHY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在C++中，虚拟内存分为text代码段、data数据段、bss段、heap堆区、文件映射区以及stack栈区六部分。3G用户空间和1G内核空间<br><strong>代码段</strong> 包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。<br><strong>数据段</strong> 存储程序中已初始化的全局变量和静态变量<br><strong>bss 段</strong> 存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。<br><strong>堆区</strong> 调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。<br><strong>映射区</strong> 存储动态链接库以及调用mmap函数进行的文件映射<br><strong>栈</strong> 使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
<p><strong>内存分配方式有三种：</strong><br>[1]从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。<br>[2]在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br>[3]从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。</p>
<h1 id="A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？"><a href="#A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？" class="headerlink" title="A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？"></a>A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？</h1><p>1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节的空间（0x000m），分配给指针a。<br>2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。<br>3）a = new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。<br>4）a-&gt;i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。</p>
<h1 id="给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"><a href="#给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布" class="headerlink" title="给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"></a>给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布</h1><p>1、static修饰符<br>1）static修饰成员变量<br>无论类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。<br>因为静态数据成员在全局<strong>数据区</strong>分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。<br>2）static修饰成员函数<br>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。<br>Static修饰的成员函数，在<strong>代码区</strong>分配内存。</p>
<p>2、C++继承和虚函数<br>C++多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。<br>动态多态实现有几个条件：<br>(1) 虚函数；<br>(2) 一个基类的指针或引用指向派生类的对象；<br>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。<br>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。<br>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</p>
<p>3、virtual修饰符<br>如果一个类是局部变量则该类数据存储在<strong>栈区</strong>，如果一个类是通过new/malloc动态申请的，则该类数据存储在<strong>堆区</strong>。
如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读<strong>数据段</strong>中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向<strong>代码段</strong>中的具体函数。<br>如果类中成员是virtual属性，会隐藏父类对应的属性。</p>
<h1 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h1><p>静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造</p>
<h1 id="STL的allocator"><a href="#STL的allocator" class="headerlink" title="STL的allocator"></a>STL的allocator</h1><p>STL的分配器用于封装STL容器在内存管理上的底层细节。<br>在C++中，其内存配置和释放如下：<br>new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容<br>delete运算分两个阶段：(1)调用对象析构函数；(2)掉用::operator delete释放内存</p>
<p>为了精密分工，STL allocator将两个阶段操作区分开来：<br>内存配置由alloc::allocate()负责，内存释放由alloc::deallocate()负责；<br>对象构造由::construct()负责，对象析构由::destroy()负责。</p>
<p>同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器，使用malloc()、realloc()、free()函数进行内存空间的分配和释放；当分配的空间大小小于128B时，将使用第二级空间配置器，采用了内存池技术，通过空闲链表来管理内存。</p>
<h1 id="malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h1><p>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap(内存映射)在映射区分配。</p>
<h1 id="C-STL-的内存优化"><a href="#C-STL-的内存优化" class="headerlink" title="C++ STL 的内存优化"></a>C++ STL 的内存优化</h1><p><strong>1）二级配置器结构</strong><br>STL内存管理使用二级内存配置器。<br>1、第一级配置器  分配的区块大于128bytes<br>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。<br>2、第二级配置器  分配的区块小于128bytes<br>在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。<br><strong>内存池管理:</strong> 每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。<br>当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表<br>如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块<br>如果内存池空间足够，则取出内存<br>如果不够分配20块，则分配最多的块数给自由链表<br>如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器</p>
<p><strong>2）二级内存池</strong><br><img src="https://img-blog.csdnimg.cn/20190926162534580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZmY2pqaHY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。<br><strong>如何分配内存：</strong><br>它的内存分配主要分为以下几种情况：<br>1、对应的free_list不为空<br>所需空间大小提升为8的倍数后(如需要13bytes空间，我们会给它分配16bytes大小)，所对应的free_list不为空时，直接从对应的free_list中拔出，第一位置向后移动指向。<br>2、对应的free_list为空，其内存池不为空时：<br>（1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) *20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接从 free-list 中拨出。<br>（2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。<br>（3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存。<br>3、内存池为空，申请内存<br>此时二级空间配置器会使用malloc()从heap上申请内存。<br>4、malloc没有成功<br>在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从任意一个比它所需节点空间大的free_list中拔除一个节点来使用。<br>5、查找失败，调用一级空间配置器<br><strong>释放内存</strong><br> 用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。<br> 否则按照其大小找到合适的自由链表，并将其插入。</p>
<h1 id="new-delete和-malloc-free的区别"><a href="#new-delete和-malloc-free的区别" class="headerlink" title="new/delete和 malloc/free的区别"></a>new/delete和 malloc/free的区别</h1><p>1、new/delete是C++关键字支持重载，需要编译器支持。malloc/free是库函数，需要头文件stdlib.h支持。<br>2、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；<br>3、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。<br>4、new不仅分配一段内存，而且会调用构造函数，malloc不会。<br>5、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。<br>6、malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。<br>7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。<br>8、new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。<br>自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请ArraySize大小的数组</span></span><br><span class="line"><span class="keyword">int</span>* Array = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(ArraySize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 在堆中申请内存</span></span><br><span class="line"><span class="built_in">memset</span>(Array, <span class="number">0</span>, ArraySize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 初始化数组全为 0</span></span><br><span class="line"><span class="built_in">free</span>(Array); <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* Array = <span class="keyword">new</span> <span class="keyword">int</span>[ArraySize]; <span class="comment">// 申请内存，不初始化</span></span><br><span class="line"><span class="comment">//int* Array = new int[ArraySize](); // 初始化数组全为 0</span></span><br><span class="line"><span class="comment">//int* Array = new int[5]&#123; 1,2,3,4,5 &#125;; // 初始化数组为 1,2,3,4,5（VS2015支持）</span></span><br><span class="line"><span class="comment">//int* Array = new int[5]&#123; 1 &#125;; // 初始化数组为 1,0,0,0,0</span></span><br><span class="line"><span class="built_in">memset</span>(Array, <span class="number">1</span>, ArraySize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 初始化数组全为 1</span></span><br><span class="line"><span class="keyword">delete</span>[] Array; <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure>

<h1 id="memory-leak，内存泄漏"><a href="#memory-leak，内存泄漏" class="headerlink" title="memory leak，内存泄漏"></a>memory leak，内存泄漏</h1><p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。可以使用<strong>Valgrind, mtrace</strong>进行内存泄漏检查。</p>
<p>内存泄漏的分类：<br>1.堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.<br>2.系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。<br>3.没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
<h1 id="STL有什么基本组成"><a href="#STL有什么基本组成" class="headerlink" title="STL有什么基本组成"></a>STL有什么基本组成</h1><p>算法、容器、迭代器</p>
<h1 id="STL中map与unordered-map"><a href="#STL中map与unordered-map" class="headerlink" title="STL中map与unordered_map"></a>STL中map与unordered_map</h1><p><strong>底层实现：</strong><br>map底层是基于红黑树实现的，因此map内部元素排列是有序的。而unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。<br><strong>map ：</strong><br>优点：<br>1)有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作<br>2)map的查找、删除、增加等一系列操作时间复杂度稳定，都为O(logn )<br>缺点：查找、删除、增加等操作平均时间复杂度较慢，与n相关<br><strong>unordered_map：</strong><br>优点：<br>查找、删除、添加的速度快，时间复杂度为常数级O(c )<br>unordered_map 缺点：<br>因为unordered_map内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高<br>unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c )，取决于哈希函数。极端情况下可能为O(n)</p>
<h1 id="STL中迭代器的作用，有指针为何还要迭代器"><a href="#STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="STL中迭代器的作用，有指针为何还要迭代器"></a>STL中迭代器的作用，有指针为何还要迭代器</h1><p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。<br><strong>迭代器和指针的区别:</strong><br>迭代器不是指针，是类模板，表现的像指针。他模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、- -等，提供了比指针更高级的行为，可以根据不同类型的数据结构来实现不同的++，- -等操作。</p>
<h1 id="STL里resize和reserve的区别"><a href="#STL里resize和reserve的区别" class="headerlink" title="STL里resize和reserve的区别"></a>STL里resize和reserve的区别</h1><p>resize()：改变当前容器内含有元素的数量(size())</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v&#123;<span class="number">1</span> ,<span class="number">2</span>&#125;; </span><br><span class="line">v.resize(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>); <span class="comment">//1 2 0 0 5</span></span><br></pre></td></tr></table></figure>

<p>v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；</p>
<p>reserve()：改变当前容器的最大容量（capacity）<br>如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；</p>
<p>注意：当v.resize(len)中len&gt;v.capacity()，则v中的size和capacity均设置为len；</p>
<p>当v.resize(len) 中len&lt;=v.capacity()，则v中的size设置为len，而capacity不变;<br>如果此时len&lt;v.size(),那么多出的那些对象(v[len], v[len+1]…)会被销毁，v[0]-v[len-1]仍保留在原地；<br>当v.reserve(len)中len&lt;=v.capacity()，则v中的capacity不变，size不变，即不对容器做任何改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.reserve(<span class="number">100</span>);</span><br><span class="line">a.resize(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//50  100</span></span><br><span class="line">a.resize(<span class="number">150</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//150  150</span></span><br><span class="line">a.reserve(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//150  150</span></span><br><span class="line">a.resize(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//50  150</span></span><br></pre></td></tr></table></figure>

<p>size可能改变capacity，但capacity不会改变size</p>
<h1 id="C-函数重载、覆盖、隐藏"><a href="#C-函数重载、覆盖、隐藏" class="headerlink" title="C++函数重载、覆盖、隐藏"></a>C++函数重载、覆盖、隐藏</h1><p><strong>重载:</strong><br>函数重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br>运算符重载：Box <strong>operator</strong>+(const Box&amp;); //返回类型 Box<br><strong>覆盖/重写:</strong><br>子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写<br><strong>隐藏:</strong><br>派生类的函数屏蔽了与其同名的基类函数。</p>
<p>不能重载的运算符：<br>“.”    “.*”    “?:”      “sizeof()”     “typeid()”     “static_cast&lt;&gt;”    “dynamic_cast&lt;&gt;”      “const_cast&lt;&gt;”       “#”    “##”</p>
<h1 id="C-编译时多态与运行时多态"><a href="#C-编译时多态与运行时多态" class="headerlink" title="C++编译时多态与运行时多态"></a>C++编译时多态与运行时多态</h1><p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。<br>一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数。<br>静态多态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    Add(<span class="number">10.0</span>,<span class="number">20</span>);  <span class="comment">//正常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态多态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span></span>&#123; <span class="comment">//重点！！！</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father say hello"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Father&#123;</span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son say hello"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Father *pFather;</span><br><span class="line">    Son son;</span><br><span class="line">    pFather = &amp;son; </span><br><span class="line">    pFather-&gt;Say(); <span class="comment">//Son say hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="虚函数的实现"><a href="#虚函数的实现" class="headerlink" title="虚函数的实现"></a>虚函数的实现</h1><p>在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<h1 id="如何实现只能动态分配类对象，不能静态分配"><a href="#如何实现只能动态分配类对象，不能静态分配" class="headerlink" title="如何实现只能动态分配类对象，不能静态分配"></a>如何实现只能动态分配类对象，不能静态分配</h1><p>动态分配就是用运算符new来创建一个类的对象，在堆上分配内存。<br>静态分配就是A a;这样来由编译器来创建一个对象，在栈 上分配内存。<br><strong>1、动态分配（在堆上分配内存）</strong><br>将类的构造函数和析构函数设为protected属性，这样类对象不能够访问，但是派生类能够访问，能够正常的继承。同时创建另外两个create和destory函数类创建对象。（将create设为static原因是：创建对象的时候是A *p = A::create(); 只有静态成员函数才能够通过类名来访问。）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">    A()&#123;&#125;  </span><br><span class="line">    ~A()&#123;&#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> A* <span class="title">create</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2、只能静态创建对象</strong><br>只有使用new运算符，对象才会被建立在堆上。因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设为私有，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">     <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125; </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">     A()&#123;&#125;  </span><br><span class="line">     ~A()&#123;&#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="C-中类成员的访问权限"><a href="#C-中类成员的访问权限" class="headerlink" title="C++中类成员的访问权限"></a>C++中类成员的访问权限</h1><p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。<br>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。<br>在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。</p>
<p>无论共有继承、私有和保护继承，私有成员不能被“派生类”访问，基类中的共有和保护成员能被“派生类”访问。<br>对于共有继承，只有基类中的共有成员能被“派生类对象”访问，保护和私有成员不能被“派生类对象”访问。对于私有和保护继承，基类中的所有成员不能被“派生类对象”访问。</p>
<h1 id="C-类内可以定义引用数据成员吗？"><a href="#C-类内可以定义引用数据成员吗？" class="headerlink" title="C++类内可以定义引用数据成员吗？"></a>C++类内可以定义引用数据成员吗？</h1><p>可以，必须通过成员函数初始化列表初始化。</p>
<h1 id="动态链接库与静态链接库的区别"><a href="#动态链接库与静态链接库的区别" class="headerlink" title="动态链接库与静态链接库的区别"></a>动态链接库与静态链接库的区别</h1><p>1、 静态链接库的后缀名为lib，动态链接库的导入库的后缀名也为lib。不同的是，静态库中包含了函数的实际执行代码，而对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息；<br>2、由于静态库是在编译期间直接将代码合到可执行程序中，而动态库是在执行期时调用DLL中的函数体，所以执行速度比动态库要快一点；<br>3、 静态库链接生成的可执行文件体积较大，且包含相同的公共代码，造成内存浪费；<br>4、 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；<br>5、 DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性，适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。</p>
<h1 id="C-中struct和class的区别"><a href="#C-中struct和class的区别" class="headerlink" title="C++中struct和class的区别"></a>C++中struct和class的区别</h1><p>在c中，struct不能包含任何函数, 在C++中struct得到了很大的扩充：1.struct可以包括成员函数2.struct可以实现继承3.struct可以实现多态。在C++中struct和class的区别并不是很大，两者之间有很大的相似性。那么为什么还要保留struct,这是因为C++是向下兼容的，因此C++中保留了很多C的东西。<br>区别：<br>1.默认的继承访问权。struct的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。<br>2.另外，class还可以定义模板类形参，比如template &lt;class T, int i&gt;。</p>
<h1 id="C-接口（抽象类）"><a href="#C-接口（抽象类）" class="headerlink" title="C++接口（抽象类）"></a>C++接口（抽象类）</h1><p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类，纯虚函数是通过在声明中使用 “= 0” 来指定的。设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">soapBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~soapBase()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SFJSoap</span>:</span><span class="keyword">public</span> soapBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"SFJ Soap!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XSLSoap</span>:</span><span class="keyword">public</span> soapBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"XSL Soap!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="虚函数与纯虚函数区别"><a href="#虚函数与纯虚函数区别" class="headerlink" title="虚函数与纯虚函数区别"></a>虚函数与纯虚函数区别</h1><p>C++的虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现。子类可以重写父类的虚函数实现子类的特殊化。<br>C++中的纯虚函数更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”。 C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。</p>
<h1 id="构造函数、析构函数"><a href="#构造函数、析构函数" class="headerlink" title="构造函数、析构函数"></a>构造函数、析构函数</h1><p>构造函数 会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。<br>使用初始化列表来初始化字段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C::C( <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c): X(a), Y(b), Z(c)&#123;....&#125;</span><br></pre></td></tr></table></figure>

<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。<br>当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。<br>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。<br>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      Line();   <span class="comment">// 这是构造函数声明</span></span><br><span class="line">      ~Line();  <span class="comment">// 这是析构函数声明</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">void</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Line::~Line(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being deleted"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> Line::setLength( <span class="keyword">double</span> len ) &#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">double</span> Line::getLength( <span class="keyword">void</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么析构函数必须是虚函数？</strong><br>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<p><strong>为什么C++默认的析构函数不是虚函数</strong><br>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
<h1 id="静态函数和虚函数的区别"><a href="#静态函数和虚函数的区别" class="headerlink" title="静态函数和虚函数的区别"></a>静态函数和虚函数的区别</h1><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</p>
<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="keyword">int</span> *p=&amp;a;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="keyword">int</span> &amp;b=a;</span><br></pre></td></tr></table></figure>

<p>指针是一个变量，存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，是原变量的一个别名。<br><strong>区别：</strong><br>1、指针有自己的一块空间，而引用只是一个别名；<br>2、使用sizeof看一个指针的大小是4（32位），而引用则是被引用对象的大小；<br>3、指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；<br>4、作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；<br>5、可以有const指针，但是没有const引用；<br>6、指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；<br>7、指针可以有多级指针（**p），而引用至于一级；<br>8、指针和引用使用++运算符的意义不一样。</p>
<p><strong>实际上”引用”可以做的任何事情”指针”也都能够做，为什么还要”引用”这东西？</strong><br>答案是 指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。<br>如果的确只需要借用一下某个对象的”别名”，那么就用”引用”，而不要用”指针”，以免发生意外。</p>
<h1 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h1><table>
<thead>
<tr>
<th>指针</th>
<th>数组</th>
</tr>
</thead>
<tbody><tr>
<td>保存数据的地址</td>
<td>保存数据</td>
</tr>
<tr>
<td>间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据</td>
<td>直接访问数据</td>
</tr>
<tr>
<td>通常用于动态的数据结构</td>
<td>通常用于固定数目且数据类型相同的元素</td>
</tr>
<tr>
<td>通过Malloc分配内存，free释放内存</td>
<td>隐式的分配和删除</td>
</tr>
<tr>
<td>通常指向匿名数据，操作匿名函数</td>
<td>自身即为数据名</td>
</tr>
<tr>
<td># 函数指针</td>
<td></td>
</tr>
<tr>
<td>函数指针是指向函数的指针变量。</td>
<td></td>
</tr>
<tr>
<td>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;,<span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span></span><br><span class="line"><span class="function"><span class="comment">//想要声明一个指向改函数的指针，只需要用指针替换函数名即可</span></span></span><br><span class="line"><span class="function"><span class="title">bool</span> <span class="params">(*pf)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;<span class="comment">//未初始化　</span></span><br><span class="line">pf=LengthCompare;</span><br><span class="line"><span class="comment">//pf=&amp;LengthCompare;</span></span><br><span class="line"><span class="keyword">bool</span> b1=pf(<span class="string">"hello"</span>,<span class="string">"goodbye"</span>);</span><br><span class="line"><span class="keyword">bool</span> b2=(*pf)(<span class="string">"hello"</span>,<span class="string">"goodbye"</span>);</span><br><span class="line"><span class="keyword">bool</span> b3=LengthCompare(<span class="string">"hello"</span>,<span class="string">"goodbye"</span>);</span><br><span class="line"><span class="comment">//三个等价调用</span></span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
</tbody></table>
<h1 id="const-char-，char-，const-char-crr-，char-drr"><a href="#const-char-，char-，const-char-crr-，char-drr" class="headerlink" title="const char *，char *，const char crr[]，char drr[]"></a>const char *，char *，const char crr[]，char drr[]</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * arr = <span class="string">"123"</span>;</span><br><span class="line"><span class="comment">//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改</span></span><br><span class="line"><span class="comment">//但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</span></span><br><span class="line"><span class="keyword">char</span> * brr = <span class="string">"123"</span>;</span><br><span class="line"><span class="comment">//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改"123"的值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> crr[] = <span class="string">"123"</span>;</span><br><span class="line"><span class="comment">//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</span></span><br><span class="line"><span class="keyword">char</span> drr[] = <span class="string">"123"</span>;</span><br><span class="line"><span class="comment">//字符串123保存在栈区，可以通过drr去修改</span></span><br></pre></td></tr></table></figure>

<h1 id="C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>C++里是怎么定义常量的？常量存放在内存的哪个位置？</h1><p>常量在C++里的定义const加上对象类型，常量定义必须初始化。<br>对于局部常量，存放在栈区；<br>对于全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；<br>字面值常量，比如字符串，放在常量区。</p>
<h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h1><p>sizeof和new、delete等一样，是关键字，不是函数或者宏<br>sizeof返回内存中分配的字节数，它和操作系统的位数有关。例如在常见的32位系统中，int类型占4个字节；但是在16位系统中，int类型占2个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在32位系统中不同类型的内存分配</span></span><br><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>);        <span class="comment">// = 4   </span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">double</span>);     <span class="comment">// = 8   </span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">char</span>);       <span class="comment">// = 1   </span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">bool</span>);       <span class="comment">// = 1   </span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">short</span>);      <span class="comment">// = 2   </span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">float</span>);      <span class="comment">// = 4   </span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">long</span>);       <span class="comment">// = 4  </span></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span> *);         <span class="comment">// = 4   </span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">double</span> *);      <span class="comment">// = 4   </span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">char</span> *);        <span class="comment">// = 4  </span></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123; &#125;   </span><br><span class="line"><span class="keyword">sizeof</span>(fn); <span class="comment">// error：函数   </span></span><br><span class="line"><span class="keyword">sizeof</span>(fn()); <span class="comment">// error：不能确定类型  </span></span><br><span class="line"><span class="comment">//sizeof对函数调用求值结果是函数返回值类型的大小，函数并不会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3</span>;&#125;   </span><br><span class="line"><span class="keyword">sizeof</span>(fun);  <span class="comment">// = sizeof(int) = 4</span></span><br><span class="line"><span class="comment">// 数组 </span></span><br><span class="line"><span class="keyword">int</span> ai[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;  <span class="comment">//数组的sizeof返回整个数组所占的字节数，即（数组元素个数×每个元素所占字节）。</span></span><br><span class="line"><span class="keyword">sizeof</span>(ai);         <span class="comment">// = 2*4 = 8  </span></span><br><span class="line"><span class="comment">// 常量字符串与字符数组的内存分配方式相同</span></span><br><span class="line"><span class="keyword">char</span> ac[] = <span class="string">"abcd"</span>;  <span class="comment">//注意数组末尾的字符串终结符'\0'   </span></span><br><span class="line"><span class="keyword">sizeof</span>(ac);          <span class="comment">// = 5*1 = 5   //注意！！！</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="string">"abcd"</span>);      <span class="comment">// = 5*1 = 5  </span></span><br><span class="line"><span class="comment">// 数组和指针所占的字节数不同</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//这是指针   </span></span><br><span class="line"><span class="keyword">sizeof</span>(pi);            <span class="comment">// = 4   </span></span><br><span class="line"><span class="keyword">int</span> ai[<span class="number">10</span>];   </span><br><span class="line"><span class="keyword">int</span> *p = ai;           <span class="comment">//这还是指针   </span></span><br><span class="line"><span class="keyword">sizeof</span>(p);             <span class="comment">// = 4   </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">double</span>* (*a)[<span class="number">3</span>][<span class="number">6</span>];    <span class="comment">//看成(double *) (*a)[3][6]，即一个3×6的二维数组，数组元素为指针，指向double类型。   </span></span><br><span class="line"><span class="keyword">sizeof</span>(a);             <span class="comment">// = 4，a为指向上述二维数组的指针   </span></span><br><span class="line"><span class="keyword">sizeof</span>(*a);            <span class="comment">// = sizeof(double *)*3*6 = 72，*a表示上述二维数组       </span></span><br><span class="line"><span class="keyword">sizeof</span>(**a);           <span class="comment">// = sizeof(double *)*6 = 24，**a即*(*a)，表示double*[6]，是元素为double指针的一维数组。   </span></span><br><span class="line"><span class="keyword">sizeof</span>(***a);          <span class="comment">// = sizeof(double *) = 4，表示上述一维数组中的第一个元素，元素类型为double指针。   </span></span><br><span class="line"><span class="keyword">sizeof</span>(****a);         <span class="comment">// = sizeof(double) = 8，表示上述数组首元素指向的double类型。 </span></span><br><span class="line"><span class="comment">// 函数形式参数中的数组会蜕变为指针，原因是数组参数“传址调用”</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aif</span><span class="params">(<span class="keyword">int</span> p[])</span>       <span class="comment">//参数类型是int[]，表示指向int的指针   </span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">sizeof</span>( p );        <span class="comment">// = 4   </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pif</span><span class="params">(<span class="keyword">int</span> (*p)[<span class="number">6</span>])</span>   <span class="comment">//参数类型是int (*)[6]，表示指向int数组的指针   </span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">sizeof</span>( p);         <span class="comment">// = 4   </span></span><br><span class="line">    <span class="keyword">sizeof</span>( *p );       <span class="comment">// = sizeof(int)*6 = 24   </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ppf</span><span class="params">(<span class="keyword">int</span> *p[<span class="number">6</span>])</span>     <span class="comment">//参数类型是int *[]，表示指向int指针的指针   </span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">sizeof</span>( p );        <span class="comment">// = 4   </span></span><br><span class="line">    <span class="keyword">sizeof</span>( *p );       <span class="comment">// = 4   </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 32位 类和结构体的内存分配</span></span><br><span class="line"><span class="comment">// 空类或空结构体占一个字节</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEmpty</span> &#123;</span> &#125;;   </span><br><span class="line"><span class="keyword">sizeof</span>(CEmpty); <span class="comment">// = 1   </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEmpty</span> &#123;</span> &#125;;   </span><br><span class="line"><span class="keyword">sizeof</span>(SEmpty); <span class="comment">// = 1 </span></span><br><span class="line"><span class="comment">// 非空类和结构体所占字节为所有成员占字节的和，但是不包括成员函数和静态成员所占的空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CInt</span> :</span> <span class="keyword">public</span> CEmpty &#123; <span class="keyword">int</span> i;&#125;;   </span><br><span class="line"><span class="keyword">sizeof</span>(CInt); <span class="comment">// = 4;   </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFunc</span> &#123;</span> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125; &#125;;   </span><br><span class="line"><span class="keyword">sizeof</span>(CFunc); <span class="comment">// = 1;   </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SInt</span> :</span> SEmpty &#123; <span class="keyword">static</span> <span class="keyword">int</span> i;&#125;;   </span><br><span class="line"><span class="keyword">sizeof</span>(SInt); <span class="comment">// = 1;  </span></span><br><span class="line"><span class="comment">// 字节对齐</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SByte1</span>   </span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="keyword">double</span> d;    <span class="comment">// 长度8，偏移量为0；存放位置区间[0,7]</span></span><br><span class="line">    <span class="keyword">char</span> j;      <span class="comment">// 长度1，偏移量为8；存放位置区间[8]</span></span><br><span class="line">    <span class="keyword">int</span> a;       <span class="comment">// 长度4，偏移量12；存放位置区间[12，15] </span></span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">sizeof</span>(SByte1);  <span class="comment">// = 16   </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SByte2</span>   </span></span><br><span class="line"><span class="class">&#123;</span>         </span><br><span class="line">    <span class="keyword">char</span> j;      <span class="comment">// 长度1，偏移量为0；存放位置区间[0,1]</span></span><br><span class="line">    <span class="keyword">double</span> d;    <span class="comment">// 长度8，偏移量8；存放位置区间[8,15]  </span></span><br><span class="line">    <span class="keyword">int</span> a;       <span class="comment">// 长度4，偏移量16；存放位置区间[16,19]</span></span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">sizeof</span>(SByte2);  <span class="comment">// = 24，为了凑成8的倍数，填充20~23  </span></span><br><span class="line"><span class="comment">//可以通过#pragma pack(n)来设定变量以n字节对齐方式，n=1,2,4,8,16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push) <span class="comment">//保存对齐状态   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)    <span class="comment">//设定为4字节对齐   </span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CByte</span>   </span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="keyword">char</span> c;       <span class="comment">//长度1 &lt; 4 按1对齐；偏移量为0；存放位置区间[0,1]</span></span><br><span class="line">    <span class="keyword">double</span> d;     <span class="comment">//长度8 &gt; 4 按4对齐；偏移量为4；存放位置区间[4,11] </span></span><br><span class="line">    <span class="keyword">int</span> i;        <span class="comment">//长度4 = 4 按4对齐；偏移量为12；存放位置区间[12,15]</span></span><br><span class="line">&#125;;   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)  <span class="comment">//恢复对齐状态   </span></span></span><br><span class="line"><span class="keyword">sizeof</span>(CByte); <span class="comment">// = 16 </span></span><br><span class="line"><span class="comment">// 联合</span></span><br><span class="line"><span class="keyword">union</span> U   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">int</span> i;   </span><br><span class="line">    <span class="keyword">char</span> c;   </span><br><span class="line">    <span class="keyword">double</span> d;   </span><br><span class="line">&#125;;   </span><br><span class="line"><span class="keyword">sizeof</span>(U); <span class="comment">// = Max(sizeof(i), sizeof(c), sizeof(d)) = sizeof(d) = 8</span></span><br></pre></td></tr></table></figure>

<h1 id="空类的大小是多少，如果是派生类呢"><a href="#空类的大小是多少，如果是派生类呢" class="headerlink" title="空类的大小是多少，如果是派生类呢"></a>空类的大小是多少，如果是派生类呢</h1><p><strong>为何空类的大小不是0呢？</strong><br>为了确保两个不同对象的地址不同，必须如此。<br>类的实例化是在内存中分配一块地址，每个实例在内存中都有独一无二的二地址。同样，空类也会实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化后就有独一无二的地址了。所以，空类的sizeof为1，而不是0.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125; &#125;; <span class="comment">//4 具有虚函数表的地址</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;&#125; <span class="comment">//4 具有虚函数的类sizeof都是4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;; <span class="comment">//1 A是空类，其大小为1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> A&#123;&#125;; <span class="comment">//4 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father1</span>&#123;</span>&#125;; <span class="class"><span class="keyword">class</span> <span class="title">Father2</span>&#123;</span>&#125;; <span class="comment">//1 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span>Father1, Father2&#123;&#125;; <span class="comment">//1 多重继承的空类的大小也是1</span></span><br></pre></td></tr></table></figure>

<p><strong>何时共享虚函数地址表：</strong><br>如果派生类继承的第一个是基类，且该基类定义了虚函数地址表，则派生类就共享该表首址占用的存储单元。对于除前述情形以外的其他任何情形，派生类在处理完所有基类或虚基类后，根据派生类是否建立了虚函数地址表，确定是否为该表首址分配存储单元。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span>&#125;; <span class="comment">//sizeof(X):1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;; <span class="comment">//sizeof(Y):4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;; <span class="comment">//sizeof(Z):4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Y &#123;&#125;; <span class="comment">//sizeof(A):8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> Y, <span class="keyword">public</span> Z&#123;&#125;; <span class="comment">//sizeof(B):8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Y, <span class="keyword">public</span> <span class="keyword">virtual</span> Z &#123;&#125;; <span class="comment">//sizeof(C):12</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> C&#123;&#125;; <span class="comment">//sizeof(D):16</span></span><br></pre></td></tr></table></figure>

<h1 id="C语言是怎么进行函数调用的"><a href="#C语言是怎么进行函数调用的" class="headerlink" title="C语言是怎么进行函数调用的"></a>C语言是怎么进行函数调用的</h1><p>eip是指令指针，即指向下一条即将执行的指令的地址；<br>ebp为基址指针，常用来指向栈底；<br>esp为栈指针，常用来指向栈顶。<br>假设函数A调用函数B，我们称A函数为”调用者”,B函数为“被调用者”则函数调用过程可以这么描述：<br>(1)先将调用者(A)的堆栈的基址(ebp)入栈，以保存之前任务的信息。<br>(2)然后将调用者(A)的栈顶指针(esp)的值赋给ebp，作为新的基址(即被调用者B的栈底)。<br>(3)然后在这个基址(被调用者B的栈底)上开辟(一般用sub指令)相应的空间用作被调用者B的栈空间。<br>…执行 B函数的主体机器指令段…<br>(4)函数B返回后，从当前栈帧的ebp即恢复为调用者A的栈顶(esp)，使栈顶恢复函数B被调用前的位置;然后调用者A再从恢复后的栈顶可弹出之前的ebp值(可以这么做是因为这个值在函数调用前一步被压入堆栈)。这样，ebp和esp就都恢复了调用函数B前的位置，也就是栈恢复函数B调用前的状态。</p>
<p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。<br><strong>参数压栈顺序</strong>：从右到左</p>
<p><strong>C++如何处理返回值</strong><br>生成一个临时变量，把它的引用作为函数参数传入函数内。<br><strong>C++中拷贝赋值函数的形参能否进行值传递</strong><br>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</p>
<h1 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h1><p>哈希的过程中需要使用哈希函数进行计算。<br>哈希函数是一种映射关系，根据数据的关键词 key ，通过一定的函数关系，计算出该元素存储位置的函数。表示为：address = H [key]<br><strong>几种常见的哈希函数（散列函数）构造方法</strong><br><strong>直接定址法</strong><br>取关键字或关键字的某个线性函数值为散列地址。<br>即 H(key) = key 或 H(key) = a<em>key + b，其中a和b为常数<br>*</em>除留余数法** 
取关键字被某个不大于散列表长度 m 的数 p 求余，得到的作为散列地址。<br>即 H(key) = key % p, p &lt; m。<br><strong>数字分析法</strong><br>当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为<strong>散列地址</strong><br>仅适用于所有关键字都已知的情况下，根据实际应用确定要选取的部分，尽量避免发生冲突。<br><strong>平方取中法</strong><br>先计算出关键字值的平方，然后取平方值中间几位作为散列地址。<br>随机分布的关键字，得到的散列地址也是随机分布的。<br><strong>折叠法（叠加法）</strong><br>将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。<br>用于关键字位数较多，并且关键字中每一位上数字分布大致均匀。<br><strong>随机数法</strong><br>选择一个随机函数，把关键字的随机函数值作为它的哈希值。<br>通常当关键字的长度不等时用这种方法。<br>当关键字是整数类型时就可以用除留余数法；如果关键字是小数类型，选择随机数法会比较好。</p>
<h1 id="哈希冲突的解决"><a href="#哈希冲突的解决" class="headerlink" title="哈希冲突的解决"></a>哈希冲突的解决</h1><p>加载因子：hash表中已经存储的关键字个数，与可以散列位置的比值，<br>表示Hsah表中元素的填满的程度.若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.冲突的机会越大,则查找的成本越高.反之,查找的成本越小.因而,查找时间就越小.<br>选用哈希函数计算哈希值时，可能不同的 key 会得到相同的结果，一个地址怎么存放多个数据呢？这就是冲突。<br><strong>1、开放地址法</strong>（前提是散列表的长度大于等于所要存放的元素）<br>发生哈希冲突后，按照某一次序找到下一个空闲的单元，把冲突的元素放入。<br><strong>线性探查法</strong><br>    从发生冲突的单元开始探查，依次查看下一个单元是否为空，如果到了最后一个单元还是空，那么再从表首依次判断。如此执行直到碰到了空闲的单元或者已经探查完所有单元。<br><strong>平方探查法</strong><br>    从发生冲突的单元加上1^2,2^2,3^2,…,n^2，直到遇到空闲的单元<br>双散列函数探查法<br>定义两个散列函数，分别为s1和s2，s1的算法和前面一致，s2取一个1～m-1之间并和m互为素数的数。s2作为步长。<br>更适合于造表前无法确定表长的情况；平均查找长度较短；适合结点规模较大时<br><strong>2、链地址法</strong><br>   将哈希值相同的元素构成一个链表，head放在散列表中。一般链表长度超过了8就转为红黑树，长度少于6个就变为链表。 缺点：指针需要额外的空间<br><strong>3、再哈希法</strong><br>    同时构造多个不同的哈希函数，Hi = RHi(key) i= 1,2,3 … k;<br>当H1 = RH1(key) 发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。缺点：每次冲突都要重新散列，计算时间增加
 </p>
<h1 id="设计模式（一）：工厂模式"><a href="#设计模式（一）：工厂模式" class="headerlink" title="设计模式（一）：工厂模式"></a>设计模式（一）：工厂模式</h1><p>工厂模式的两个最重要的功能：<br>定义创建对象的接口，封装了对象的创建；使得具体化类的工作延迟到了子类中。<br>对于工厂模式，为了使其能更好的解决多种情况的问题，将其分为三类：简单工厂模式（Simple Factory），工厂方法模式（Factory Method），抽象工厂模式（Abstract Factory）。<br><strong>简单工厂模式（Simple Factory）</strong><br><img src="https://img-blog.csdnimg.cn/20190926124913807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZmY2pqaHY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>简单设计模式存在的目的很简单：定义一个用于创建对象的接口。<br>缺点：对修改不封闭，新增加产品要修改工厂。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">enum</span> PRODUCTTYPE &#123;SFJ,XSL,NAS&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">soapBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~soapBase()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SFJSoap</span>:</span><span class="keyword">public</span> soapBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"SFJ Soap!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XSLSoap</span>:</span><span class="keyword">public</span> soapBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"XSL Soap!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NASSoap</span>:</span><span class="keyword">public</span> soapBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"NAS Soap!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">soapBase * <span class="title">creatSoap</span><span class="params">(PRODUCTTYPE type)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> SFJ: </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SFJSoap();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> XSL:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XSLSoap();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NAS:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NASSoap();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Factory factory;</span><br><span class="line">  soapBase* pSoap1 = factory.creatSoap(SFJ);</span><br><span class="line">  pSoap1-&gt;show();</span><br><span class="line">  soapBase* pSoap2 = factory.creatSoap(XSL);</span><br><span class="line">  pSoap2-&gt;show();</span><br><span class="line">  soapBase* pSoap3 = factory.creatSoap(NAS);</span><br><span class="line">  pSoap3-&gt;show();</span><br><span class="line">  <span class="keyword">delete</span> pSoap1;</span><br><span class="line">  <span class="keyword">delete</span> pSoap2;</span><br><span class="line">  <span class="keyword">delete</span> pSoap3;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工厂模式（Factory Method）</strong><br><img src="https://img-blog.csdnimg.cn/20190926124926125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZmY2pqaHY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>工厂方法模式的应用并不是只是为了封装对象的创建，而是要把对象的创建放到子类中实现：Factory中只是提供了对象创建的接口，其实现将放在Factory的子类ConcreteFactory中进行<br>缺点：每增加一种产品，就需要增加一个对象的工厂。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">enum</span> SOAPTYPE &#123;SFJ,XSL,NAS&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">soapBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~soapBase()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SFJSoap</span>:</span><span class="keyword">public</span> soapBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"SFJ Soap!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XSLSoap</span>:</span><span class="keyword">public</span> soapBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"XSL Soap!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NASSoap</span>:</span><span class="keyword">public</span> soapBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"NAS Soap!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> soapBase * <span class="title">creatSoap</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SFJFactory</span>:</span><span class="keyword">public</span> FactoryBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">soapBase * <span class="title">creatSoap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SFJSoap();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XSLFactory</span>:</span><span class="keyword">public</span> FactoryBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">soapBase * <span class="title">creatSoap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XSLSoap();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NASFactory</span>:</span><span class="keyword">public</span> FactoryBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">soapBase * <span class="title">creatSoap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NASSoap();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  SFJFactory factory1;</span><br><span class="line">  soapBase* pSoap1 = factory1.creatSoap();</span><br><span class="line">  pSoap1-&gt;show();</span><br><span class="line">  XSLFactory factory2;</span><br><span class="line">  soapBase* pSoap2 = factory2.creatSoap();</span><br><span class="line">  pSoap2-&gt;show();</span><br><span class="line">  NASFactory factory3;</span><br><span class="line">  soapBase* pSoap3 = factory3.creatSoap();</span><br><span class="line">  pSoap3-&gt;show();</span><br><span class="line">  <span class="keyword">delete</span> pSoap1;</span><br><span class="line">  <span class="keyword">delete</span> pSoap2;</span><br><span class="line">  <span class="keyword">delete</span> pSoap3;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象工厂模式（Abstract Factory）</strong><br> <img src="https://img-blog.csdnimg.cn/20190926124936714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZmY2pqaHY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>抽象工厂模式：给客户端提供一个接口，可以创建多个产品族中的产品对象 ，而且使用抽象工厂模式还要满足一下条件：<br>1)系统中有多个产品族，而系统一次只可能消费其中一族产品。<br>2)同属于同一个产品族的产品以其使用。</p>
<p>Eg：搞两个厂房，一个生产低档的牙膏和肥皂，一个生产高档的牙膏和肥皂。比如，厂房一生产中华牙膏、娜爱斯肥皂，厂房二生产黑人牙膏和舒肤佳牙膏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">enum</span> SOAPTYPE &#123;SFJ,XSL,NAS&#125;;</span><br><span class="line"><span class="keyword">enum</span> TOOTHTYPE &#123;HR,ZH&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoapBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~SoapBase()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SFJSoap</span>:</span><span class="keyword">public</span> SoapBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"SFJ Soap!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NASSoap</span>:</span><span class="keyword">public</span> SoapBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"NAS Soap!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToothBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~ToothBase()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HRTooth</span>:</span><span class="keyword">public</span> ToothBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Hei ren Toothpaste!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaTooth</span>:</span><span class="keyword">public</span> ToothBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"China Toothpaste!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> SoapBase * <span class="title">creatSoap</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ToothBase * <span class="title">creatToothpaste</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> :</span><span class="keyword">public</span> FactoryBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">SoapBase * <span class="title">creatSoap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SFJSoap();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">ToothBase * <span class="title">creatToothpaste</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HRTooth();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> :</span><span class="keyword">public</span> FactoryBase</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">SoapBase * <span class="title">creatSoap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NASSoap();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">ToothBase * <span class="title">creatToothpaste</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ChinaTooth();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FactoryA factory1;</span><br><span class="line">  FactoryB factory2;</span><br><span class="line">  SoapBase *pSoap1 = <span class="literal">NULL</span>;</span><br><span class="line">  ToothBase *pToothpaste1 = <span class="literal">NULL</span>;</span><br><span class="line">  pSoap1 = factory1.creatSoap();</span><br><span class="line">  pToothpaste1 = factory1.creatToothpaste();</span><br><span class="line">  pSoap1-&gt;show();</span><br><span class="line">  pToothpaste1-&gt;show();</span><br><span class="line">  </span><br><span class="line">  SoapBase *pSoap2 = <span class="literal">NULL</span>;</span><br><span class="line">  ToothBase *pToothpaste2 = <span class="literal">NULL</span>;</span><br><span class="line">  pSoap2 = factory2.creatSoap();</span><br><span class="line">  pToothpaste2 = factory2.creatToothpaste();</span><br><span class="line">  pSoap2-&gt;show();</span><br><span class="line">  pToothpaste2-&gt;show();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> pSoap1;</span><br><span class="line">  <span class="keyword">delete</span> pSoap2;</span><br><span class="line">  <span class="keyword">delete</span> pToothpaste1;</span><br><span class="line">  <span class="keyword">delete</span> pToothpaste2;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="设计模式（二）：单例模式"><a href="#设计模式（二）：单例模式" class="headerlink" title="设计模式（二）：单例模式"></a>设计模式（二）：单例模式</h1><p>单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。<br>单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。<br>单例的实现主要是通过以下两个步骤：<br>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；<br>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</p>
<p><strong>懒汉：</strong><br>懒汉式的特点是延迟加载，比如配置文件，在第一次用到类实例的时候才会去实例化；<br>懒汉加载，如果并发访问：使用锁机制，防止多次访问,可以这样，第一次判断为空不加锁，若为空，再进行加锁判断是否为空，若为空则生成对象。在访问量较小时，采用懒汉实现。这是以时间换空间。<br><strong>饿汉：</strong><br>饿汉式的特点是一开始就加载了，在单例类定义的时候就进行实例化。<br>由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式 第一次用到类的实例的时候才回去实例化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    singleton()&#123;&#125; <span class="comment">//构造函数私有</span></span><br><span class="line">    <span class="keyword">static</span> singleton* _instance;  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleton* <span class="title">Get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_instance == <span class="literal">NULL</span>)&#123;  <span class="comment">//判断是否第一次调用</span></span><br><span class="line">           Lock();</span><br><span class="line">           <span class="keyword">if</span>(_instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">              _instance = <span class="keyword">new</span> singleton();</span><br><span class="line">           &#125;</span><br><span class="line">           UnLock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式 单例类定义的时候就进行实例化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span>  </span></span><br><span class="line"><span class="class">  &#123;</span>  </span><br><span class="line">  <span class="keyword">private</span>:  </span><br><span class="line">      singleton()&#123;&#125;  <span class="comment">//私有构造函数  </span></span><br><span class="line">  <span class="keyword">public</span>:  </span><br><span class="line">      <span class="function"><span class="keyword">static</span> singleton* <span class="title">Get_instance</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">      </span>&#123;  </span><br><span class="line">          <span class="keyword">static</span> singleton _instance;  </span><br><span class="line">          <span class="keyword">return</span> &amp;_instance;  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>应用场景：<br>Windows的Task Manager（任务管理器）就是很典型的单例模式，你不能同时打开两个任务管理器。Windows的回收站也是同理。<br>应用程序的日志应用，一般都可以用单例模式实现，只能有一个实例去操作文件。<br>读取配置文件，读取的配置项是公有的，一个地方读取了所有地方都能用，没有必要所有的地方都能读取一遍配置。<br>数据库连接池，多线程的线程池。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
          
            <a href="/tags/后台开发/" rel="tag"><i class="fa fa-tag"></i> 后台开发</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/26/25/" rel="next" title="刷题汇总（三）leetcode 精选50题 C++答案总结">
                <i class="fa fa-chevron-left"></i> 刷题汇总（三）leetcode 精选50题 C++答案总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/26/27/" rel="prev" title="C++后台开发知识总结（二）数据库">
                C++后台开发知识总结（二）数据库 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/zj.png" alt="ZhouJie">
            
              <p class="site-author-name" itemprop="name">ZhouJie</p>
              <p class="site-description motion-element" itemprop="description">C++ / 后台开发 / Three</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zj19941113" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1601584358@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/ffcjjhv" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-link"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://zhoujie1994.cn/my" target="_blank" title="主页">
                      
                        <i class="fa fa-fw fa-link"></i>主页</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#extern-“C”的作用"><span class="nav-text">extern “C”的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-和C的区别"><span class="nav-text">C++和C的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-C-const关键字"><span class="nav-text">C/C++ const关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-C-static关键字"><span class="nav-text">C/C++ static关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-C-volatile关键字"><span class="nav-text">C/C++ volatile关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-C-restrict关键字"><span class="nav-text">C/C++ restrict关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是右值引用，跟左值又有什么区别？"><span class="nav-text">什么是右值引用，跟左值又有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-11有哪些新特性"><span class="nav-text">C++11有哪些新特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-智能指针"><span class="nav-text">C++智能指针</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#隐式类型转换"><span class="nav-text">隐式类型转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-四种类型转换"><span class="nav-text">C++四种类型转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-源文件从文本到可执行文件经历的过程"><span class="nav-text">C++源文件从文本到可执行文件经历的过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#静态链接和动态链接"><span class="nav-text">静态链接和动态链接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#include头文件的顺序以及双引号””和尖括号-lt-gt-的区别"><span class="nav-text">include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么时候会发生段错误"><span class="nav-text">什么时候会发生段错误</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-模板"><span class="nav-text">C++ 模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-string实现原理"><span class="nav-text">C++ string实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-map、set实现原理-红黑树"><span class="nav-text">C++ map、set实现原理:红黑树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#哈夫曼编码"><span class="nav-text">哈夫曼编码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vector、list、deque、set、map的应用场景"><span class="nav-text">vector、list、deque、set、map的应用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vector和list的区别"><span class="nav-text">vector和list的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vector、list、map、set迭代器失效"><span class="nav-text">vector、list、map、set迭代器失效</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-内存分配管理"><span class="nav-text">C++内存分配管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？"><span class="nav-text">A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"><span class="nav-text">给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#静态变量什么时候初始化"><span class="nav-text">静态变量什么时候初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL的allocator"><span class="nav-text">STL的allocator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><span class="nav-text">malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-STL-的内存优化"><span class="nav-text">C++ STL 的内存优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#new-delete和-malloc-free的区别"><span class="nav-text">new/delete和 malloc/free的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#memory-leak，内存泄漏"><span class="nav-text">memory leak，内存泄漏</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL有什么基本组成"><span class="nav-text">STL有什么基本组成</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL中map与unordered-map"><span class="nav-text">STL中map与unordered_map</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL中迭代器的作用，有指针为何还要迭代器"><span class="nav-text">STL中迭代器的作用，有指针为何还要迭代器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL里resize和reserve的区别"><span class="nav-text">STL里resize和reserve的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-函数重载、覆盖、隐藏"><span class="nav-text">C++函数重载、覆盖、隐藏</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-编译时多态与运行时多态"><span class="nav-text">C++编译时多态与运行时多态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚函数的实现"><span class="nav-text">虚函数的实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何实现只能动态分配类对象，不能静态分配"><span class="nav-text">如何实现只能动态分配类对象，不能静态分配</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中类成员的访问权限"><span class="nav-text">C++中类成员的访问权限</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-类内可以定义引用数据成员吗？"><span class="nav-text">C++类内可以定义引用数据成员吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态链接库与静态链接库的区别"><span class="nav-text">动态链接库与静态链接库的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中struct和class的区别"><span class="nav-text">C++中struct和class的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-接口（抽象类）"><span class="nav-text">C++接口（抽象类）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚函数与纯虚函数区别"><span class="nav-text">虚函数与纯虚函数区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造函数、析构函数"><span class="nav-text">构造函数、析构函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#静态函数和虚函数的区别"><span class="nav-text">静态函数和虚函数的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#指针和引用的区别"><span class="nav-text">指针和引用的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组和指针的区别"><span class="nav-text">数组和指针的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#const-char-，char-，const-char-crr-，char-drr"><span class="nav-text">const char *，char *，const char crr[]，char drr[]</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-里是怎么定义常量的？常量存放在内存的哪个位置？"><span class="nav-text">C++里是怎么定义常量的？常量存放在内存的哪个位置？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sizeof"><span class="nav-text">sizeof</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#空类的大小是多少，如果是派生类呢"><span class="nav-text">空类的大小是多少，如果是派生类呢</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C语言是怎么进行函数调用的"><span class="nav-text">C语言是怎么进行函数调用的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hash函数"><span class="nav-text">Hash函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#哈希冲突的解决"><span class="nav-text">哈希冲突的解决</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式（一）：工厂模式"><span class="nav-text">设计模式（一）：工厂模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式（二）：单例模式"><span class="nav-text">设计模式（二）：单例模式</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhouJie</span>

  
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">陕ICP备19000649号-1</span>
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>



-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <!-- <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"> -->
        <!-- <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script> -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css">
        <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitment({
            id: '1569496432000', 
            owner: 'zj19941113',
            repo: 'zj19941113.github.io',
            
            oauth: {
            
            
                client_secret: '5fc128c4f5668afe365fee33ddae3d01045bd156',
            
                client_id: 'b8b1ba34016a28be9e53'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("4zBHAlw9o2CSjEpTr7lklGEu-gzGzoHsz", "Q0URB4zACHWCSynicJioTJan");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
